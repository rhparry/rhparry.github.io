<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sRNAMap v0.2.8</title>
    <script>
/* fflate 0.8.2 - Fast, lightweight gzip/deflate - https://github.com/101arrowz/fflate @license MIT */
!function(f){typeof module!='undefined'&&typeof exports=='object'?module.exports=f():typeof define!='undefined'&&define.amd?define(f):(typeof self!='undefined'?self:this).fflate=f()}(function(){var _e={};"use strict";var t=(typeof module!='undefined'&&typeof exports=='object'?function(_f){"use strict";var e,t=";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global";try{e=require("worker_threads").Worker}catch(e){}exports.default=e?function(r,n,o,a,s){var u=!1,i=new e(r+t,{eval:!0}).on("error",(function(e){return s(e,null)})).on("message",(function(e){return s(null,e)})).on("exit",(function(e){e&&!u&&s(Error("exited with code "+e),null)}));return i.postMessage(o,a),i.terminate=function(){return u=!0,e.prototype.terminate.call(i)},i}:function(e,t,r,n,o){setImmediate((function(){return o(Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"),null)}));var a=function(){};return{terminate:a,postMessage:a}};return _f}:function(_f){"use strict";var e={};_f.default=function(r,t,s,a,n){var o=new Worker(e[t]||(e[t]=URL.createObjectURL(new Blob([r+';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'],{type:"text/javascript"}))));return o.onmessage=function(e){var r=e.data,t=r.$e$;if(t){var s=Error(t[0]);s.code=t[1],s.stack=t[2],n(s,null)}else n(null,r)},o.postMessage(s,a),o};return _f})({}),n=Uint8Array,r=Uint16Array,e=Int32Array,i=new n([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),o=new n([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new n([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,n){for(var i=new r(31),o=0;o<31;++o)i[o]=n+=1<<t[o-1];var s=new e(i[30]);for(o=1;o<30;++o)for(var a=i[o];a<i[o+1];++a)s[a]=a-i[o]<<5|o;return{b:i,r:s}},u=a(i,2),h=u.b,f=u.r;h[28]=258,f[258]=28;for(var l=a(o,0),c=l.b,p=l.r,v=new r(32768),d=0;d<32768;++d){var g=(43690&d)>>1|(21845&d)<<1;v[d]=((65280&(g=(61680&(g=(52428&g)>>2|(13107&g)<<2))>>4|(3855&g)<<4))>>8|(255&g)<<8)>>1}var y=function(t,n,e){for(var i=t.length,o=0,s=new r(n);o<i;++o)t[o]&&++s[t[o]-1];var a,u=new r(n);for(o=1;o<n;++o)u[o]=u[o-1]+s[o-1]<<1;if(e){a=new r(1<<n);var h=15-n;for(o=0;o<i;++o)if(t[o])for(var f=o<<4|t[o],l=n-t[o],c=u[t[o]-1]++<<l,p=c|(1<<l)-1;c<=p;++c)a[v[c]>>h]=f}else for(a=new r(i),o=0;o<i;++o)t[o]&&(a[o]=v[u[t[o]-1]++]>>15-t[o]);return a},m=new n(288);for(d=0;d<144;++d)m[d]=8;for(d=144;d<256;++d)m[d]=9;for(d=256;d<280;++d)m[d]=7;for(d=280;d<288;++d)m[d]=8;var b=new n(32);for(d=0;d<32;++d)b[d]=5;var w=y(m,9,0),x=y(m,9,1),z=y(b,5,0),k=y(b,5,1),M=function(t){for(var n=t[0],r=1;r<t.length;++r)t[r]>n&&(n=t[r]);return n},S=function(t,n,r){var e=n/8|0;return(t[e]|t[e+1]<<8)>>(7&n)&r},A=function(t,n){var r=n/8|0;return(t[r]|t[r+1]<<8|t[r+2]<<16)>>(7&n)},T=function(t){return(t+7)/8|0},D=function(t,r,e){return(null==r||r<0)&&(r=0),(null==e||e>t.length)&&(e=t.length),new n(t.subarray(r,e))};_e.FlateErrorCode={UnexpectedEOF:0,InvalidBlockType:1,InvalidLengthLiteral:2,InvalidDistance:3,StreamFinished:4,NoStreamHandler:5,InvalidHeader:6,NoCallback:7,InvalidUTF8:8,ExtraFieldTooLong:9,InvalidDate:10,FilenameTooLong:11,StreamFinishing:12,InvalidZipData:13,UnknownCompressionMethod:14};var C=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],I=function(t,n,r){var e=Error(n||C[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,I),!r)throw e;return e},U=function(t,r,e,a){var u=t.length,f=a?a.length:0;if(!u||r.f&&!r.l)return e||new n(0);var l=!e,p=l||2!=r.i,v=r.i;l&&(e=new n(3*u));var d=function(t){var r=e.length;if(t>r){var i=new n(Math.max(2*r,t));i.set(e),e=i}},g=r.f||0,m=r.p||0,b=r.b||0,w=r.l,z=r.d,C=r.m,U=r.n,F=8*u;do{if(!w){g=S(t,m,1);var E=S(t,m+1,3);if(m+=3,!E){var Z=t[(J=T(m)+4)-4]|t[J-3]<<8,q=J+Z;if(q>u){v&&I(0);break}p&&d(b+Z),e.set(t.subarray(J,q),b),r.b=b+=Z,r.p=m=8*q,r.f=g;continue}if(1==E)w=x,z=k,C=9,U=5;else if(2==E){var O=S(t,m,31)+257,G=S(t,m+10,15)+4,L=O+S(t,m+5,31)+1;m+=14;for(var H=new n(L),j=new n(19),N=0;N<G;++N)j[s[N]]=S(t,m+3*N,7);m+=3*G;var P=M(j),B=(1<<P)-1,Y=y(j,P,1);for(N=0;N<L;){var J,K=Y[S(t,m,B)];if(m+=15&K,(J=K>>4)<16)H[N++]=J;else{var Q=0,R=0;for(16==J?(R=3+S(t,m,3),m+=2,Q=H[N-1]):17==J?(R=3+S(t,m,7),m+=3):18==J&&(R=11+S(t,m,127),m+=7);R--;)H[N++]=Q}}var V=H.subarray(0,O),W=H.subarray(O);C=M(V),U=M(W),w=y(V,C,1),z=y(W,U,1)}else I(1);if(m>F){v&&I(0);break}}p&&d(b+131072);for(var X=(1<<C)-1,$=(1<<U)-1,_=m;;_=m){var tt=(Q=w[A(t,m)&X])>>4;if((m+=15&Q)>F){v&&I(0);break}if(Q||I(2),tt<256)e[b++]=tt;else{if(256==tt){_=m,w=null;break}var nt=tt-254;tt>264&&(nt=S(t,m,(1<<(it=i[N=tt-257]))-1)+h[N],m+=it);var rt=z[A(t,m)&$],et=rt>>4;if(rt||I(3),m+=15&rt,W=c[et],et>3){var it=o[et];W+=A(t,m)&(1<<it)-1,m+=it}if(m>F){v&&I(0);break}p&&d(b+131072);var ot=b+nt;if(b<W){var st=f-W,at=Math.min(W,ot);for(st+b<0&&I(3);b<at;++b)e[b]=a[st+b]}for(;b<ot;++b)e[b]=e[b-W]}}r.l=w,r.p=_,r.b=b,r.f=g,w&&(g=1,r.m=C,r.d=z,r.n=U)}while(!g);return b!=e.length&&l?D(e,0,b):e.subarray(0,b)},F=function(t,n,r){var e=n/8|0;t[e]|=r<<=7&n,t[e+1]|=r>>8},E=function(t,n,r){var e=n/8|0;t[e]|=r<<=7&n,t[e+1]|=r>>8,t[e+2]|=r>>16},Z=function(t,e){for(var i=[],o=0;o<t.length;++o)t[o]&&i.push({s:o,f:t[o]});var s=i.length,a=i.slice();if(!s)return{t:N,l:0};if(1==s){var u=new n(i[0].s+1);return u[i[0].s]=1,{t:u,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],f=i[1],l=0,c=1,p=2;for(i[0]={s:-1,f:h.f+f.f,l:h,r:f};c!=s-1;)h=i[i[l].f<i[p].f?l++:p++],f=i[l!=c&&i[l].f<i[p].f?l++:p++],i[c++]={s:-1,f:h.f+f.f,l:h,r:f};var v=a[0].s;for(o=1;o<s;++o)a[o].s>v&&(v=a[o].s);var d=new r(v+1),g=q(i[c-1],d,0);if(g>e){o=0;var y=0,m=g-e,b=1<<m;for(a.sort((function(t,n){return d[n.s]-d[t.s]||t.f-n.f}));o<s;++o){var w=a[o].s;if(!(d[w]>e))break;y+=b-(1<<g-d[w]),d[w]=e}for(y>>=m;y>0;){var x=a[o].s;d[x]<e?y-=1<<e-d[x]++-1:++o}for(;o>=0&&y;--o){var z=a[o].s;d[z]==e&&(--d[z],++y)}g=e}return{t:new n(d),l:g}},q=function(t,n,r){return-1==t.s?Math.max(q(t.l,n,r+1),q(t.r,n,r+1)):n[t.s]=r},O=function(t){for(var n=t.length;n&&!t[--n];);for(var e=new r(++n),i=0,o=t[0],s=1,a=function(t){e[i++]=t},u=1;u<=n;++u)if(t[u]==o&&u!=n)++s;else{if(!o&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(o),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(o);s=1,o=t[u]}return{c:e.subarray(0,i),n:n}},G=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},L=function(t,n,r){var e=r.length,i=T(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var o=0;o<e;++o)t[i+o+4]=r[o];return 8*(i+4+e)},H=function(t,n,e,a,u,h,f,l,c,p,v){F(n,v++,e),++u[256];for(var d=Z(u,15),g=d.t,x=d.l,k=Z(h,15),M=k.t,S=k.l,A=O(g),T=A.c,D=A.n,C=O(M),I=C.c,U=C.n,q=new r(19),H=0;H<T.length;++H)++q[31&T[H]];for(H=0;H<I.length;++H)++q[31&I[H]];for(var j=Z(q,7),N=j.t,P=j.l,B=19;B>4&&!N[s[B-1]];--B);var Y,J,K,Q,R=p+5<<3,V=G(u,m)+G(h,b)+f,W=G(u,g)+G(h,M)+f+14+3*B+G(q,N)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&R<=V&&R<=W)return L(n,v,t.subarray(c,c+p));if(F(n,v,1+(W<V)),v+=2,W<V){Y=y(g,x,0),J=g,K=y(M,S,0),Q=M;var X=y(N,P,0);for(F(n,v,D-257),F(n,v+5,U-1),F(n,v+10,B-4),v+=14,H=0;H<B;++H)F(n,v+3*H,N[s[H]]);v+=3*B;for(var $=[T,I],_=0;_<2;++_){var tt=$[_];for(H=0;H<tt.length;++H)F(n,v,X[rt=31&tt[H]]),v+=N[rt],rt>15&&(F(n,v,tt[H]>>5&127),v+=tt[H]>>12)}}else Y=w,J=m,K=z,Q=b;for(H=0;H<l;++H){var nt=a[H];if(nt>255){var rt;E(n,v,Y[257+(rt=nt>>18&31)]),v+=J[rt+257],rt>7&&(F(n,v,nt>>23&31),v+=i[rt]);var et=31&nt;E(n,v,K[et]),v+=Q[et],et>3&&(E(n,v,nt>>5&8191),v+=o[et])}else E(n,v,Y[nt]),v+=J[nt]}return E(n,v,Y[256]),v+J[256]},j=new e([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),N=new n(0),P=function(t,s,a,u,h,l){var c=l.z||t.length,v=new n(u+c+5*(1+Math.ceil(c/7e3))+h),d=v.subarray(u,v.length-h),g=l.l,y=7&(l.r||0);if(s){y&&(d[0]=l.r>>3);for(var m=j[s-1],b=m>>13,w=8191&m,x=(1<<a)-1,z=l.p||new r(32768),k=l.h||new r(x+1),M=Math.ceil(a/3),S=2*M,A=function(n){return(t[n]^t[n+1]<<M^t[n+2]<<S)&x},C=new e(25e3),I=new r(288),U=new r(32),F=0,E=0,Z=l.i||0,q=0,O=l.w||0,G=0;Z+2<c;++Z){var N=A(Z),P=32767&Z,B=k[N];if(z[P]=B,k[N]=P,O<=Z){var Y=c-Z;if((F>7e3||q>24576)&&(Y>423||!g)){y=H(t,d,0,C,I,U,E,q,G,Z-G,y),q=F=E=0,G=Z;for(var J=0;J<286;++J)I[J]=0;for(J=0;J<30;++J)U[J]=0}var K=2,Q=0,R=w,V=P-B&32767;if(Y>2&&N==A(Z-V))for(var W=Math.min(b,Y)-1,X=Math.min(32767,Z),$=Math.min(258,Y);V<=X&&--R&&P!=B;){if(t[Z+K]==t[Z+K-V]){for(var _=0;_<$&&t[Z+_]==t[Z+_-V];++_);if(_>K){if(K=_,Q=V,_>W)break;var tt=Math.min(V,_-2),nt=0;for(J=0;J<tt;++J){var rt=Z-V+J&32767,et=rt-z[rt]&32767;et>nt&&(nt=et,B=rt)}}}V+=(P=B)-(B=z[P])&32767}if(Q){C[q++]=268435456|f[K]<<18|p[Q];var it=31&f[K],ot=31&p[Q];E+=i[it]+o[ot],++I[257+it],++U[ot],O=Z+K,++F}else C[q++]=t[Z],++I[t[Z]]}}for(Z=Math.max(Z,O);Z<c;++Z)C[q++]=t[Z],++I[t[Z]];y=H(t,d,g,C,I,U,E,q,G,Z-G,y),g||(l.r=7&y|d[y/8|0]<<3,y-=7,l.h=k,l.p=z,l.i=Z,l.w=O)}else{for(Z=l.w||0;Z<c+g;Z+=65535){var st=Z+65535;st>=c&&(d[y/8|0]=g,st=c),y=L(d,y+1,t.subarray(Z,st))}l.i=c}return D(v,0,u+T(y)+h)},B=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),Y=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=B[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},J=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,o=0|r.length,s=0;s!=o;){for(var a=Math.min(s+2655,o);s<a;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},K=function(t,r,e,i,o){if(!o&&(o={l:1},r.dictionary)){var s=r.dictionary.subarray(-32768),a=new n(s.length+t.length);a.set(s),a.set(t,s.length),t=a,o.w=s.length}return P(t,null==r.level?6:r.level,null==r.mem?o.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(t.length)))):20:12+r.mem,e,i,o)},Q=function(t,n){var r={};for(var e in t)r[e]=t[e];for(var e in n)r[e]=n[e];return r},R=function(t,n,r){for(var e=t(),i=""+t,o=i.slice(i.indexOf("[")+1,i.lastIndexOf("]")).replace(/\s+/g,"").split(","),s=0;s<e.length;++s){var a=e[s],u=o[s];if("function"==typeof a){n+=";"+u+"=";var h=""+a;if(a.prototype)if(-1!=h.indexOf("[native code]")){var f=h.indexOf(" ",8)+1;n+=h.slice(f,h.indexOf("(",f))}else for(var l in n+=h,a.prototype)n+=";"+u+".prototype."+l+"="+a.prototype[l];else n+=h}else r[u]=a}return n},V=[],W=function(t){var n=[];for(var r in t)t[r].buffer&&n.push((t[r]=new t[r].constructor(t[r])).buffer);return n},X=function(n,r,e,i){if(!V[e]){for(var o="",s={},a=n.length-1,u=0;u<a;++u)o=R(n[u],o,s);V[e]={c:R(n[a],o,s),e:s}}var h=Q({},V[e].e);return(0,t.default)(V[e].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+r+"}",e,h,W(h),i)},$=function(){return[n,r,e,i,o,s,h,c,x,k,v,C,y,M,S,A,T,D,I,U,Tt,it,ot]},_=function(){return[n,r,e,i,o,s,f,p,w,m,z,b,v,j,N,y,F,E,Z,q,O,G,L,H,T,D,P,K,kt,it]},tt=function(){return[pt,gt,ct,Y,B]},nt=function(){return[vt,dt]},rt=function(){return[yt,ct,J]},et=function(){return[mt]},it=function(t){return postMessage(t,[t.buffer])},ot=function(t){return t&&{out:t.size&&new n(t.size),dictionary:t.dictionary}},st=function(t,n,r,e,i,o){var s=X(r,e,i,(function(t,n){s.terminate(),o(t,n)}));return s.postMessage([t,n],n.consume?[t.buffer]:[]),function(){s.terminate()}},at=function(t){return t.ondata=function(t,n){return postMessage([t,n],[t.buffer])},function(n){n.data.length?(t.push(n.data[0],n.data[1]),postMessage([n.data[0].length])):t.flush()}},ut=function(t,n,r,e,i,o,s){var a,u=X(t,e,i,(function(t,r){t?(u.terminate(),n.ondata.call(n,t)):Array.isArray(r)?1==r.length?(n.queuedSize-=r[0],n.ondrain&&n.ondrain(r[0])):(r[1]&&u.terminate(),n.ondata.call(n,t,r[0],r[1])):s(r)}));u.postMessage(r),n.queuedSize=0,n.push=function(t,r){n.ondata||I(5),a&&n.ondata(I(4,0,1),null,!!r),n.queuedSize+=t.length,u.postMessage([t,a=r],[t.buffer])},n.terminate=function(){u.terminate()},o&&(n.flush=function(){u.postMessage([])})},ht=function(t,n){return t[n]|t[n+1]<<8},ft=function(t,n){return(t[n]|t[n+1]<<8|t[n+2]<<16|t[n+3]<<24)>>>0},lt=function(t,n){return ft(t,n)+4294967296*ft(t,n+4)},ct=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},pt=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&ct(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},vt=function(t){31==t[0]&&139==t[1]&&8==t[2]||I(6,"invalid gzip data");var n=t[3],r=10;4&n&&(r+=2+(t[10]|t[11]<<8));for(var e=(n>>3&1)+(n>>4&1);e>0;e-=!t[r++]);return r+(2&n)},dt=function(t){var n=t.length;return(t[n-4]|t[n-3]<<8|t[n-2]<<16|t[n-1]<<24)>>>0},gt=function(t){return 10+(t.filename?t.filename.length+1:0)},yt=function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=J();i.p(n.dictionary),ct(t,2,i.d())}},mt=function(t,n){return(8!=(15&t[0])||t[0]>>4>7||(t[0]<<8|t[1])%31)&&I(6,"invalid zlib data"),(t[1]>>5&1)==+!n&&I(6,"invalid zlib data: "+(32&t[1]?"need":"unexpected")+" dictionary"),2+(t[1]>>3&4)};function bt(t,n){return"function"==typeof t&&(n=t,t={}),this.ondata=n,t}var wt=function(){function t(t,r){if("function"==typeof t&&(r=t,t={}),this.ondata=r,this.o=t||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new n(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return t.prototype.p=function(t,n){this.ondata(K(t,this.o,0,0,this.s),n)},t.prototype.push=function(t,r){this.ondata||I(5),this.s.l&&I(4);var e=t.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new n(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var o=this.b.length-this.s.z;this.b.set(t.subarray(0,o),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(t.subarray(o),32768),this.s.z=t.length-o+32768,this.s.i=32766,this.s.w=32768}else this.b.set(t,this.s.z),this.s.z+=t.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},t.prototype.flush=function(){this.ondata||I(5),this.s.l&&I(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},t}();_e.Deflate=wt;var xt=function(){return function(t,n){ut([_,function(){return[at,wt]}],this,bt.call(this,t,n),(function(t){var n=new wt(t.data);onmessage=at(n)}),6,1)}}();function zt(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[_],(function(t){return it(kt(t.data[0],t.data[1]))}),0,r)}function kt(t,n){return K(t,n||{},0,0)}_e.AsyncDeflate=xt,_e.deflate=zt,_e.deflateSync=kt;var Mt=function(){function t(t,r){"function"==typeof t&&(r=t,t={}),this.ondata=r;var e=t&&t.dictionary&&t.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new n(32768),this.p=new n(0),e&&this.o.set(e)}return t.prototype.e=function(t){if(this.ondata||I(5),this.d&&I(4),this.p.length){if(t.length){var r=new n(this.p.length+t.length);r.set(this.p),r.set(t,this.p.length),this.p=r}}else this.p=t},t.prototype.c=function(t){this.s.i=+(this.d=t||!1);var n=this.s.b,r=U(this.p,this.s,this.o);this.ondata(D(r,n,this.s.b),this.d),this.o=D(r,this.s.b-32768),this.s.b=this.o.length,this.p=D(this.p,this.s.p/8|0),this.s.p&=7},t.prototype.push=function(t,n){this.e(t),this.c(n)},t}();_e.Inflate=Mt;var St=function(){return function(t,n){ut([$,function(){return[at,Mt]}],this,bt.call(this,t,n),(function(t){var n=new Mt(t.data);onmessage=at(n)}),7,0)}}();function At(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[$],(function(t){return it(Tt(t.data[0],ot(t.data[1])))}),1,r)}function Tt(t,n){return U(t,{i:2},n&&n.out,n&&n.dictionary)}_e.AsyncInflate=St,_e.inflate=At,_e.inflateSync=Tt;var Dt=function(){function t(t,n){this.c=Y(),this.l=0,this.v=1,wt.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),this.l+=t.length,wt.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=K(t,this.o,this.v&&gt(this.o),n&&8,this.s);this.v&&(pt(r,this.o),this.v=0),n&&(ct(r,r.length-8,this.c.d()),ct(r,r.length-4,this.l)),this.ondata(r,n)},t.prototype.flush=function(){wt.prototype.flush.call(this)},t}();_e.Gzip=Dt,_e.Compress=Dt;var Ct=function(){return function(t,n){ut([_,tt,function(){return[at,wt,Dt]}],this,bt.call(this,t,n),(function(t){var n=new Dt(t.data);onmessage=at(n)}),8,1)}}();function It(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[_,tt,function(){return[Ut]}],(function(t){return it(Ut(t.data[0],t.data[1]))}),2,r)}function Ut(t,n){n||(n={});var r=Y(),e=t.length;r.p(t);var i=K(t,n,gt(n),8),o=i.length;return pt(i,n),ct(i,o-8,r.d()),ct(i,o-4,e),i}_e.AsyncGzip=Ct,_e.AsyncCompress=Ct,_e.gzip=It,_e.compress=It,_e.gzipSync=Ut,_e.compressSync=Ut;var Ft=function(){function t(t,n){this.v=1,this.r=0,Mt.call(this,t,n)}return t.prototype.push=function(t,r){if(Mt.prototype.e.call(this,t),this.r+=t.length,this.v){var e=this.p.subarray(this.v-1),i=e.length>3?vt(e):4;if(i>e.length){if(!r)return}else this.v>1&&this.onmember&&this.onmember(this.r-e.length);this.p=e.subarray(i),this.v=0}Mt.prototype.c.call(this,r),!this.s.f||this.s.l||r||(this.v=T(this.s.p)+9,this.s={i:0},this.o=new n(0),this.push(new n(0),r))},t}();_e.Gunzip=Ft;var Et=function(){return function(t,n){var r=this;ut([$,nt,function(){return[at,Mt,Ft]}],this,bt.call(this,t,n),(function(t){var n=new Ft(t.data);n.onmember=function(t){return postMessage(t)},onmessage=at(n)}),9,0,(function(t){return r.onmember&&r.onmember(t)}))}}();function Zt(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[$,nt,function(){return[qt]}],(function(t){return it(qt(t.data[0],t.data[1]))}),3,r)}function qt(t,r){var e=vt(t);return e+8>t.length&&I(6,"invalid gzip data"),U(t.subarray(e,-8),{i:2},r&&r.out||new n(dt(t)),r&&r.dictionary)}_e.AsyncGunzip=Et,_e.gunzip=Zt,_e.gunzipSync=qt;var Ot=function(){function t(t,n){this.c=J(),this.v=1,wt.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),wt.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=K(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(yt(r,this.o),this.v=0),n&&ct(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){wt.prototype.flush.call(this)},t}();_e.Zlib=Ot;var Gt=function(){return function(t,n){ut([_,rt,function(){return[at,wt,Ot]}],this,bt.call(this,t,n),(function(t){var n=new Ot(t.data);onmessage=at(n)}),10,1)}}();function Lt(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[_,rt,function(){return[Ht]}],(function(t){return it(Ht(t.data[0],t.data[1]))}),4,r)}function Ht(t,n){n||(n={});var r=J();r.p(t);var e=K(t,n,n.dictionary?6:2,4);return yt(e,n),ct(e,e.length-4,r.d()),e}_e.AsyncZlib=Gt,_e.zlib=Lt,_e.zlibSync=Ht;var jt=function(){function t(t,n){Mt.call(this,t,n),this.v=t&&t.dictionary?2:1}return t.prototype.push=function(t,n){if(Mt.prototype.e.call(this,t),this.v){if(this.p.length<6&&!n)return;this.p=this.p.subarray(mt(this.p,this.v-1)),this.v=0}n&&(this.p.length<4&&I(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),Mt.prototype.c.call(this,n)},t}();_e.Unzlib=jt;var Nt=function(){return function(t,n){ut([$,et,function(){return[at,Mt,jt]}],this,bt.call(this,t,n),(function(t){var n=new jt(t.data);onmessage=at(n)}),11,0)}}();function Pt(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),st(t,n,[$,et,function(){return[Bt]}],(function(t){return it(Bt(t.data[0],ot(t.data[1])))}),5,r)}function Bt(t,n){return U(t.subarray(mt(t,n&&n.dictionary),-4),{i:2},n&&n.out,n&&n.dictionary)}_e.AsyncUnzlib=Nt,_e.unzlib=Pt,_e.unzlibSync=Bt;var Yt=function(){function t(t,n){this.o=bt.call(this,t,n)||{},this.G=Ft,this.I=Mt,this.Z=jt}return t.prototype.i=function(){var t=this;this.s.ondata=function(n,r){t.ondata(n,r)}},t.prototype.push=function(t,r){if(this.ondata||I(5),this.s)this.s.push(t,r);else{if(this.p&&this.p.length){var e=new n(this.p.length+t.length);e.set(this.p),e.set(t,this.p.length)}else this.p=t;this.p.length>2&&(this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(this.o):8!=(15&this.p[0])||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(this.o):new this.Z(this.o),this.i(),this.s.push(this.p,r),this.p=null)}},t}();_e.Decompress=Yt;var Jt=function(){function t(t,n){Yt.call(this,t,n),this.queuedSize=0,this.G=Et,this.I=St,this.Z=Nt}return t.prototype.i=function(){var t=this;this.s.ondata=function(n,r,e){t.ondata(n,r,e)},this.s.ondrain=function(n){t.queuedSize-=n,t.ondrain&&t.ondrain(n)}},t.prototype.push=function(t,n){this.queuedSize+=t.length,Yt.prototype.push.call(this,t,n)},t}();function Kt(t,n,r){return r||(r=n,n={}),"function"!=typeof r&&I(7),31==t[0]&&139==t[1]&&8==t[2]?Zt(t,n,r):8!=(15&t[0])||t[0]>>4>7||(t[0]<<8|t[1])%31?At(t,n,r):Pt(t,n,r)}function Qt(t,n){return 31==t[0]&&139==t[1]&&8==t[2]?qt(t,n):8!=(15&t[0])||t[0]>>4>7||(t[0]<<8|t[1])%31?Tt(t,n):Bt(t,n)}_e.AsyncDecompress=Jt,_e.decompress=Kt,_e.decompressSync=Qt;var Rt=function(t,r,e,i){for(var o in t){var s=t[o],a=r+o,u=i;Array.isArray(s)&&(u=Q(i,s[1]),s=s[0]),s instanceof n?e[a]=[s,u]:(e[a+="/"]=[new n(0),u],Rt(s,a,e,i))}},Vt="undefined"!=typeof TextEncoder&&new TextEncoder,Wt="undefined"!=typeof TextDecoder&&new TextDecoder,Xt=0;try{Wt.decode(N,{stream:!0}),Xt=1}catch(t){}var $t=function(t){for(var n="",r=0;;){var e=t[r++],i=(e>127)+(e>223)+(e>239);if(r+i>t.length)return{s:n,r:D(t,r-1)};i?3==i?(e=((15&e)<<18|(63&t[r++])<<12|(63&t[r++])<<6|63&t[r++])-65536,n+=String.fromCharCode(55296|e>>10,56320|1023&e)):n+=String.fromCharCode(1&i?(31&e)<<6|63&t[r++]:(15&e)<<12|(63&t[r++])<<6|63&t[r++]):n+=String.fromCharCode(e)}},_t=function(){function t(t){this.ondata=t,Xt?this.t=new TextDecoder:this.p=N}return t.prototype.push=function(t,r){if(this.ondata||I(5),r=!!r,this.t)return this.ondata(this.t.decode(t,{stream:!0}),r),void(r&&(this.t.decode().length&&I(8),this.t=null));this.p||I(4);var e=new n(this.p.length+t.length);e.set(this.p),e.set(t,this.p.length);var i=$t(e),o=i.s,s=i.r;r?(s.length&&I(8),this.p=null):this.p=s,this.ondata(o,r)},t}();_e.DecodeUTF8=_t;var tn=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||I(5),this.d&&I(4),this.ondata(nn(t),this.d=n||!1)},t}();function nn(t,r){if(r){for(var e=new n(t.length),i=0;i<t.length;++i)e[i]=t.charCodeAt(i);return e}if(Vt)return Vt.encode(t);var o=t.length,s=new n(t.length+(t.length>>1)),a=0,u=function(t){s[a++]=t};for(i=0;i<o;++i){if(a+5>s.length){var h=new n(a+8+(o-i<<1));h.set(s),s=h}var f=t.charCodeAt(i);f<128||r?u(f):f<2048?(u(192|f>>6),u(128|63&f)):f>55295&&f<57344?(u(240|(f=65536+(1047552&f)|1023&t.charCodeAt(++i))>>18),u(128|f>>12&63),u(128|f>>6&63),u(128|63&f)):(u(224|f>>12),u(128|f>>6&63),u(128|63&f))}return D(s,0,a)}function rn(t,n){if(n){for(var r="",e=0;e<t.length;e+=16384)r+=String.fromCharCode.apply(null,t.subarray(e,e+16384));return r}if(Wt)return Wt.decode(t);var i=$t(t),o=i.s;return(r=i.r).length&&I(8),o}_e.EncodeUTF8=tn,_e.strToU8=nn,_e.strFromU8=rn;var en=function(t){return 1==t?3:t<6?2:9==t?1:0},on=function(t,n){return n+30+ht(t,n+26)+ht(t,n+28)},sn=function(t,n,r){var e=ht(t,n+28),i=rn(t.subarray(n+46,n+46+e),!(2048&ht(t,n+8))),o=n+46+e,s=ft(t,n+20),a=r&&4294967295==s?an(t,o):[s,ft(t,n+24),ft(t,n+42)],u=a[0],h=a[1],f=a[2];return[ht(t,n+10),u,h,i,o+ht(t,n+30)+ht(t,n+32),f]},an=function(t,n){for(;1!=ht(t,n);n+=4+ht(t,n+2));return[lt(t,n+12),lt(t,n+4),lt(t,n+20)]},un=function(t){var n=0;if(t)for(var r in t){var e=t[r].length;e>65535&&I(9),n+=e+4}return n},hn=function(t,n,r,e,i,o,s,a){var u=e.length,h=r.extra,f=a&&a.length,l=un(h);ct(t,n,null!=s?33639248:67324752),n+=4,null!=s&&(t[n++]=20,t[n++]=r.os),t[n]=20,n+=2,t[n++]=r.flag<<1|(o<0&&8),t[n++]=i&&8,t[n++]=255&r.compression,t[n++]=r.compression>>8;var c=new Date(null==r.mtime?Date.now():r.mtime),p=c.getFullYear()-1980;if((p<0||p>119)&&I(10),ct(t,n,p<<25|c.getMonth()+1<<21|c.getDate()<<16|c.getHours()<<11|c.getMinutes()<<5|c.getSeconds()>>1),n+=4,-1!=o&&(ct(t,n,r.crc),ct(t,n+4,o<0?-o-2:o),ct(t,n+8,r.size)),ct(t,n+12,u),ct(t,n+14,l),n+=16,null!=s&&(ct(t,n,f),ct(t,n+6,r.attrs),ct(t,n+10,s),n+=14),t.set(e,n),n+=u,l)for(var v in h){var d=h[v],g=d.length;ct(t,n,+v),ct(t,n+2,g),t.set(d,n+4),n+=4+g}return f&&(t.set(a,n),n+=f),n},fn=function(t,n,r,e,i){ct(t,n,101010256),ct(t,n+8,r),ct(t,n+10,r),ct(t,n+12,e),ct(t,n+16,i)},ln=function(){function t(t){this.filename=t,this.c=Y(),this.size=0,this.compression=0}return t.prototype.process=function(t,n){this.ondata(null,t,n)},t.prototype.push=function(t,n){this.ondata||I(5),this.c.p(t),this.size+=t.length,n&&(this.crc=this.c.d()),this.process(t,n||!1)},t}();_e.ZipPassThrough=ln;var cn=function(){function t(t,n){var r=this;n||(n={}),ln.call(this,t),this.d=new wt(n,(function(t,n){r.ondata(null,t,n)})),this.compression=8,this.flag=en(n.level)}return t.prototype.process=function(t,n){try{this.d.push(t,n)}catch(t){this.ondata(t,null,n)}},t.prototype.push=function(t,n){ln.prototype.push.call(this,t,n)},t}();_e.ZipDeflate=cn;var pn=function(){function t(t,n){var r=this;n||(n={}),ln.call(this,t),this.d=new xt(n,(function(t,n,e){r.ondata(t,n,e)})),this.compression=8,this.flag=en(n.level),this.terminate=this.d.terminate}return t.prototype.process=function(t,n){this.d.push(t,n)},t.prototype.push=function(t,n){ln.prototype.push.call(this,t,n)},t}();_e.AsyncZipDeflate=pn;var vn=function(){function t(t){this.ondata=t,this.u=[],this.d=1}return t.prototype.add=function(t){var r=this;if(this.ondata||I(5),2&this.d)this.ondata(I(4+8*(1&this.d),0,1),null,!1);else{var e=nn(t.filename),i=e.length,o=t.comment,s=o&&nn(o),a=i!=t.filename.length||s&&o.length!=s.length,u=i+un(t.extra)+30;i>65535&&this.ondata(I(11,0,1),null,!1);var h=new n(u);hn(h,0,t,e,a,-1);var f=[h],l=function(){for(var t=0,n=f;t<n.length;t++)r.ondata(null,n[t],!1);f=[]},c=this.d;this.d=0;var p=this.u.length,v=Q(t,{f:e,u:a,o:s,t:function(){t.terminate&&t.terminate()},r:function(){if(l(),c){var t=r.u[p+1];t?t.r():r.d=1}c=1}}),d=0;t.ondata=function(e,i,o){if(e)r.ondata(e,i,o),r.terminate();else if(d+=i.length,f.push(i),o){var s=new n(16);ct(s,0,134695760),ct(s,4,t.crc),ct(s,8,d),ct(s,12,t.size),f.push(s),v.c=d,v.b=u+d+16,v.crc=t.crc,v.size=t.size,c&&v.r(),c=1}else c&&l()},this.u.push(v)}},t.prototype.end=function(){var t=this;2&this.d?this.ondata(I(4+8*(1&this.d),0,1),null,!0):(this.d?this.e():this.u.push({r:function(){1&t.d&&(t.u.splice(-1,1),t.e())},t:function(){}}),this.d=3)},t.prototype.e=function(){for(var t=0,r=0,e=0,i=0,o=this.u;i<o.length;i++)e+=46+(h=o[i]).f.length+un(h.extra)+(h.o?h.o.length:0);for(var s=new n(e+22),a=0,u=this.u;a<u.length;a++){var h;hn(s,t,h=u[a],h.f,h.u,-h.c-2,r,h.o),t+=46+h.f.length+un(h.extra)+(h.o?h.o.length:0),r+=h.b}fn(s,t,this.u.length,e,r),this.ondata(null,s,!0),this.d=2},t.prototype.terminate=function(){for(var t=0,n=this.u;t<n.length;t++)n[t].t();this.d=2},t}();function dn(t,r,e){e||(e=r,r={}),"function"!=typeof e&&I(7);var i={};Rt(t,"",i,r);var o=Object.keys(i),s=o.length,a=0,u=0,h=s,f=Array(s),l=[],c=function(){for(var t=0;t<l.length;++t)l[t]()},p=function(t,n){xn((function(){e(t,n)}))};xn((function(){p=e}));var v=function(){var t=new n(u+22),r=a,e=u-a;u=0;for(var i=0;i<h;++i){var o=f[i];try{var s=o.c.length;hn(t,u,o,o.f,o.u,s);var l=30+o.f.length+un(o.extra),c=u+l;t.set(o.c,c),hn(t,a,o,o.f,o.u,s,u,o.m),a+=16+l+(o.m?o.m.length:0),u=c+s}catch(t){return p(t,null)}}fn(t,a,f.length,e,r),p(null,t)};s||v();for(var d=function(t){var n=o[t],r=i[n],e=r[0],h=r[1],d=Y(),g=e.length;d.p(e);var y=nn(n),m=y.length,b=h.comment,w=b&&nn(b),x=w&&w.length,z=un(h.extra),k=0==h.level?0:8,M=function(r,e){if(r)c(),p(r,null);else{var i=e.length;f[t]=Q(h,{size:g,crc:d.d(),c:e,f:y,m:w,u:m!=n.length||w&&b.length!=x,compression:k}),a+=30+m+z+i,u+=76+2*(m+z)+(x||0)+i,--s||v()}};if(m>65535&&M(I(11,0,1),null),k)if(g<16e4)try{M(null,kt(e,h))}catch(t){M(t,null)}else l.push(zt(e,h,M));else M(null,e)},g=0;g<h;++g)d(g);return c}function gn(t,r){r||(r={});var e={},i=[];Rt(t,"",e,r);var o=0,s=0;for(var a in e){var u=e[a],h=u[0],f=u[1],l=0==f.level?0:8,c=(M=nn(a)).length,p=f.comment,v=p&&nn(p),d=v&&v.length,g=un(f.extra);c>65535&&I(11);var y=l?kt(h,f):h,m=y.length,b=Y();b.p(h),i.push(Q(f,{size:h.length,crc:b.d(),c:y,f:M,m:v,u:c!=a.length||v&&p.length!=d,o:o,compression:l})),o+=30+c+g+m,s+=76+2*(c+g)+(d||0)+m}for(var w=new n(s+22),x=o,z=s-o,k=0;k<i.length;++k){var M;hn(w,(M=i[k]).o,M,M.f,M.u,M.c.length);var S=30+M.f.length+un(M.extra);w.set(M.c,M.o+S),hn(w,o,M,M.f,M.u,M.c.length,M.o,M.m),o+=16+S+(M.m?M.m.length:0)}return fn(w,o,i.length,z,x),w}_e.Zip=vn,_e.zip=dn,_e.zipSync=gn;var yn=function(){function t(){}return t.prototype.push=function(t,n){this.ondata(null,t,n)},t.compression=0,t}();_e.UnzipPassThrough=yn;var mn=function(){function t(){var t=this;this.i=new Mt((function(n,r){t.ondata(null,n,r)}))}return t.prototype.push=function(t,n){try{this.i.push(t,n)}catch(t){this.ondata(t,null,n)}},t.compression=8,t}();_e.UnzipInflate=mn;var bn=function(){function t(t,n){var r=this;n<32e4?this.i=new Mt((function(t,n){r.ondata(null,t,n)})):(this.i=new St((function(t,n,e){r.ondata(t,n,e)})),this.terminate=this.i.terminate)}return t.prototype.push=function(t,n){this.i.terminate&&(t=D(t,0)),this.i.push(t,n)},t.compression=8,t}();_e.AsyncUnzipInflate=bn;var wn=function(){function t(t){this.onfile=t,this.k=[],this.o={0:yn},this.p=N}return t.prototype.push=function(t,r){var e=this;if(this.onfile||I(5),this.p||I(4),this.c>0){var i=Math.min(this.c,t.length),o=t.subarray(0,i);if(this.c-=i,this.d?this.d.push(o,!this.c):this.k[0].push(o),(t=t.subarray(i)).length)return this.push(t,r)}else{var s=0,a=0,u=void 0,h=void 0;this.p.length?t.length?((h=new n(this.p.length+t.length)).set(this.p),h.set(t,this.p.length)):h=this.p:h=t;for(var f=h.length,l=this.c,c=l&&this.d,p=function(){var t,n=ft(h,a);if(67324752==n){s=1,u=a,v.d=null,v.c=0;var r=ht(h,a+6),i=ht(h,a+8),o=2048&r,c=8&r,p=ht(h,a+26),d=ht(h,a+28);if(f>a+30+p+d){var g=[];v.k.unshift(g),s=2;var y,m=ft(h,a+18),b=ft(h,a+22),w=rn(h.subarray(a+30,a+=30+p),!o);4294967295==m?(t=c?[-2]:an(h,a),m=t[0],b=t[1]):c&&(m=-1),a+=d,v.c=m;var x={name:w,compression:i,start:function(){if(x.ondata||I(5),m){var t=e.o[i];t||x.ondata(I(14,"unknown compression type "+i,1),null,!1),(y=m<0?new t(w):new t(w,m,b)).ondata=function(t,n,r){x.ondata(t,n,r)};for(var n=0,r=g;n<r.length;n++)y.push(r[n],!1);e.k[0]==g&&e.c?e.d=y:y.push(N,!0)}else x.ondata(null,N,!0)},terminate:function(){y&&y.terminate&&y.terminate()}};m>=0&&(x.size=m,x.originalSize=b),v.onfile(x)}return"break"}if(l){if(134695760==n)return u=a+=12+(-2==l&&8),s=3,v.c=0,"break";if(33639248==n)return u=a-=4,s=3,v.c=0,"break"}},v=this;a<f-4&&"break"!==p();++a);if(this.p=N,l<0){var d=h.subarray(0,s?u-12-(-2==l&&8)-(134695760==ft(h,u-16)&&4):a);c?c.push(d,!!s):this.k[+(2==s)].push(d)}if(2&s)return this.push(h.subarray(a),r);this.p=h.subarray(a)}r&&(this.c&&I(13),this.p=null)},t.prototype.register=function(t){this.o[t.compression]=t},t}();_e.Unzip=wn;var xn="function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout?setTimeout:function(t){t()};function zn(t,r,e){e||(e=r,r={}),"function"!=typeof e&&I(7);var i=[],o=function(){for(var t=0;t<i.length;++t)i[t]()},s={},a=function(t,n){xn((function(){e(t,n)}))};xn((function(){a=e}));for(var u=t.length-22;101010256!=ft(t,u);--u)if(!u||t.length-u>65558)return a(I(13,0,1),null),o;var h=ht(t,u+8);if(h){var f=h,l=ft(t,u+16),c=4294967295==l||65535==f;if(c){var p=ft(t,u-12);(c=101075792==ft(t,p))&&(f=h=ft(t,p+32),l=ft(t,p+48))}for(var v=r&&r.filter,d=function(r){var e=sn(t,l,c),u=e[0],f=e[1],p=e[2],d=e[3],g=e[4],y=on(t,e[5]);l=g;var m=function(t,n){t?(o(),a(t,null)):(n&&(s[d]=n),--h||a(null,s))};if(!v||v({name:d,size:f,originalSize:p,compression:u}))if(u)if(8==u){var b=t.subarray(y,y+f);if(p<524288||f>.8*p)try{m(null,Tt(b,{out:new n(p)}))}catch(t){m(t,null)}else i.push(At(b,{size:p},m))}else m(I(14,"unknown compression type "+u,1),null);else m(null,D(t,y,y+f));else m(null,null)},g=0;g<f;++g)d()}else a(null,{});return o}function kn(t,r){for(var e={},i=t.length-22;101010256!=ft(t,i);--i)(!i||t.length-i>65558)&&I(13);var o=ht(t,i+8);if(!o)return{};var s=ft(t,i+16),a=4294967295==s||65535==o;if(a){var u=ft(t,i-12);(a=101075792==ft(t,u))&&(o=ft(t,u+32),s=ft(t,u+48))}for(var h=r&&r.filter,f=0;f<o;++f){var l=sn(t,s,a),c=l[0],p=l[1],v=l[2],d=l[3],g=l[4],y=on(t,l[5]);s=g,h&&!h({name:d,size:p,originalSize:v,compression:c})||(c?8==c?e[d]=Tt(t.subarray(y,y+p),{out:new n(v)}):I(14,"unknown compression type "+c):e[d]=D(t,y,y+p))}return e}_e.unzip=zn,_e.unzipSync=kn;return _e});
    </script>
    <style>
        :root { --bg: #fff; --bg2: #f8f9fa; --bg3: #f0f2f4; --bg-alt: #e8eaed; --text: #1a1a2e; --text2: #2a3a4e; --muted: #4a5a6a; --accent: #0055bb; --primary: #0055bb; --border: #c0c8d0; --focus: #0055bb; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); font-size: 16px; line-height: 1.6; }
        .container { max-width: 1450px; margin: 0 auto; padding: 1.25rem; }
        header { margin-bottom: 1.25rem; padding-bottom: 1rem; border-bottom: 2px solid var(--border); }
        h1 { font-size: 2rem; margin-bottom: 0.25rem; }
        h1 span { color: var(--accent); }
        .subtitle { font-size: 1rem; color: var(--text2); }
        .attribution { font-size: 0.875rem; color: var(--muted); margin-top: 0.25rem; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.25rem; margin-bottom: 1.25rem; }
        .box { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem; }
        .box h3 { font-size: 0.95rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text2); margin-bottom: 0.75rem; font-weight: 600; }
        .drop { border: 2px dashed var(--border); border-radius: 6px; padding: 2rem; text-align: center; cursor: pointer; background: var(--bg); transition: all 0.2s; }
        .drop:hover, .drop:focus-within { border-color: var(--accent); background: rgba(0,85,187,0.04); }
        .drop input { display: none; }
        .drop-text { font-size: 1rem; color: var(--text2); pointer-events: none; }
        .drop-text strong { color: var(--accent); text-decoration: underline; }
        .drop * { pointer-events: none; }
        .file-info { margin-top: 0.75rem; padding: 0.5rem 0.75rem; background: var(--bg3); border-radius: 4px; font-size: 0.95rem; display: none; color: var(--accent); font-weight: 500; }
        .file-info.show { display: block; }
        textarea { width: 100%; height: 80px; border: 1px solid var(--border); border-radius: 4px; padding: 0.6rem; font-size: 0.95rem; font-family: monospace; resize: vertical; margin-top: 0.75rem; }
        textarea:focus { outline: 3px solid var(--focus); outline-offset: 1px; border-color: var(--focus); }
        .row { display: flex; gap: 0.75rem; margin-top: 0.75rem; flex-wrap: wrap; align-items: center; }
        .setting { display: flex; align-items: center; gap: 0.4rem; }
        .setting label { font-size: 0.9rem; color: var(--text2); white-space: nowrap; font-weight: 500; }
        .setting input, .setting select { font-size: 0.9rem; padding: 0.35rem 0.5rem; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); }
        .setting input:focus, .setting select:focus { outline: 3px solid var(--focus); outline-offset: 1px; border-color: var(--focus); }
        .setting input[type="number"] { width: 60px; }
        .setting input[type="color"] { width: 32px; height: 28px; padding: 2px; border: 1px solid var(--border); cursor: pointer; border-radius: 4px; }
        .setting input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent); }
        button { font-size: 0.95rem; padding: 0.65rem 1.25rem; border: none; border-radius: 5px; cursor: pointer; transition: all 0.15s; font-weight: 500; }
        button:focus { outline: 3px solid var(--focus); outline-offset: 2px; }
        .btn-primary { background: var(--accent); color: #fff; }
        .btn-primary:hover { background: #004499; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: var(--bg3); color: var(--text2); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--border); }
        .btn-small { padding: 0.35rem 0.7rem; font-size: 0.85rem; }
        .progress { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; margin-bottom: 1.25rem; display: none; }
        .progress.show { display: block; }
        .progress-bar { height: 8px; background: var(--bg3); border-radius: 4px; overflow: hidden; margin-top: 0.6rem; }
        .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }
        .results { display: none; }
        .results.show { display: block; }
        .stats { display: grid; grid-template-columns: repeat(7, 1fr); gap: 0.75rem; margin-bottom: 1.25rem; }
        .stat { background: var(--bg2); border: 1px solid var(--border); border-radius: 6px; padding: 0.85rem; text-align: center; }
        .stat-label { font-size: 0.8rem; text-transform: uppercase; color: var(--muted); font-weight: 600; letter-spacing: 0.03em; }
        .stat-value { font-size: 1.4rem; font-weight: 700; color: var(--accent); margin-top: 0.2rem; }
        .panel { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem; margin-bottom: 1.25rem; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; flex-wrap: wrap; gap: 0.5rem; }
        .panel-header h3 { font-size: 0.95rem; text-transform: uppercase; color: var(--text2); letter-spacing: 0.03em; font-weight: 600; }
        .panel-controls { display: flex; gap: 0.4rem; flex-wrap: wrap; }
        .viz-controls { display: flex; gap: 0.85rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.75rem; padding: 0.7rem 0.85rem; background: var(--bg3); border-radius: 5px; }
        .legend { display: flex; gap: 0.85rem; font-size: 0.85rem; color: var(--text2); margin-bottom: 0.5rem; font-weight: 500; }
        .legend-item { display: flex; align-items: center; gap: 0.35rem; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.15); }
        canvas { background: #fff; display: block; }
        .panel-info { font-size: 0.85rem; color: var(--muted); margin-top: 0.5rem; }
        .panel-desc { font-size: 0.9rem; color: var(--text2); margin-top: 0.75rem; padding: 0.6rem 0.85rem; background: var(--bg3); border-radius: 4px; border-left: 4px solid var(--accent); }
        footer { text-align: center; font-size: 0.85rem; color: var(--muted); padding-top: 1rem; border-top: 1px solid var(--border); margin-top: 1.25rem; }
        /* Skip link for keyboard navigation */
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--accent); color: #fff; padding: 8px 16px; z-index: 100; border-radius: 0 0 4px 0; font-size: 1rem; }
        .skip-link:focus { top: 0; }
        /* High contrast focus indicators */
        a:focus, summary:focus { outline: 3px solid var(--focus); outline-offset: 2px; }
        details summary { cursor: pointer; }
        details summary:hover { color: var(--accent); }
        @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } .stats { grid-template-columns: repeat(4, 1fr); } }
        @media (prefers-reduced-motion: reduce) { *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; } }
        /* Collapsible aesthetics panel */
        .aesthetics-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 420px;
            transition: all 0.2s ease;
        }
        .aesthetics-panel.collapsed .aesthetics-content {
            display: none;
        }
        .aesthetics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.9rem;
            cursor: pointer;
            background: var(--bg3);
            border-radius: 7px 7px 0 0;
            user-select: none;
        }
        .aesthetics-panel.collapsed .aesthetics-header {
            border-radius: 7px;
        }
        .aesthetics-header h4 {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--text2);
            letter-spacing: 0.03em;
            font-weight: 600;
            margin: 0;
        }
        .aesthetics-toggle {
            font-size: 1.1rem;
            color: var(--muted);
            transition: transform 0.2s;
        }
        .aesthetics-panel.collapsed .aesthetics-toggle {
            transform: rotate(-90deg);
        }
        .aesthetics-content {
            padding: 0.75rem;
            max-height: 70vh;
            overflow-y: auto;
        }
        .aesthetics-content .row {
            margin-top: 0.5rem;
        }
        .aesthetics-content .row:first-child {
            margin-top: 0;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>sRNA<span>Map</span> <span style="font-size:0.6rem;color:var(--muted)">v0.2.8</span></h1>
        <p class="subtitle">Browser-based small RNA mapping and signature analysis</p>
        <p class="attribution">Created by Rhys H Parry ‚Äî <a href="/cdn-cgi/l/email-protection#b6c498c6d7c4c4cff6c3c798d3d2c398d7c3"><span class="__cf_email__" data-cfemail="0c7e227c6d7e7e754c797d22696879226d79">[email&#160;protected]</span></a> ‚Äî The University of Queensland</p>
    </header>

    <div class="grid">
        <div class="box">
            <h3 id="ref-heading">Reference (FASTA ‚Äî multi-segment supported)</h3>
            <div class="drop" id="ref-drop" role="button" tabindex="0" aria-labelledby="ref-heading"><input type="file" id="ref-file" accept=".fasta,.fa,.fna,.txt" aria-label="Upload reference FASTA file"><p class="drop-text">Drop FASTA or <strong>click to browse</strong></p></div>
            <div class="file-info" id="ref-info" role="status" aria-live="polite"></div>
            <!-- Recent references dropdown -->
            <div class="row" style="margin-top:8px;align-items:center;">
                <div class="setting" style="flex:1;">
                    <label for="recent-refs" style="font-weight:600;">üìÅ Recent references:</label>
                    <select id="recent-refs" style="min-width:200px;" title="Load a previously used reference">
                        <option value="">-- Select saved reference --</option>
                    </select>
                </div>
                <button class="btn-secondary btn-small" id="save-ref-btn" title="Save current reference for later use">Save ref</button>
                <button class="btn-secondary btn-small" id="delete-ref-btn" title="Delete selected reference">Delete</button>
            </div>
            <textarea id="ref-text" aria-label="Paste reference sequence" placeholder=">segment1&#10;ATGCATGC...&#10;>segment2&#10;GCTAGCTA..."></textarea>
        </div>
        <div class="box">
            <h3 id="reads-heading">Reads (FASTQ/FASTA ‚Äî multiple files = replicates)</h3>
            <div class="drop" id="reads-drop" role="button" tabindex="0" aria-labelledby="reads-heading"><input type="file" id="reads-file" accept=".fastq,.fq,.fasta,.fa,.gz,.fastq.gz,.fq.gz" multiple aria-label="Upload read files"><p class="drop-text">Drop files or <strong>click to browse</strong> (supports .gz)</p></div>
            <div class="file-info" id="reads-info" role="status" aria-live="polite"></div>
            
            <!-- Experiment name -->
            <div class="row" style="margin-top:8px;">
                <div class="setting" style="flex:1;"><label for="experiment-name">Experiment name:</label><input type="text" id="experiment-name" placeholder="e.g., WT_rep1-3_SFV4" style="min-width:250px;" title="Name for this analysis (used in cache)"></div>
            </div>
            
            <!-- Cache controls -->
            <div class="row" style="margin-top:8px;padding:8px;background:var(--bg-secondary);border-radius:4px;">
                <div class="setting" style="flex:1;">
                    <label style="font-weight:600;">üíæ Cached Results:</label>
                    <select id="cache-select" style="min-width:200px;" title="Load previously processed results">
                        <option value="">-- Select saved analysis --</option>
                    </select>
                </div>
                <button class="btn-secondary btn-small" id="cache-load-btn" title="Load selected cached results">Load</button>
                <button class="btn-secondary btn-small" id="cache-delete-btn" title="Delete selected cached results">Delete</button>
                <button class="btn-secondary btn-small" id="cache-clear-btn" title="Clear all cached results" style="color:#c53030;">Clear All</button>
            </div>
            <div class="row" style="font-size:0.75rem;color:var(--muted);margin-top:4px;">
                <span id="cache-info">Cache: checking...</span>
                <label style="margin-left:8px;"><input type="checkbox" id="cache-enabled" checked> Auto-save</label>
                <button class="btn-secondary btn-small" id="import-json-btn" style="margin-left:auto;font-size:0.7rem;" title="Import previously exported JSON results">Import JSON</button>
                <input type="file" id="import-json-file" accept=".json" style="display:none;">
            </div>
            
            <div class="row">
                <div class="setting"><label for="kmer">k-mer:</label><input type="number" id="kmer" value="15" min="8" max="21" title="K-mer size for indexing (8-21)"></div>
                <div class="setting"><label for="seeds">Seeds:</label><input type="number" id="seeds" value="1" min="1" title="Number of seed hits required"></div>
                <div class="setting"><label for="mismatch">Mismatch:</label><input type="number" id="mismatch" value="2" min="0" max="5" title="Maximum mismatches allowed (0-5)"></div>
                <div class="setting"><label for="mm-penalty">MM penalty:</label><input type="number" id="mm-penalty" value="2" min="1" max="5" step="0.5" title="Mismatch penalty score"></div>
            </div>
            <div class="row">
                <div class="setting"><label for="minlen">Read length:</label><input type="number" id="minlen" value="18" min="10" max="50" title="Minimum read length">‚Äì<input type="number" id="maxlen" value="30" min="10" max="50" title="Maximum read length"></div>
                <div class="setting"><label><input type="checkbox" id="adaptive-seed" checked> Adaptive seeding</label></div>
            </div>
            <div class="row">
                <div class="setting"><label for="max-reads">Max reads:</label><input type="number" id="max-reads" value="0" min="0" step="100000" title="Maximum reads per file (0 = all reads)"><span style="font-size:0.7rem;color:var(--muted);margin-left:4px;">(0=all)</span></div>
                <div class="setting"><label for="num-workers">Threads:</label><input type="number" id="num-workers" value="0" min="0" max="16" step="1" title="Number of worker threads (0 = auto based on CPU)"><span style="font-size:0.7rem;color:var(--muted);margin-left:4px;">(0=auto)</span></div>
                <div class="setting"><label><input type="checkbox" id="low-memory-mode"> Low memory mode</label><span style="font-size:0.7rem;color:var(--muted);margin-left:4px;" title="Discard read sequences after mapping to save RAM">(slower)</span></div>
            </div>
            <div class="row">
                <div class="setting"><label for="multi-map">Multi-map:</label><select id="multi-map" title="How to handle reads mapping to multiple locations">
                    <option value="best">Best only</option>
                    <option value="all-best">All equally best</option>
                    <option value="random">Random best</option>
                </select></div>
                <div class="setting"><label for="max-loci">Max loci:</label><input type="number" id="max-loci" value="10" min="1" max="100" title="Maximum mapping locations to report"></div>
            </div>
            <div class="row">
                <div class="setting"><label><input type="checkbox" id="no-3prime-mm"> No 3‚Ä≤ mismatch</label><span style="font-size:0.7rem;color:var(--muted);margin-left:4px;" title="Exclude alignments with mismatch at 3' end (filters soft-clipped/NTA reads)">(filter NTA)</span></div>
                <div class="setting"><label><input type="checkbox" id="n-as-match"> N = match</label><span style="font-size:0.7rem;color:var(--muted);margin-left:4px;" title="Treat N bases as matching any nucleotide">(allow ambiguous)</span></div>
            </div>
            <div class="row">
                <div class="setting"><label for="qmin">Query:</label><input type="number" id="qmin" value="18" min="10" title="Query length minimum">‚Äì<input type="number" id="qmax" value="30" min="10" title="Query length maximum"></div>
                <div class="setting"><label for="tmin">Target:</label><input type="number" id="tmin" value="18" min="10" title="Target length minimum">‚Äì<input type="number" id="tmax" value="30" min="10" title="Target length maximum"></div>
            </div>
            <div class="row">
                <div class="setting"><label for="omin">Overlap:</label><input type="number" id="omin" value="-10" min="-30" title="Overlap minimum (negative = gap)">‚Äì<input type="number" id="omax" value="30" min="-30" title="Overlap maximum"></div>
            </div>
        </div>
    </div>

    <!-- Collapsible Aesthetics Panel (floating, top-right) -->
    <div class="aesthetics-panel" id="aesthetics-panel">
        <div class="aesthetics-header" id="aesthetics-toggle">
            <h4>‚öô Display Settings</h4>
            <span class="aesthetics-toggle">‚ñº</span>
        </div>
        <div class="aesthetics-content">
            <div class="row">
                <div class="setting"><label for="color-palette">Palette:</label><select id="color-palette" title="Color scheme for nucleotide visualization">
                    <option value="default">Default</option>
                    <option value="pastel">Pastel</option>
                    <option value="viridis">Viridis</option>
                    <option value="colorblind">Colorblind-friendly</option>
                </select></div>
                <div class="setting"><label for="font-family">Font:</label><select id="font-family" title="Font for plot labels">
                    <option value="system-ui, sans-serif">System</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="Helvetica, sans-serif">Helvetica</option>
                    <option value="Times New Roman, serif">Times</option>
                    <option value="Georgia, serif">Georgia</option>
                    <option value="Courier New, monospace">Courier</option>
                </select></div>
            </div>
            <div class="row">
                <div class="setting"><label for="font-size">Font:</label><input type="number" id="font-size" value="11" min="6" max="18" step="1" title="Base font size for plots"></div>
                <div class="setting"><label for="label-size">Labels:</label><input type="number" id="label-size" value="11" min="6" max="20" step="1" title="Axis label font size"></div>
                <div class="setting"><label for="cov-lw">Line:</label><input type="number" id="cov-lw" value="1.5" min="0.5" max="5" step="0.5" title="Line thickness for coverage plots"></div>
            </div>
            <div class="row">
                <div class="setting"><label for="err-type">Error:</label><select id="err-type" title="Type of error bars to display"><option value="sd">SD</option><option value="sem">SEM</option><option value="ci95">95% CI</option></select></div>
                <div class="setting"><label for="err-opacity">Opacity:</label><input type="number" id="err-opacity" value="0.25" min="0" max="1" step="0.05" title="Transparency of error shading"></div>
            </div>
            <div class="row">
                <div class="setting"><label for="cov-fwd-col">+:</label><input type="color" id="cov-fwd-col" value="#0066cc" title="Forward strand color"></div>
                <div class="setting"><label for="cov-rev-col">‚àí:</label><input type="color" id="cov-rev-col" value="#cc3300" title="Reverse strand color"></div>
                <div class="setting"><label for="col-A">A:</label><input type="color" id="col-A" value="#e67c35" title="Adenine color"></div>
                <div class="setting"><label for="col-C">C:</label><input type="color" id="col-C" value="#3a9a5b" title="Cytosine color"></div>
                <div class="setting"><label for="col-G">G:</label><input type="color" id="col-G" value="#f0d444" title="Guanine color"></div>
                <div class="setting"><label for="col-T">T:</label><input type="color" id="col-T" value="#3d8fb8" title="Thymine/Uracil color"></div>
            </div>
        </div>
    </div>

    <div class="row" style="margin-bottom:1.25rem;">
        <button class="btn-primary" id="run-btn" disabled aria-describedby="run-help">Start Mapping</button>
        <button class="btn-secondary" id="stop-btn" disabled>Stop</button>
        <button class="btn-secondary" id="reset-btn">Reset All</button>
        <span id="rep-info" style="font-size:0.75rem;color:var(--muted);margin-left:0.75rem;"></span>
    </div>

    <div class="progress" id="progress" role="status" aria-live="polite">
        <div style="display:flex;justify-content:space-between;font-size:0.8rem;"><span id="prog-status">Processing...</span><span id="prog-stats"></span></div>
        <div class="progress-bar"><div class="progress-fill" id="prog-bar"></div></div>
    </div>

    <div class="results" id="results">
        <div class="stats">
            <div class="stat"><div class="stat-label">Total Reads</div><div class="stat-value" id="s-total">0</div></div>
            <div class="stat"><div class="stat-label">Mapped</div><div class="stat-value" id="s-mapped">0</div></div>
            <div class="stat"><div class="stat-label">Mapped %</div><div class="stat-value" id="s-pct">0%</div></div>
            <div class="stat"><div class="stat-label">Avg. Depth</div><div class="stat-value" id="s-cov">0√ó</div></div>
            <div class="stat"><div class="stat-label">Breadth</div><div class="stat-value" id="s-breadth">0%</div></div>
            <div class="stat"><div class="stat-label">Segments</div><div class="stat-value" id="s-segs">0</div></div>
            <div class="stat"><div class="stat-label">Replicates</div><div class="stat-value" id="s-reps">0</div></div>
        </div>
        
        <!-- Per-replicate breakdown (always visible) -->
        <div id="rep-details" style="margin-bottom:1.25rem;font-size:0.85rem;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                <h4 style="font-size:0.85rem;color:var(--text2);font-weight:600;">Per-replicate Mapping Summary</h4>
                <button class="btn-secondary btn-small" id="exp-rep-tsv" title="Download full table as TSV">Download TSV</button>
            </div>
            <div id="rep-breakdown" style="overflow-x:auto;"></div>
            <p class="panel-desc" style="margin-top:0.5rem;">Shows mapped read counts for each input file (replicate) across all reference segments. Rows highlighted in red have no mapped reads.</p>
        </div>

        <!-- Read Length Histogram Panels -->
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;">
            <div class="panel">
                <div class="panel-header"><h3>5‚Ä≤ Bias Length Histogram</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-hist5">‚ü≤</button><button class="btn-secondary btn-small" id="exp-hist5-svg">SVG</button><button class="btn-secondary btn-small" id="exp-hist5-png">PNG</button><button class="btn-secondary btn-small" id="exp-hist5-pdf">PDF</button><button class="btn-secondary btn-small" id="exp-hist5-tsv">TSV</button></div></div>
                <div class="viz-controls">
                    <div class="setting"><label>W:</label><input type="number" id="hist5-w" value="420" step="20" min="250"></div>
                    <div class="setting"><label>H:</label><input type="number" id="hist5-h" value="220" step="20" min="150"></div>
                    <div class="setting"><label>Y-max:</label><input type="number" id="hist5-ymax" value="0"></div>
                    <div class="setting"><label>Y-tick:</label><input type="number" id="hist5-ytick" value="0" min="0" step="100" title="Y-axis tick interval (0=auto)"></div>
                    <div class="setting"><label>X-start:</label><input type="number" id="hist5-xstart" value="18" min="10" max="50" title="First X-axis label"></div>
                    <div class="setting"><label>X-tick:</label><input type="number" id="hist5-xtick" value="2" min="1" max="10" title="X-axis label interval"></div>
                    <div class="setting"><label>Cap:</label><input type="number" id="hist5-cap" value="4" min="1" max="20" step="1"></div>
                    <div class="setting"><label>Bar %:</label><input type="number" id="hist5-barw" value="75" min="20" max="100" step="5" title="Bar width as % of slot"></div>
                    <div class="setting"><label>Data:</label><select id="hist5-data"><option value="counts">Counts</option><option value="cpm">CPM</option><option value="pct">Percentage</option></select></div>
                    <div class="setting"><label>Font:</label><input type="number" id="hist5-font" value="11" min="6" max="18" step="1"></div>
                    <div class="setting"><label>X-off:</label><input type="number" id="hist5-xoff" value="0" min="0" max="30" step="2" title="X-axis label offset"></div>
                    <div class="setting"><label>Y-off:</label><input type="number" id="hist5-yoff" value="0" min="0" max="30" step="2" title="Y-axis label offset"></div>
                </div>
                <div class="viz-controls">
                    <div class="setting"><label><input type="checkbox" id="hist5-err" checked> Error</label></div>
                    <div class="setting"><label><input type="checkbox" id="hist5-pts"> Points</label></div>
                    <div class="setting"><label><input type="checkbox" id="hist5-jitter"> Jitter</label></div>
                    <div class="setting"><label>Pt opacity:</label><input type="number" id="hist5-pt-opacity" value="0.7" min="0.1" max="1" step="0.1"></div>
                    <div class="setting"><label><input type="checkbox" id="hist5-show-legend" checked> Legend</label></div>
                    <div class="setting"><label>Leg font:</label><input type="number" id="hist5-leg-font" value="12" min="6" max="18" step="1"></div>
                    <div class="setting"><label>Leg pos:</label><select id="hist5-leg-pos"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
                    <div class="setting"><label><input type="checkbox" id="hist5-leg-bold"> Bold</label></div>
                </div>
                <canvas id="hist5-canvas" style="display:block;margin:0 auto;"></canvas>
                <div class="panel-info"><span id="hist5-info">Hover for details</span></div>
            </div>
            <div class="panel">
                <div class="panel-header"><h3>3‚Ä≤ Bias Length Histogram</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-hist3">‚ü≤</button><button class="btn-secondary btn-small" id="exp-hist3-svg">SVG</button><button class="btn-secondary btn-small" id="exp-hist3-png">PNG</button><button class="btn-secondary btn-small" id="exp-hist3-pdf">PDF</button><button class="btn-secondary btn-small" id="exp-hist3-tsv">TSV</button></div></div>
                <div class="viz-controls">
                    <div class="setting"><label>W:</label><input type="number" id="hist3-w" value="420" step="20" min="250"></div>
                    <div class="setting"><label>H:</label><input type="number" id="hist3-h" value="220" step="20" min="150"></div>
                    <div class="setting"><label>Y-max:</label><input type="number" id="hist3-ymax" value="0"></div>
                    <div class="setting"><label>Y-tick:</label><input type="number" id="hist3-ytick" value="0" min="0" step="100" title="Y-axis tick interval (0=auto)"></div>
                    <div class="setting"><label>X-start:</label><input type="number" id="hist3-xstart" value="18" min="10" max="50" title="First X-axis label"></div>
                    <div class="setting"><label>X-tick:</label><input type="number" id="hist3-xtick" value="2" min="1" max="10" title="X-axis label interval"></div>
                    <div class="setting"><label>Cap:</label><input type="number" id="hist3-cap" value="4" min="1" max="20" step="1"></div>
                    <div class="setting"><label>Bar %:</label><input type="number" id="hist3-barw" value="75" min="20" max="100" step="5" title="Bar width as % of slot"></div>
                    <div class="setting"><label>Data:</label><select id="hist3-data"><option value="counts">Counts</option><option value="cpm">CPM</option><option value="pct">Percentage</option></select></div>
                    <div class="setting"><label>Font:</label><input type="number" id="hist3-font" value="11" min="6" max="18" step="1"></div>
                    <div class="setting"><label>X-off:</label><input type="number" id="hist3-xoff" value="0" min="0" max="30" step="2" title="X-axis label offset"></div>
                    <div class="setting"><label>Y-off:</label><input type="number" id="hist3-yoff" value="0" min="0" max="30" step="2" title="Y-axis label offset"></div>
                </div>
                <div class="viz-controls">
                    <div class="setting"><label><input type="checkbox" id="hist3-err" checked> Error</label></div>
                    <div class="setting"><label><input type="checkbox" id="hist3-pts"> Points</label></div>
                    <div class="setting"><label><input type="checkbox" id="hist3-jitter"> Jitter</label></div>
                    <div class="setting"><label>Pt opacity:</label><input type="number" id="hist3-pt-opacity" value="0.7" min="0.1" max="1" step="0.1"></div>
                    <div class="setting"><label><input type="checkbox" id="hist3-show-legend" checked> Legend</label></div>
                    <div class="setting"><label>Leg font:</label><input type="number" id="hist3-leg-font" value="12" min="6" max="18" step="1"></div>
                    <div class="setting"><label>Leg pos:</label><select id="hist3-leg-pos"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
                    <div class="setting"><label><input type="checkbox" id="hist3-leg-bold"> Bold</label></div>
                </div>
                <canvas id="hist3-canvas" style="display:block;margin:0 auto;"></canvas>
                <div class="panel-info"><span id="hist3-info">Hover for details</span></div>
            </div>
        </div>
        <p class="panel-desc" style="text-align:center;margin-top:0.5rem;">Distribution of all reads in library by length, colored by 5‚Ä≤ or 3‚Ä≤ terminal nucleotide. Useful for identifying siRNA (21nt, U-bias) vs piRNA (24-30nt, U-bias) populations. Shows total library composition regardless of mapping.</p>

        <!-- Coverage Panel -->
        <div class="panel">
            <div class="panel-header"><h3>Coverage (+ sense up, ‚àí antisense down)</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-cov">‚ü≤</button><button class="btn-secondary btn-small" id="exp-cov-svg">SVG</button><button class="btn-secondary btn-small" id="exp-cov-png">PNG</button><button class="btn-secondary btn-small" id="exp-cov-pdf">PDF</button><button class="btn-secondary btn-small" id="exp-cov-tsv">TSV</button></div></div>
            <div class="viz-controls">
                <div class="setting"><label>W:</label><input type="number" id="cov-w" value="900" step="50" min="400"></div>
                <div class="setting"><label>H:</label><input type="number" id="cov-h" value="240" step="20" min="150"></div>
                <div class="setting"><label>+Y max:</label><input type="number" id="cov-ymax-fwd" value="0"></div>
                <div class="setting"><label>‚àíY max:</label><input type="number" id="cov-ymax-rev" value="0"></div>
                <div class="setting"><label>Segment:</label><select id="cov-seg"></select></div>
                <div class="setting"><label>Data:</label><select id="cov-data"><option value="counts">Counts</option><option value="cpm">CPM</option></select></div>
                <div class="setting"><label>Type:</label><select id="cov-type"><option value="full">Full coverage</option><option value="5end">5‚Ä≤ end only</option><option value="3end">3‚Ä≤ end only</option></select></div>
                <div class="setting"><label>Font:</label><input type="number" id="cov-font" value="11" min="6" max="18" step="1"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Min len:</label><input type="number" id="cov-len-min" value="18" min="15" max="35" step="1"></div>
                <div class="setting"><label>Max len:</label><input type="number" id="cov-len-max" value="30" min="15" max="35" step="1"></div>
                <div class="setting"><label>X-off:</label><input type="number" id="cov-xoff" value="0" min="0" max="30" step="2" title="X-axis label offset"></div>
                <div class="setting"><label>Y-off:</label><input type="number" id="cov-yoff" value="0" min="0" max="30" step="2" title="Y-axis label offset"></div>
                <div class="setting"><label>X-tick:</label><input type="number" id="cov-xtick" value="0" min="0" step="50" style="width:60px;" title="X-axis tick interval (0=auto)"></div>
                <div class="setting"><label>X-start:</label><input type="number" id="cov-xstart" value="0" min="0" step="1" style="width:60px;" title="X-axis starting value for ticks"></div>
                <div class="setting"><label>Y-tick:</label><input type="number" id="cov-ytick" value="0" min="0" step="10" style="width:60px;" title="Y-axis tick interval (0=auto)"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label><input type="checkbox" id="cov-xbold"> X-axis bold</label></div>
                <div class="setting"><label><input type="checkbox" id="cov-ybold"> Y-axis bold</label></div>
                <div class="setting"><label><input type="checkbox" id="cov-err" checked> Error</label></div>
                <div class="setting"><label><input type="checkbox" id="cov-show-seq" checked> Show sequence</label></div>
                <div class="setting"><label><input type="checkbox" id="cov-lock-y"> Lock Y-axis</label></div>
            </div>
            <canvas id="cov-canvas" style="display:block;margin:0 auto;"></canvas>
            <div class="viz-controls" style="justify-content:center;margin-top:8px;">
                <div class="setting"><label>Start:</label><input type="number" id="cov-range-start" value="0" min="0" step="1" style="width:70px;"></div>
                <div class="setting"><label>End:</label><input type="number" id="cov-range-end" value="0" min="0" step="1" style="width:70px;"></div>
                <button class="btn-secondary btn-small" id="cov-pan-left" title="Pan left">‚óÄ</button>
                <button class="btn-secondary btn-small" id="cov-zoom-out" title="Zoom out 2x">‚àí</button>
                <button class="btn-secondary btn-small" id="cov-zoom-in" title="Zoom in 2x">+</button>
                <button class="btn-secondary btn-small" id="cov-pan-right" title="Pan right">‚ñ∂</button>
                <button class="btn-secondary btn-small" id="cov-reset-zoom" title="Reset zoom to full range">Reset</button>
                <div class="setting" style="margin-left:10px;"><label><input type="checkbox" id="cov-pan-mode"> Drag to pan</label></div>
            </div>
            <div class="panel-info"><span id="cov-info">Hover for position details</span></div>
            <p class="panel-desc">Genome-wide read coverage profile. Sense (+) reads shown above the axis, antisense (‚àí) below. Hotspots indicate highly targeted regions.</p>
        </div>

        <!-- Length Distribution Panel -->
        <div class="panel">
            <div class="panel-header"><h3>Mapped Length Distribution</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-len">‚ü≤</button><button class="btn-secondary btn-small" id="exp-len-svg">SVG</button><button class="btn-secondary btn-small" id="exp-len-png">PNG</button><button class="btn-secondary btn-small" id="exp-len-pdf">PDF</button><button class="btn-secondary btn-small" id="exp-len-tsv">TSV</button></div></div>
            <div class="viz-controls">
                <div class="setting"><label>W:</label><input type="number" id="len-w" value="500" step="50" min="300"></div>
                <div class="setting"><label>H:</label><input type="number" id="len-h" value="350" step="20" min="200"></div>
                <div class="setting"><label>+Y max:</label><input type="number" id="len-ymax-fwd" value="0" title="Forward strand Y-axis max (0=auto)"></div>
                <div class="setting"><label>‚àíY max:</label><input type="number" id="len-ymax-rev" value="0" title="Reverse strand Y-axis max (0=auto)"></div>
                <div class="setting"><label>Segment:</label><select id="len-seg"></select></div>
                <div class="setting"><label>Top (fwd):</label><select id="len-top-end"><option value="5">5‚Ä≤</option><option value="3">3‚Ä≤</option></select></div>
                <div class="setting"><label>Bottom (rev):</label><select id="len-bot-end"><option value="5">5‚Ä≤</option><option value="3">3‚Ä≤</option></select></div>
                <div class="setting"><label>Bar %:</label><input type="number" id="len-barw" value="75" min="20" max="100" step="5" title="Bar width as % of slot"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Data:</label><select id="len-data"><option value="counts">Counts</option><option value="cpm">CPM</option><option value="pct">Percentage</option></select></div>
                <div class="setting"><label>X-tick:</label><select id="len-xtick"><option value="1">Every 1</option><option value="2">Every 2</option><option value="5">Every 5</option></select></div>
                <div class="setting"><label>Y-tick:</label><input type="number" id="len-ytick" value="0" min="0" step="100" title="Y-axis tick interval (0=auto)"></div>
                <div class="setting"><label>Font:</label><input type="number" id="len-font" value="11" min="6" max="18" step="1"></div>
                <div class="setting"><label>X-off:</label><input type="number" id="len-xoff" value="0" min="0" max="30" step="2" title="X-axis label offset"></div>
                <div class="setting"><label>Y-off:</label><input type="number" id="len-yoff" value="0" min="0" max="30" step="2" title="Y-axis label offset"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label><input type="checkbox" id="len-err" checked> Error</label></div>
                <div class="setting"><label><input type="checkbox" id="len-pts"> Points</label></div>
                <div class="setting"><label><input type="checkbox" id="len-jitter"> Jitter</label></div>
                <div class="setting"><label>Pt opacity:</label><input type="number" id="len-pt-opacity" value="0.7" min="0.1" max="1" step="0.1"></div>
                <div class="setting"><label><input type="checkbox" id="len-show-legend" checked> Legend</label></div>
                <div class="setting"><label>Leg font:</label><input type="number" id="len-leg-font" value="12" min="6" max="18" step="1"></div>
                <div class="setting"><label>Leg pos:</label><select id="len-leg-pos"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
                <div class="setting"><label><input type="checkbox" id="len-leg-bold"> Bold</label></div>
            </div>
            <canvas id="len-canvas" style="display:block;margin:0 auto;"></canvas>
            <div class="panel-info"><span id="len-info">Hover for count details</span></div>
            <p class="panel-desc">Strand-separated length distribution with nucleotide bias. Forward reads (top) and reverse reads (bottom) shown separately to reveal strand-specific patterns.</p>
        </div>

        <!-- Nucleotide Bias Panel -->
        <div class="panel">
            <div class="panel-header"><h3>Mapped Nucleotide Bias</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-bias">‚ü≤</button><button class="btn-secondary btn-small" id="exp-bias-svg">SVG</button><button class="btn-secondary btn-small" id="exp-bias-png">PNG</button><button class="btn-secondary btn-small" id="exp-bias-pdf">PDF</button></div></div>
            <div class="viz-controls">
                <div class="setting"><label>W:</label><input type="number" id="bias-w" value="700" step="50" min="300"></div>
                <div class="setting"><label>H:</label><input type="number" id="bias-h" value="180" step="20" min="100"></div>
                <div class="setting"><label>Segment:</label><select id="bias-seg"></select></div>
                <div class="setting"><label>End:</label><select id="bias-end"><option value="5">5‚Ä≤</option><option value="3">3‚Ä≤</option></select></div>
                <div class="setting"><label>Strand:</label><select id="bias-strand"><option value="both">Both</option><option value="fwd">Forward (+)</option><option value="rev">Reverse (‚àí)</option></select></div>
                <div class="setting"><label>Length:</label><input type="number" id="bias-len-min" value="18" min="10" max="50" step="1" title="Minimum read length">‚Äì<input type="number" id="bias-len-max" value="30" min="10" max="50" step="1" title="Maximum read length"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Display:</label><select id="bias-type"><option value="prop">Proportion</option><option value="bits">Bits (logo)</option></select></div>
                <div class="setting"><label>Max bits:</label><input type="number" id="bias-maxbits" value="2" min="0.5" max="4" step="0.5"></div>
                <div class="setting"><label>X-tick:</label><select id="bias-xtick"><option value="1">Every 1</option><option value="2">Every 2</option><option value="5">Every 5</option></select></div>
                <div class="setting"><label>Font:</label><input type="number" id="bias-font" value="11" min="6" max="18" step="1"></div>
                <div class="setting"><label><input type="checkbox" id="bias-err"> Error</label></div>
                <div class="setting"><label><input type="checkbox" id="bias-show-legend" checked> Legend</label></div>
                <div class="setting"><label>Leg font:</label><input type="number" id="bias-leg-font" value="12" min="6" max="18" step="1"></div>
                <div class="setting"><label>Leg pos:</label><select id="bias-leg-pos"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
                <div class="setting"><label><input type="checkbox" id="bias-leg-bold"> Bold</label></div>
                <div class="setting"><label>Leg X-off:</label><input type="number" id="bias-leg-xoff" value="15" min="0" max="100" step="5" title="Legend X offset from chart"></div>
                <div class="setting"><label>Leg Y-off:</label><input type="number" id="bias-leg-yoff" value="0" min="-20" max="50" step="2" title="Legend Y offset (negative moves up)"></div>
            </div>
            <canvas id="bias-canvas" style="display:block;margin:0 auto;"></canvas>
            <p class="panel-desc">Positional nucleotide composition from 5‚Ä≤ or 3‚Ä≤ end of mapped reads. Strong 1U bias at position 1 indicates Argonaute loading. Position 10A bias suggests ping-pong amplification. Use length filter to focus on specific size classes (e.g., 21-21 for siRNA, 24-30 for piRNA).</p>
        </div>

        <!-- Overlap Signature Panel - 4 subplots like Mississippi -->
        <div class="panel">
            <div class="panel-header"><h3>Overlap Signatures (4-Panel Summary)</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-ovl">‚ü≤</button><button class="btn-secondary btn-small" id="exp-ovl-svg">SVG</button><button class="btn-secondary btn-small" id="exp-ovl-png">PNG</button><button class="btn-secondary btn-small" id="exp-ovl-pdf">PDF</button><button class="btn-secondary btn-small" id="exp-ovl-tsv">TSV</button></div></div>
            <p class="panel-citation" style="margin:0.25rem 0 0.5rem;font-size:0.8rem;color:#666;font-style:italic;">Uses logic from Antoniewski (2014) Methods Mol Biol, DOI: <a href="https://doi.org/10.1007/978-1-4939-0931-5_12" target="_blank" style="color:#666;">10.1007/978-1-4939-0931-5_12</a></p>
            <div class="viz-controls">
                <div class="setting"><label>W:</label><input type="number" id="ovl-w" value="800" step="25" min="500"></div>
                <div class="setting"><label>H:</label><input type="number" id="ovl-h" value="500" step="25" min="300"></div>
                <div class="setting"><label>Segment:</label><select id="ovl-seg"></select></div>
                <div class="setting"><label>Font:</label><input type="number" id="ovl-font" value="14" min="6" max="20" step="1"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Query (+) min:</label><input type="number" id="ovl-qmin" value="18" min="10" max="50" step="1" title="Minimum size of forward strand query reads"></div>
                <div class="setting"><label>Query (+) max:</label><input type="number" id="ovl-qmax" value="30" min="10" max="50" step="1" title="Maximum size of forward strand query reads"></div>
                <div class="setting"><label>Target (‚àí) min:</label><input type="number" id="ovl-tmin" value="18" min="10" max="50" step="1" title="Minimum size of reverse strand target reads"></div>
                <div class="setting"><label>Target (‚àí) max:</label><input type="number" id="ovl-tmax" value="30" min="10" max="50" step="1" title="Maximum size of reverse strand target reads"></div>
                <div class="setting"><label>Overlap min:</label><input type="number" id="ovl-omin" value="-10" min="-30" max="30" step="1" title="Minimum overlap distance (negative = gap between 5' ends)"></div>
                <div class="setting"><label>Overlap max:</label><input type="number" id="ovl-omax" value="30" min="-30" max="50" step="1" title="Maximum overlap distance to analyze"></div>
                <button class="btn-secondary btn-small" id="recalc-ovl" title="Recalculate overlap signatures with current settings">Recalculate</button>
            </div>
            <div class="viz-controls">
                <div class="setting"><label><input type="checkbox" id="ovl-err" checked> Error bars</label></div>
                <div class="setting"><label><input type="checkbox" id="ovl-pts"> Points</label></div>
                <div class="setting"><label><input type="checkbox" id="ovl-normalize-rpm"> Normalize to RPM</label></div>
                <div class="setting"><label>Counts Y:</label><input type="number" id="ovl-ymax-counts" value="0" min="0" step="1000" title="Y-max for Number of pairs (0=auto)"></div>
                <div class="setting"><label>Prob Y:</label><input type="number" id="ovl-ymax-probs" value="0" min="0" step="0.01" title="Y-max for Probabilities (0=auto)"></div>
                <div class="setting"><label>z Y:</label><input type="number" id="ovl-ymax-z" value="0" min="0" step="1" title="Y-max for z-scores (0=auto, symmetric ¬±)"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Counts Y tick:</label><input type="number" id="ovl-ytick-counts" value="0" min="0" step="10" title="Y-axis tick increment for Counts panel (0=auto)"></div>
                <div class="setting"><label>Prob Y tick:</label><input type="number" id="ovl-ytick-probs" value="0" min="0" step="0.01" title="Y-axis tick increment for Probabilities panel (0=auto)"></div>
                <div class="setting"><label>z Y tick:</label><input type="number" id="ovl-ytick-z" value="0" min="0" step="0.5" title="Y-axis tick increment for z-scores panel (0=auto)"></div>
                <div class="setting"><label>X tick:</label><input type="number" id="ovl-xtick" value="0" min="0" step="2" title="X-axis tick increment (0=auto)"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Panel width:</label><input type="number" id="ovl-panel-w" value="0" min="0" step="10" title="Width of each panel in pixels (0=auto)"></div>
                <div class="setting"><label>Panel height:</label><input type="number" id="ovl-panel-h" value="0" min="0" step="10" title="Height of each panel in pixels (0=auto)"></div>
                <div class="setting"><label>Title size:</label><input type="number" id="ovl-title-size" value="14" min="8" max="24" title="Title font size"></div>
                <div class="setting"><label><input type="checkbox" id="ovl-title-bold" checked> Bold titles</label></div>
                <div class="setting"><label><input type="checkbox" id="ovl-show-subtitles" checked> Panel subtitles</label></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>X offset:</label><input type="number" id="ovl-xoff" value="0" step="5" title="X-axis label offset"></div>
                <div class="setting"><label>Y offset:</label><input type="number" id="ovl-yoff" value="0" step="5" title="Y-axis label offset"></div>
                <div class="setting"><label><input type="checkbox" id="ovl-show-border"> Panel borders</label></div>
                <div class="setting"><label><input type="checkbox" id="ovl-show-10line"> Show 10nt line</label></div>
            </div>
            <canvas id="ovl-canvas" style="display:block;margin:0 auto;"></canvas>
            <div class="panel-info"><span id="ovl-info">Hover for overlap details</span></div>
            <p class="panel-desc">5‚Ä≤-to-5‚Ä≤ overlap analysis between sense (+) and antisense (‚àí) reads. <strong>10nt peak</strong> indicates ping-pong amplification. Negative overlaps show gaps/phasing.</p>
            <p class="panel-ref" style="margin-top:0.5rem;font-size:0.7rem;color:#888;line-height:1.4;">Antoniewski C. Computing siRNA and piRNA overlap signatures. <em>Methods Mol Biol.</em> 2014;1173:135-46. doi: 10.1007/978-1-4939-0931-5_12. PMID: 24920366</p>
        </div>
        
        <!-- Overlap Heatmap Panel - Independent controls -->
        <div class="panel">
            <div class="panel-header"><h3>Overlap Heatmap (by Query Length)</h3><div class="panel-controls"><button class="btn-secondary btn-small" id="rev-ovl-hm">‚ü≤</button><button class="btn-secondary btn-small" id="exp-ovl-hm-svg">SVG</button><button class="btn-secondary btn-small" id="exp-ovl-hm-png">PNG</button><button class="btn-secondary btn-small" id="exp-ovl-hm-pdf">PDF</button></div></div>
            <p class="panel-citation" style="margin:0.25rem 0 0.5rem;font-size:0.8rem;color:#666;font-style:italic;">Uses logic from Antoniewski (2014) Methods Mol Biol, DOI: <a href="https://doi.org/10.1007/978-1-4939-0931-5_12" target="_blank" style="color:#666;">10.1007/978-1-4939-0931-5_12</a></p>
            <div class="viz-controls">
                <div class="setting"><label>W:</label><input type="number" id="ovl-hm-w" value="400" step="25" min="300"></div>
                <div class="setting"><label>H:</label><input type="number" id="ovl-hm-h" value="700" step="25" min="400"></div>
                <div class="setting"><label>Font:</label><input type="number" id="ovl-hm-font" value="14" min="6" max="20" step="1"></div>
                <div class="setting"><label>Segment:</label><select id="ovl-hm-seg"></select></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Data:</label><select id="ovl-hm-data"><option value="pz">Probability z-score (h-sig)</option><option value="cz">Count z-score</option><option value="p">Probability</option><option value="c">Counts</option></select></div>
                <div class="setting"><label>Colors:</label><select id="ovl-hm-colors"><option value="blue-red">Blue‚ÜíPink</option><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="cool-warm">Cool‚ÜíWarm</option></select></div>
                <div class="setting"><label>X-tick:</label><input type="number" id="ovl-hm-xtick" value="1" min="1" max="10" step="1" title="Show every Nth tick on axes"></div>
                <div class="setting"><label>Z min:</label><input type="number" id="ovl-hm-zmin" value="" placeholder="auto" step="0.5" title="Minimum z-score for heatmap color scale"></div>
                <div class="setting"><label>Z max:</label><input type="number" id="ovl-hm-zmax" value="" placeholder="auto" step="0.5" title="Maximum z-score for heatmap color scale"></div>
            </div>
            <div class="viz-controls">
                <div class="setting"><label>Query (+) min:</label><input type="number" id="ovl-hm-qmin" value="18" min="10" max="50" step="1"></div>
                <div class="setting"><label>Query (+) max:</label><input type="number" id="ovl-hm-qmax" value="30" min="10" max="50" step="1"></div>
                <div class="setting"><label>Overlap min:</label><input type="number" id="ovl-hm-omin" value="-10" min="-30" max="30" step="1"></div>
                <div class="setting"><label>Overlap max:</label><input type="number" id="ovl-hm-omax" value="30" min="-30" max="50" step="1"></div>
            </div>
            <canvas id="ovl-hm-canvas" style="display:block;margin:0 auto;"></canvas>
            <div class="panel-info"><span id="ovl-hm-info">Hover for heatmap details</span></div>
            <p class="panel-desc">Heatmap showing overlap signatures by query read length. <strong>Probability z-score (h-sig)</strong> is recommended as it normalizes per-position, making it robust to depth variations. Count z-score may be biased by high-coverage regions. Each row represents a different query length, with 'all' aggregating across lengths.</p>
            <p class="panel-ref" style="margin-top:0.5rem;font-size:0.7rem;color:#888;line-height:1.4;">Antoniewski C. Computing siRNA and piRNA overlap signatures. <em>Methods Mol Biol.</em> 2014;1173:135-46. doi: 10.1007/978-1-4939-0931-5_12. PMID: 24920366</p>
        </div>

        <div class="row"><button class="btn-secondary" id="exp-all">Export Full Statistics (JSON)</button></div>
        
        <!-- Standalone HTML Export -->
        <div class="panel" style="margin-top:1rem;background:var(--bg3);">
            <div class="panel-header"><h3>Export Standalone Report</h3></div>
            <p class="panel-desc" style="margin-top:0;margin-bottom:0.75rem;">Generate a self-contained HTML file with all figures and analysis metadata. Ideal for supplementary materials in manuscripts - reviewers can open it in any browser without additional software.</p>
            <div class="row" style="align-items:flex-end;">
                <div class="setting" style="flex:1;">
                    <label for="export-filename" style="display:block;margin-bottom:0.25rem;">Filename:</label>
                    <input type="text" id="export-filename" value="srnamap_report" style="width:100%;max-width:300px;padding:0.4rem 0.6rem;font-size:0.85rem;" placeholder="srnamap_report">
                </div>
                <button class="btn-primary" id="exp-standalone" style="margin-left:0.75rem;">Export Standalone HTML</button>
            </div>
        </div>
    </div>

    <footer>sRNAMap v0.2.8 ‚Äî Rhys H Parry (<a href="/cdn-cgi/l/email-protection#097b2779687b7b70497c78276c6d7c27687c"><span class="__cf_email__" data-cfemail="9ae8b4eafbe8e8e3daefebb4fffeefb4fbef">[email&#160;protected]</span></a>) ‚Äî School of Chemistry and Molecular Biosciences, The University of Queensland</footer>
</div>

<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
'use strict';

// =============================================================================
// INDEXEDDB CACHE FOR PERSISTENT STORAGE
// =============================================================================
// Stores processed results to avoid re-processing on page refresh

class ResultsCache {
    constructor() {
        this.dbName = 'sRNAMapCache';
        this.dbVersion = 1;
        this.db = null;
    }
    
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Store for cached analysis results
                if (!db.objectStoreNames.contains('results')) {
                    const store = db.createObjectStore('results', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('name', 'name', { unique: false });
                }
                
                // Store for large coverage arrays (chunked)
                if (!db.objectStoreNames.contains('coverage')) {
                    const covStore = db.createObjectStore('coverage', { keyPath: ['resultId', 'segment', 'type', 'chunk'] });
                    covStore.createIndex('resultId', 'resultId', { unique: false });
                }
            };
        });
    }
    
    // Generate a hash from file metadata and settings
    async generateCacheKey(files, refs, settings) {
        const fileInfo = files.map(f => f.name + '_' + f.size + '_' + f.lastModified).join('|');
        const refInfo = Object.keys(refs).sort().join('|');
        const settingsStr = JSON.stringify(settings);
        const combined = fileInfo + '::' + refInfo + '::' + settingsStr;
        
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            const char = combined.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return 'cache_' + Math.abs(hash).toString(36);
    }
    
    // Save results to IndexedDB
    async saveResults(cacheKey, name, data) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['results', 'coverage'], 'readwrite');
        const resultsStore = transaction.objectStore('results');
        const coverageStore = transaction.objectStore('coverage');
        
        // Prepare main result object (without large arrays)
        const result = {
            id: cacheKey,
            name: name,
            timestamp: Date.now(),
            refs: data.refs,
            refOrder: data.refOrder,
            settings: data.settings,
            stats: data.stats,
            replicates: data.replicates.map(rep => ({
                name: rep.name,
                stats: rep.stats,
                lenDist5: rep.lenDist5,
                lenDist3: rep.lenDist3,
                lenDistBySeg: rep.lenDistBySeg,
                bias: rep.bias,
                biasBySeg: rep.biasBySeg
                // Coverage arrays stored separately
            })),
            // Save pre-calculated overlap data
            ovlData: data.ovlData,
            ovlSettings: data.ovlSettings
        };
        
        // Save main result
        await new Promise((resolve, reject) => {
            const req = resultsStore.put(result);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });
        
        // Save coverage arrays in chunks (TypedArrays need special handling)
        const CHUNK_SIZE = 100000; // Elements per chunk
        
        for (const seg of data.refOrder) {
            // Save each coverage type
            for (const [type, arrays] of [
                ['covFwd', data.covFwd],
                ['covRev', data.covRev],
                ['cov5Fwd', data.cov5Fwd],
                ['cov5Rev', data.cov5Rev]
            ]) {
                if (!arrays[seg]) continue;
                const arr = arrays[seg];
                const numChunks = Math.ceil(arr.length / CHUNK_SIZE);
                
                for (let c = 0; c < numChunks; c++) {
                    const start = c * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, arr.length);
                    const chunkData = Array.from(arr.slice(start, end));
                    
                    await new Promise((resolve, reject) => {
                        const req = coverageStore.put({
                            resultId: cacheKey,
                            segment: seg,
                            type: type,
                            chunk: c,
                            data: chunkData,
                            totalLength: arr.length
                        });
                        req.onsuccess = resolve;
                        req.onerror = () => reject(req.error);
                    });
                }
            }
            
            // Save per-replicate coverage
            for (let ri = 0; ri < data.replicates.length; ri++) {
                const rep = data.replicates[ri];
                for (const [type, arrays] of [
                    ['repCovFwd', rep.covFwd],
                    ['repCovRev', rep.covRev],
                    ['repCov5Fwd', rep.cov5Fwd],
                    ['repCov5Rev', rep.cov5Rev]
                ]) {
                    if (!arrays || !arrays[seg]) continue;
                    const arr = arrays[seg];
                    const numChunks = Math.ceil(arr.length / CHUNK_SIZE);
                    
                    for (let c = 0; c < numChunks; c++) {
                        const start = c * CHUNK_SIZE;
                        const end = Math.min(start + CHUNK_SIZE, arr.length);
                        const chunkData = Array.from(arr.slice(start, end));
                        
                        await new Promise((resolve, reject) => {
                            const req = coverageStore.put({
                                resultId: cacheKey,
                                segment: seg,
                                type: type + '_' + ri,
                                chunk: c,
                                data: chunkData,
                                totalLength: arr.length
                            });
                            req.onsuccess = resolve;
                            req.onerror = () => reject(req.error);
                        });
                    }
                }
            }
        }
        
        return cacheKey;
    }
    
    // Load results from IndexedDB
    async loadResults(cacheKey) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['results', 'coverage'], 'readonly');
        const resultsStore = transaction.objectStore('results');
        const coverageStore = transaction.objectStore('coverage');
        
        // Load main result
        const result = await new Promise((resolve, reject) => {
            const req = resultsStore.get(cacheKey);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
        
        if (!result) return null;
        
        // Load coverage arrays
        const coverageData = await new Promise((resolve, reject) => {
            const index = coverageStore.index('resultId');
            const req = index.getAll(cacheKey);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
        
        // Reconstruct coverage arrays
        const covFwd = {}, covRev = {}, cov5Fwd = {}, cov5Rev = {};
        const repCoverage = result.replicates.map(() => ({
            covFwd: {}, covRev: {}, cov5Fwd: {}, cov5Rev: {}
        }));
        
        // Group chunks by segment and type
        const chunks = {};
        for (const chunk of coverageData) {
            const key = chunk.segment + '::' + chunk.type;
            if (!chunks[key]) chunks[key] = { totalLength: chunk.totalLength, parts: [] };
            chunks[key].parts[chunk.chunk] = chunk.data;
        }
        
        // Reconstruct arrays
        for (const [key, chunkData] of Object.entries(chunks)) {
            const [segment, type] = key.split('::');
            const fullArray = new Uint32Array(chunkData.totalLength);
            let offset = 0;
            for (const part of chunkData.parts) {
                if (part) {
                    fullArray.set(part, offset);
                    offset += part.length;
                }
            }
            
            // Assign to appropriate object
            if (type === 'covFwd') covFwd[segment] = fullArray;
            else if (type === 'covRev') covRev[segment] = fullArray;
            else if (type === 'cov5Fwd') cov5Fwd[segment] = fullArray;
            else if (type === 'cov5Rev') cov5Rev[segment] = fullArray;
            else if (type.startsWith('repCovFwd_')) {
                const ri = parseInt(type.split('_')[1]);
                repCoverage[ri].covFwd[segment] = fullArray;
            }
            else if (type.startsWith('repCovRev_')) {
                const ri = parseInt(type.split('_')[1]);
                repCoverage[ri].covRev[segment] = fullArray;
            }
            else if (type.startsWith('repCov5Fwd_')) {
                const ri = parseInt(type.split('_')[1]);
                repCoverage[ri].cov5Fwd[segment] = fullArray;
            }
            else if (type.startsWith('repCov5Rev_')) {
                const ri = parseInt(type.split('_')[1]);
                repCoverage[ri].cov5Rev[segment] = fullArray;
            }
        }
        
        // Reconstruct replicates with coverage
        const replicates = result.replicates.map((rep, i) => ({
            ...rep,
            covFwd: repCoverage[i].covFwd,
            covRev: repCoverage[i].covRev,
            cov5Fwd: repCoverage[i].cov5Fwd,
            cov5Rev: repCoverage[i].cov5Rev
        }));
        
        return {
            ...result,
            covFwd,
            covRev,
            cov5Fwd,
            cov5Rev,
            replicates,
            ovlData: result.ovlData,
            ovlSettings: result.ovlSettings
        };
    }
    
    // Check if results exist in cache
    async hasResults(cacheKey) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['results'], 'readonly');
            const store = transaction.objectStore('results');
            const req = store.get(cacheKey);
            req.onsuccess = () => resolve(!!req.result);
            req.onerror = () => reject(req.error);
        });
    }
    
    // List all cached results
    async listResults() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['results'], 'readonly');
            const store = transaction.objectStore('results');
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result.map(r => ({
                id: r.id,
                name: r.name,
                timestamp: r.timestamp,
                stats: r.stats,
                refOrder: r.refOrder
            })));
            req.onerror = () => reject(req.error);
        });
    }
    
    // Delete cached result
    async deleteResult(cacheKey) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['results', 'coverage'], 'readwrite');
        const resultsStore = transaction.objectStore('results');
        const coverageStore = transaction.objectStore('coverage');
        
        // Delete main result
        await new Promise((resolve, reject) => {
            const req = resultsStore.delete(cacheKey);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });
        
        // Delete coverage chunks
        const coverageIndex = coverageStore.index('resultId');
        const coverageKeys = await new Promise((resolve, reject) => {
            const req = coverageIndex.getAllKeys(cacheKey);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
        
        for (const key of coverageKeys) {
            await new Promise((resolve, reject) => {
                const req = coverageStore.delete(key);
                req.onsuccess = resolve;
                req.onerror = () => reject(req.error);
            });
        }
    }
    
    // Clear all cached results
    async clearAll() {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['results', 'coverage'], 'readwrite');
        await Promise.all([
            new Promise((resolve, reject) => {
                const req = transaction.objectStore('results').clear();
                req.onsuccess = resolve;
                req.onerror = () => reject(req.error);
            }),
            new Promise((resolve, reject) => {
                const req = transaction.objectStore('coverage').clear();
                req.onsuccess = resolve;
                req.onerror = () => reject(req.error);
            })
        ]);
    }
    
    // Get approximate cache size
    async getCacheSize() {
        if (!this.db) await this.init();
        
        let totalSize = 0;
        const transaction = this.db.transaction(['coverage'], 'readonly');
        const store = transaction.objectStore('coverage');
        
        return new Promise((resolve, reject) => {
            const req = store.openCursor();
            req.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    totalSize += cursor.value.data.length * 4; // Uint32 = 4 bytes
                    cursor.continue();
                } else {
                    resolve(totalSize);
                }
            };
            req.onerror = () => reject(req.error);
        });
    }
}

// Global cache instance
const resultsCache = new ResultsCache();

// Color palettes for nucleotides
const COLOR_PALETTES = {
    default: { A: '#e67c35', C: '#3a9a5b', G: '#f0d444', T: '#3d8fb8' },
    pastel: { A: '#ffb3ba', C: '#baffc9', G: '#ffffba', T: '#bae1ff' },
    viridis: { A: '#440154', C: '#31688e', G: '#35b779', T: '#fde725' },
    colorblind: { A: '#E69F00', C: '#56B4E9', G: '#009E73', T: '#CC79A7' }
};

function getNtColors() {
    const palette = document.getElementById('color-palette')?.value || 'default';
    const custom = {
        A: document.getElementById('col-A')?.value,
        C: document.getElementById('col-C')?.value,
        G: document.getElementById('col-G')?.value,
        T: document.getElementById('col-T')?.value
    };
    // Use palette colors as base, custom colors override if changed from defaults
    const base = COLOR_PALETTES[palette] || COLOR_PALETTES.default;
    return {
        A: custom.A && custom.A !== COLOR_PALETTES.default.A ? custom.A : base.A,
        C: custom.C && custom.C !== COLOR_PALETTES.default.C ? custom.C : base.C,
        G: custom.G && custom.G !== COLOR_PALETTES.default.G ? custom.G : base.G,
        T: custom.T && custom.T !== COLOR_PALETTES.default.T ? custom.T : base.T
    };
}

function getFont() {
    return document.getElementById('font-family')?.value || 'system-ui, sans-serif';
}

function getFontSize() {
    return +(document.getElementById('font-size')?.value || 10);
}

function getLabelSize() {
    return +(document.getElementById('label-size')?.value || 11);
}

// =============================================================================
// WEB WORKER CODE FOR PARALLEL READ MAPPING
// =============================================================================
// This code will be stringified and run in Web Workers for multi-threaded processing

const WORKER_CODE = [
'"use strict";',
'',
'// Worker state',
'let refs = {};',
'let refOrder = [];',
'let kmerIdx = new Map();',
'let kmerCounts = new Map();',
'let settings = {};',
'',
'// Reverse complement',
'function rc(s) {',
'    const comp = { A: "T", T: "A", G: "C", C: "G", N: "N" };',
'    let r = "";',
'    for (let i = s.length - 1; i >= 0; i--) r += comp[s[i]] || "N";',
'    return r;',
'}',
'',
'// Score alignment',
'function scoreAlignment(query, ref, mmPenalty, nAsMatch) {',
'    let mm = 0, score = 0, has3PrimeMM = false;',
'    const lastPos = query.length - 1;',
'    for (let i = 0; i < query.length; i++) {',
'        const qBase = query[i].toUpperCase();',
'        const rBase = ref[i].toUpperCase();',
'        let isMismatch = false;',
'        if (nAsMatch && (qBase === "N" || rBase === "N")) {',
'            isMismatch = false;',
'        } else {',
'            isMismatch = qBase !== rBase;',
'        }',
'        if (isMismatch) {',
'            mm++;',
'            score -= mmPenalty;',
'            if (i === lastPos) has3PrimeMM = true;',
'        } else {',
'            score += 1;',
'        }',
'    }',
'    return { mm: mm, score: score, has3PrimeMM: has3PrimeMM };',
'}',
'',
'// Collect candidates',
'function collectCandidates(testSeq, k, step) {',
'    const votes = new Map();',
'    for (let i = 0; i <= testSeq.length - k; i += step) {',
'        const kmer = testSeq.substring(i, i + k);',
'        if (kmer.includes("N")) continue;',
'        const hits = kmerIdx.get(kmer);',
'        if (hits) {',
'            const weight = 1 / (kmerCounts.get(kmer) || 1);',
'            for (let j = 0; j < hits.length; j++) {',
'                const hit = hits[j];',
'                const sp = hit.pos - i;',
'                if (sp >= 0 && sp + testSeq.length <= refs[hit.seg].length) {',
'                    const key = hit.seg + ":" + sp;',
'                    votes.set(key, (votes.get(key) || 0) + weight);',
'                }',
'            }',
'        }',
'    }',
'    return votes;',
'}',
'',
'// Map a single read',
'function mapRead(seq) {',
'    const k = settings.kmer;',
'    const seeds = settings.seeds;',
'    const maxMM = settings.mm;',
'    const mmPenalty = settings.mmPenalty;',
'    const adaptiveSeed = settings.adaptiveSeed;',
'    const multiMap = settings.multiMap;',
'    const maxLoci = settings.maxLoci;',
'    const no3PrimeMM = settings.no3PrimeMM || false;',
'    const nAsMatch = settings.nAsMatch || false;',
'    ',
'    if (seq.length < k) return null;',
'',
'    var allCandidates = [];',
'    var testPairs = [{ testSeq: seq, strand: "fwd" }, { testSeq: rc(seq), strand: "rev" }];',
'',
'    for (var ti = 0; ti < testPairs.length; ti++) {',
'        var testSeq = testPairs[ti].testSeq;',
'        var strand = testPairs[ti].strand;',
'        var votes = collectCandidates(testSeq, k, Math.max(1, Math.floor(k / 2)));',
'        if (adaptiveSeed && votes.size === 0) {',
'            votes = collectCandidates(testSeq, Math.max(8, k - 2), 1);',
'        }',
'        votes.forEach(function(v, key) {',
'            if (v >= seeds) {',
'                allCandidates.push({ key: key, votes: v, strand: strand, testSeq: testSeq });',
'            }',
'        });',
'    }',
'',
'    if (allCandidates.length === 0) return null;',
'    allCandidates.sort(function(a, b) { return b.votes - a.votes; });',
'',
'    var topN = Math.min(10, allCandidates.length);',
'    var scored = [];',
'    ',
'    for (var i = 0; i < topN; i++) {',
'        var c = allCandidates[i];',
'        var colonIdx = c.key.indexOf(":");',
'        var seg = c.key.substring(0, colonIdx);',
'        var pos = parseInt(c.key.substring(colonIdx + 1), 10);',
'        var refSeg = refs[seg].substring(pos, pos + c.testSeq.length);',
'        var alignment = scoreAlignment(c.testSeq, refSeg, mmPenalty, nAsMatch);',
'        ',
'        if (alignment.mm > maxMM) continue;',
'        if (no3PrimeMM && alignment.has3PrimeMM) continue;',
'        ',
'        scored.push({ ',
'            seg: seg, pos: pos, len: seq.length, strand: c.strand, seq: c.testSeq,',
'            mm: alignment.mm, score: alignment.score, votes: c.votes',
'        });',
'    }',
'',
'    if (scored.length === 0) return null;',
'',
'    scored.sort(function(a, b) {',
'        if (a.mm !== b.mm) return a.mm - b.mm;',
'        if (a.score !== b.score) return b.score - a.score;',
'        return b.votes - a.votes;',
'    });',
'',
'    var bestScore = scored[0].score;',
'    var bestMM = scored[0].mm;',
'    var equallyBest = scored.filter(function(s) { return s.mm === bestMM && s.score === bestScore; });',
'    var numLoci = Math.min(equallyBest.length, maxLoci);',
'',
'    if (multiMap === "best" || numLoci === 1) {',
'        var result = {};',
'        for (var key in scored[0]) result[key] = scored[0][key];',
'        result.numLoci = equallyBest.length;',
'        return result;',
'    } else if (multiMap === "random") {',
'        var pick = equallyBest[Math.floor(Math.random() * numLoci)];',
'        var result = {};',
'        for (var key in pick) result[key] = pick[key];',
'        result.numLoci = equallyBest.length;',
'        return result;',
'    } else {',
'        return equallyBest.slice(0, numLoci).map(function(s) {',
'            var result = {};',
'            for (var key in s) result[key] = s[key];',
'            result.numLoci = equallyBest.length;',
'            return result;',
'        });',
'    }',
'}',
'',
'// Handle messages from main thread',
'self.onmessage = function(e) {',
'    var type = e.data.type;',
'    var data = e.data.data;',
'    ',
'    if (type === "init") {',
'        // Initialize with reference data and settings',
'        refs = data.refs;',
'        refOrder = data.refOrder;',
'        settings = data.settings;',
'        ',
'        // Rebuild kmer index from serialized data',
'        kmerIdx = new Map();',
'        for (var i = 0; i < data.kmerIdxArr.length; i++) {',
'            kmerIdx.set(data.kmerIdxArr[i][0], data.kmerIdxArr[i][1]);',
'        }',
'        kmerCounts = new Map();',
'        for (var i = 0; i < data.kmerCountsArr.length; i++) {',
'            kmerCounts.set(data.kmerCountsArr[i][0], data.kmerCountsArr[i][1]);',
'        }',
'        ',
'        self.postMessage({ type: "ready" });',
'    }',
'    else if (type === "mapBatch") {',
'        // Map a batch of reads',
'        var batch = data.batch;',
'        var batchId = data.batchId;',
'        var results = [];',
'        var mapped = 0;',
'        ',
'        for (var i = 0; i < batch.length; i++) {',
'            var m = mapRead(batch[i]);',
'            if (m) {',
'                mapped++;',
'                if (Array.isArray(m)) {',
'                    for (var j = 0; j < m.length; j++) results.push(m[j]);',
'                } else {',
'                    results.push(m);',
'                }',
'            }',
'        }',
'        ',
'        self.postMessage({ ',
'            type: "batchResult", ',
'            data: { results: results, total: batch.length, mapped: mapped, batchId: batchId } ',
'        });',
'    }',
'};'
].join('\n');

// Create worker pool
class WorkerPool {
    constructor(numWorkers = navigator.hardwareConcurrency || 4) {
        this.numWorkers = Math.max(1, Math.min(numWorkers, 8)); // Cap at 8 workers
        this.workers = [];
        this.available = [];
        this.pending = [];
        this.initialized = false;
        this.onBatchComplete = null;
    }
    
    async init(mapper) {
        // Create blob URL from worker code
        const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        
        // Serialize kmer index for transfer to workers
        const kmerIdxArr = Array.from(mapper.kmerIdx.entries());
        const kmerCountsArr = Array.from(mapper.kmerCounts.entries());
        
        const initData = {
            refs: mapper.refs,
            refOrder: mapper.refOrder,
            settings: mapper.settings,
            kmerIdxArr,
            kmerCountsArr
        };
        
        // Create and initialize workers
        const initPromises = [];
        for (let i = 0; i < this.numWorkers; i++) {
            const worker = new Worker(workerUrl);
            this.workers.push(worker);
            
            const p = new Promise((resolve) => {
                worker.onmessage = (e) => {
                    if (e.data.type === 'ready') {
                        resolve();
                    } else if (e.data.type === 'batchResult') {
                        this.handleBatchResult(worker, e.data.data);
                    }
                };
            });
            
            worker.postMessage({ type: 'init', data: initData });
            initPromises.push(p);
        }
        
        await Promise.all(initPromises);
        this.available = [...this.workers];
        this.initialized = true;
        
        // Clean up blob URL
        URL.revokeObjectURL(workerUrl);
        
        console.log('WorkerPool initialized with ' + this.numWorkers + ' workers');
    }
    
    handleBatchResult(worker, result) {
        // Return worker to available pool
        this.available.push(worker);
        
        // Notify caller
        if (this.onBatchComplete) {
            this.onBatchComplete(result);
        }
        
        // Process pending batches
        this.processPending();
    }
    
    processPending() {
        while (this.available.length > 0 && this.pending.length > 0) {
            const worker = this.available.pop();
            const { batch, batchId } = this.pending.shift();
            worker.postMessage({ type: 'mapBatch', data: { batch, batchId } });
        }
    }
    
    submitBatch(batch, batchId) {
        if (this.available.length > 0) {
            const worker = this.available.pop();
            worker.postMessage({ type: 'mapBatch', data: { batch, batchId } });
        } else {
            this.pending.push({ batch, batchId });
        }
    }
    
    terminate() {
        for (const worker of this.workers) {
            worker.terminate();
        }
        this.workers = [];
        this.available = [];
        this.pending = [];
        this.initialized = false;
    }
    
    get pendingCount() {
        return this.pending.length + (this.numWorkers - this.available.length);
    }
}

class Mapper {
    constructor() {
        this.refs = {}; this.refOrder = []; this.kmerIdx = new Map(); this.kmerCounts = new Map();
        this.covFwd = {}; this.covRev = {}; this.cov5Fwd = {}; this.cov5Rev = {}; this.cov3Fwd = {}; this.cov3Rev = {};
        this.replicates = [];
        this.settings = { 
            kmer: 15, seeds: 1, mm: 2, mmPenalty: 2, minLen: 18, maxLen: 30, 
            qmin: 18, qmax: 30, tmin: 18, tmax: 30, omin: -10, omax: 30,
            adaptiveSeed: true, multiMap: 'best', maxLoci: 10,
            no3PrimeMM: false, nAsMatch: false
        };
        this.stats = { total: 0, mapped: 0, multiMapped: 0 };
        this.running = false; this.stop = false;
    }

    parseFA(txt) {
        const refs = {}, order = [];
        let name = null, seq = '';
        for (const line of txt.trim().split('\n')) {
            const t = line.trim();
            if (t.startsWith('>')) {
                if (name && seq) { refs[name] = seq; order.push(name); }
                name = t.slice(1).split(/\s+/)[0]; seq = '';
            } else seq += t.toUpperCase().replace(/[^ATGCN]/g, '');
        }
        if (name && seq) { refs[name] = seq; order.push(name); }
        return { refs, order };
    }

    setRef(txt) {
        const { refs, order } = this.parseFA(txt);
        if (order.length === 0) return [];
        this.refs = refs; this.refOrder = order;
        for (const n of order) {
            this.covFwd[n] = new Uint32Array(refs[n].length);
            this.covRev[n] = new Uint32Array(refs[n].length);
            this.cov5Fwd[n] = new Uint32Array(refs[n].length);
            this.cov5Rev[n] = new Uint32Array(refs[n].length);
            this.cov3Fwd[n] = new Uint32Array(refs[n].length);
            this.cov3Rev[n] = new Uint32Array(refs[n].length);
        }
        this.buildIdx();
        return order;
    }

    buildIdx() {
        this.kmerIdx.clear();
        this.kmerCounts.clear();
        const k = this.settings.kmer;
        // First pass: count k-mer occurrences for weighting
        for (const seg of this.refOrder) {
            const s = this.refs[seg];
            for (let i = 0; i <= s.length - k; i++) {
                const kmer = s.substring(i, i + k);
                if (!kmer.includes('N')) {
                    this.kmerCounts.set(kmer, (this.kmerCounts.get(kmer) || 0) + 1);
                }
            }
        }
        // Second pass: build index with positions
        for (const seg of this.refOrder) {
            const s = this.refs[seg];
            for (let i = 0; i <= s.length - k; i++) {
                const kmer = s.substring(i, i + k);
                if (!kmer.includes('N')) {
                    if (!this.kmerIdx.has(kmer)) this.kmerIdx.set(kmer, []);
                    this.kmerIdx.get(kmer).push({ seg, pos: i });
                }
            }
        }
    }

    initRep() {
        const { minLen, maxLen } = this.settings;
        const rep = { 
            mappedReads: {}, 
            lenDist5: { fwd: {}, rev: {} }, lenDist3: { fwd: {}, rev: {} },
            lenDistBySeg: {}, // Per-segment length distribution
            bias: { fwd5: [], fwd3: [], rev5: [], rev3: [] }, 
            biasBySeg: {}, // Per-segment nucleotide bias
            // Library-wide (all reads, not just mapped) length distribution
            libLenDist5: {},  // {length: {A:n, C:n, G:n, T:n}}
            libLenDist3: {},  // {length: {A:n, C:n, G:n, T:n}}
            stats: { total: 0, mapped: 0, multiMapped: 0 },
            multiMapCounts: {}
        };
        for (const seg of this.refOrder) {
            rep.mappedReads[seg] = [];
            rep.multiMapCounts[seg] = 0;
            // Per-segment length distribution
            rep.lenDistBySeg[seg] = { 
                len5: { fwd: {}, rev: {} }, 
                len3: { fwd: {}, rev: {} } 
            };
            // Per-segment nucleotide bias
            rep.biasBySeg[seg] = {
                fwd5: [], fwd3: [], rev5: [], rev3: []
            };
            for (let l = minLen; l <= maxLen; l++) {
                rep.lenDistBySeg[seg].len5.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                rep.lenDistBySeg[seg].len5.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
                rep.lenDistBySeg[seg].len3.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                rep.lenDistBySeg[seg].len3.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
            }
            for (let i = 0; i < 20; i++) {
                rep.biasBySeg[seg].fwd5[i] = { A: 0, C: 0, G: 0, T: 0 };
                rep.biasBySeg[seg].fwd3[i] = { A: 0, C: 0, G: 0, T: 0 };
                rep.biasBySeg[seg].rev5[i] = { A: 0, C: 0, G: 0, T: 0 };
                rep.biasBySeg[seg].rev3[i] = { A: 0, C: 0, G: 0, T: 0 };
            }
        }
        for (let l = minLen; l <= maxLen; l++) {
            rep.lenDist5.fwd[l] = { A: 0, C: 0, G: 0, T: 0 }; rep.lenDist5.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
            rep.lenDist3.fwd[l] = { A: 0, C: 0, G: 0, T: 0 }; rep.lenDist3.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
            // Library-wide length distribution
            rep.libLenDist5[l] = { A: 0, C: 0, G: 0, T: 0 };
            rep.libLenDist3[l] = { A: 0, C: 0, G: 0, T: 0 };
        }
        for (let i = 0; i < 20; i++) {
            rep.bias.fwd5[i] = { A: 0, C: 0, G: 0, T: 0 }; rep.bias.fwd3[i] = { A: 0, C: 0, G: 0, T: 0 };
            rep.bias.rev5[i] = { A: 0, C: 0, G: 0, T: 0 }; rep.bias.rev3[i] = { A: 0, C: 0, G: 0, T: 0 };
        }
        return rep;
    }

    // Track library-wide (all reads, not just mapped) length distribution
    // Called for every read during parsing, before mapping
    trackLibRead(seq, rep) {
        const len = seq.length;
        const { minLen, maxLen } = this.settings;
        if (len < minLen || len > maxLen) return;
        
        // Initialize if needed (for lengths outside initial range)
        if (!rep.libLenDist5[len]) rep.libLenDist5[len] = { A: 0, C: 0, G: 0, T: 0 };
        if (!rep.libLenDist3[len]) rep.libLenDist3[len] = { A: 0, C: 0, G: 0, T: 0 };
        
        const nt5 = seq[0];
        const nt3 = seq[len - 1];
        
        if ('ACGT'.includes(nt5)) rep.libLenDist5[len][nt5]++;
        if ('ACGT'.includes(nt3)) rep.libLenDist3[len][nt3]++;
    }

    rc(s) { const c = { A: 'T', T: 'A', G: 'C', C: 'G', N: 'N' }; return s.split('').reverse().map(b => c[b] || 'N').join(''); }

    // Score alignment: matches - (mismatches * penalty)
    scoreAlignment(testSeq, refSeq, penalty, nAsMatch = false) {
        let mm = 0;
        let has3PrimeMM = false;
        const lastPos = testSeq.length - 1;
        
        for (let i = 0; i < testSeq.length; i++) {
            const qBase = testSeq[i].toUpperCase();
            const rBase = refSeq[i].toUpperCase();
            
            // Check for mismatch (handle N bases based on setting)
            let isMismatch;
            if (nAsMatch && (qBase === 'N' || rBase === 'N')) {
                isMismatch = false; // N matches anything
            } else {
                isMismatch = qBase !== rBase;
            }
            
            if (isMismatch) {
                mm++;
                if (i === lastPos) has3PrimeMM = true;
            }
        }
        const score = testSeq.length - (mm * penalty);
        return { mm, score, has3PrimeMM };
    }

    // Collect candidate positions with weighted voting
    collectCandidates(testSeq, k, step) {
        const votes = new Map();
        for (let i = 0; i <= testSeq.length - k; i += step) {
            const kmer = testSeq.substring(i, i + k);
            const hits = this.kmerIdx.get(kmer);
            if (hits) {
                const weight = 1 / (this.kmerCounts.get(kmer) || 1); // Weight by uniqueness
                for (const { seg, pos } of hits) {
                    const sp = pos - i;
                    if (sp >= 0 && sp + testSeq.length <= this.refs[seg].length) {
                        const key = `${seg}:${sp}`;
                        votes.set(key, (votes.get(key) || 0) + weight);
                    }
                }
            }
        }
        return votes;
    }

    mapRead(seq) {
        const { kmer: k, seeds, mm: maxMM, mmPenalty, adaptiveSeed, multiMap, maxLoci, no3PrimeMM, nAsMatch } = this.settings;
        if (seq.length < k) return null;

        let allCandidates = [];

        for (const { testSeq, strand } of [{ testSeq: seq, strand: 'fwd' }, { testSeq: this.rc(seq), strand: 'rev' }]) {
            // Pass A: Fast seeding (step = k/2)
            let votes = this.collectCandidates(testSeq, k, Math.max(1, Math.floor(k / 2)));
            
            // Pass B: Rescue with denser seeding if no candidates (adaptive)
            if (adaptiveSeed && votes.size === 0) {
                votes = this.collectCandidates(testSeq, Math.max(8, k - 2), 1);
            }

            // Get top candidates meeting seed threshold
            const candidates = [];
            for (const [key, v] of votes) {
                if (v >= seeds) {
                    candidates.push({ key, votes: v, strand, testSeq });
                }
            }
            allCandidates.push(...candidates);
        }

        if (allCandidates.length === 0) return null;

        // Sort by votes descending
        allCandidates.sort((a, b) => b.votes - a.votes);

        // Evaluate top N candidates with actual alignment scoring
        const topN = Math.min(10, allCandidates.length);
        const scored = [];
        
        for (let i = 0; i < topN; i++) {
            const c = allCandidates[i];
            const [seg, posStr] = c.key.split(':');
            const pos = parseInt(posStr, 10);
            const refSeg = this.refs[seg].substring(pos, pos + c.testSeq.length);
            const { mm, score, has3PrimeMM } = this.scoreAlignment(c.testSeq, refSeg, mmPenalty, nAsMatch);
            
            // Apply filters
            if (mm > maxMM) continue;
            if (no3PrimeMM && has3PrimeMM) continue;
            
            scored.push({ 
                seg, pos, len: seq.length, strand: c.strand, seq: c.testSeq,
                mm, score, votes: c.votes
            });
        }

        if (scored.length === 0) return null;

        // Sort by: lowest mm, then highest score, then highest votes
        scored.sort((a, b) => {
            if (a.mm !== b.mm) return a.mm - b.mm;
            if (a.score !== b.score) return b.score - a.score;
            return b.votes - a.votes;
        });

        const bestScore = scored[0].score;
        const bestMM = scored[0].mm;
        
        // Find all equally best alignments
        const equallyBest = scored.filter(s => s.mm === bestMM && s.score === bestScore);
        const numLoci = Math.min(equallyBest.length, maxLoci);

        // Handle multi-mapping
        if (multiMap === 'best' || numLoci === 1) {
            return { ...scored[0], numLoci: equallyBest.length };
        } else if (multiMap === 'random') {
            const pick = equallyBest[Math.floor(Math.random() * numLoci)];
            return { ...pick, numLoci: equallyBest.length };
        } else { // all-best
            return equallyBest.slice(0, numLoci).map(s => ({ ...s, numLoci: equallyBest.length }));
        }
    }

    addMap(m, rep, lowMemMode = false) {
        const { seg, pos, len, strand, seq, numLoci } = m;
        const { minLen, maxLen } = this.settings;
        const end = Math.min(pos + len, this.refs[seg].length);
        
        // Full coverage
        if (strand === 'fwd') {
            for (let i = pos; i < end; i++) this.covFwd[seg][i]++;
            this.cov5Fwd[seg][pos]++; // 5' end only
            this.cov3Fwd[seg][end - 1]++; // 3' end only
        } else {
            for (let i = pos; i < end; i++) this.covRev[seg][i]++;
            this.cov5Rev[seg][end - 1]++; // 5' end is at the other end for rev
            this.cov3Rev[seg][pos]++; // 3' end is at start for rev
        }
        
        // In low memory mode, don't store individual reads
        if (!lowMemMode && rep.mappedReads[seg].length < 2000000) {
            rep.mappedReads[seg].push({ pos, len, strand });
        }
        
        // Always track segment counts for table display
        if (!rep.segCounts) rep.segCounts = {};
        rep.segCounts[seg] = (rep.segCounts[seg] || 0) + 1;
        
        // Track multi-mappers
        if (numLoci > 1) {
            rep.stats.multiMapped++;
            rep.multiMapCounts[seg]++;
        }
        
        // For nucleotide bias: 
        // Forward strand: seq is original read orientation, 5' is position 0
        // Reverse strand: seq is RC'd for alignment - this IS the correct orientation
        //                 for siRNA analysis (5' of antisense strand)
        // We want the 5'/3' ends as they appear in the aligned orientation
        // (i.e., relative to the reference strand direction)
        
        if (len >= minLen && len <= maxLen) {
            // For both strands, use seq directly (already in aligned orientation)
            // 5' nt is first position, 3' nt is last position
            const nt5 = seq[0], nt3 = seq[seq.length - 1];
            if ('ACGT'.includes(nt5)) {
                rep.lenDist5[strand][len][nt5]++;
                // Per-segment tracking
                if (rep.lenDistBySeg[seg]?.len5?.[strand]?.[len]) {
                    rep.lenDistBySeg[seg].len5[strand][len][nt5]++;
                }
            }
            if ('ACGT'.includes(nt3)) {
                rep.lenDist3[strand][len][nt3]++;
                if (rep.lenDistBySeg[seg]?.len3?.[strand]?.[len]) {
                    rep.lenDistBySeg[seg].len3[strand][len][nt3]++;
                }
            }
        }
        
        // Nucleotide bias positions in aligned orientation
        const maxP = Math.min(20, seq.length);
        for (let i = 0; i < maxP; i++) {
            const nt5 = seq[i];                        // Position i from 5' end (aligned)
            const nt3 = seq[seq.length - 1 - i];       // Position i from 3' end (aligned)
            if ('ACGT'.includes(nt5)) {
                rep.bias[strand + '5'][i][nt5]++;
                // Per-segment bias tracking
                if (rep.biasBySeg[seg]?.[strand + '5']?.[i]) {
                    rep.biasBySeg[seg][strand + '5'][i][nt5]++;
                }
            }
            if ('ACGT'.includes(nt3)) {
                rep.bias[strand + '3'][i][nt3]++;
                if (rep.biasBySeg[seg]?.[strand + '3']?.[i]) {
                    rep.biasBySeg[seg][strand + '3'][i][nt3]++;
                }
            }
        }
    }

    // Calculate overlap signatures following Mississippi tool logic
    // Uses 5' positions: forward reads use start position, reverse reads use end position
    // Overlap is calculated as the distance between 5' ends of overlapping read pairs
    // Positive overlap = 5' ends overlap; Negative overlap = gap between 5' ends
    calcOverlap(rep, seg, qmin, qmax, tmin, tmax, omin, omax) {
        // Use passed parameters or fall back to settings
        qmin = qmin ?? this.settings.qmin;
        qmax = qmax ?? this.settings.qmax;
        tmin = tmin ?? this.settings.tmin;
        tmax = tmax ?? this.settings.tmax;
        omin = omin ?? this.settings.omin;
        omax = omax ?? this.settings.omax;
        
        const reads = rep.mappedReads[seg] || [];
        if (reads.length === 0) return null;
        
        // Build position maps
        // Forward reads: 5' position is read.pos (0-based start)
        // Reverse reads: 5' position is read.pos + read.len - 1 (0-based end)
        const fwdByPos = {}; // {pos: [len1, len2, ...]}
        const revByPos = {}; // {pos: [len1, len2, ...]}
        
        for (const read of reads) {
            if (read.strand === 'fwd') {
                const pos5 = read.pos;
                if (!fwdByPos[pos5]) fwdByPos[pos5] = [];
                fwdByPos[pos5].push(read.len);
            } else {
                const pos5 = read.pos + read.len - 1;
                if (!revByPos[pos5]) revByPos[pos5] = [];
                revByPos[pos5].push(read.len);
            }
        }
        
        // ========== Z-SIGNATURE (pair counts) ==========
        // Following signature.py countpairs() - BIDIRECTIONAL pairing
        // A pair is counted if:
        //   (upper in query_range AND lower in target_range) OR
        //   (upper in target_range AND lower in query_range)
        // This allows both directions of pairing for asymmetric ranges
        
        const counts = {};
        for (let qlen = qmin; qlen <= qmax; qlen++) {
            counts[qlen] = {};
            for (let o = omin; o <= omax; o++) counts[qlen][o] = 0;
        }
        counts['all'] = {};
        for (let o = omin; o <= omax; o++) counts['all'][o] = 0;
        
        // Count pairs for each overlap distance (bidirectional like signature.py)
        for (const posStr of Object.keys(fwdByPos)) {
            const fwdPos = parseInt(posStr);
            const uppers = fwdByPos[fwdPos].filter(len => 
                (len >= qmin && len <= qmax) || (len >= tmin && len <= tmax));
            
            for (let overlap = omin; overlap <= omax; overlap++) {
                const revPos = fwdPos + overlap - 1;
                const revLengths = revByPos[revPos];
                if (!revLengths || revLengths.length === 0) continue;
                
                const lowers = revLengths.filter(len => 
                    (len >= qmin && len <= qmax) || (len >= tmin && len <= tmax));
                
                // Count pairs following signature.py countpairs() logic
                // Use a copy of lowers to track which have been paired
                const lowersAvailable = [...lowers];
                
                for (const upLen of uppers) {
                    for (let i = 0; i < lowersAvailable.length; i++) {
                        const downLen = lowersAvailable[i];
                        // Check if valid pair (bidirectional)
                        const validPair = 
                            (upLen >= qmin && upLen <= qmax && downLen >= tmin && downLen <= tmax) ||
                            (upLen >= tmin && upLen <= tmax && downLen >= qmin && downLen <= qmax);
                        
                        if (validPair) {
                            // Count by the query-sized read length for heatmap
                            if (upLen >= qmin && upLen <= qmax) {
                                counts[upLen][overlap]++;
                            } else if (downLen >= qmin && downLen <= qmax) {
                                counts[downLen][overlap]++;
                            }
                            counts['all'][overlap]++;
                            lowersAvailable.splice(i, 1); // Remove paired read
                            break;
                        }
                    }
                }
            }
        }
        
        // ========== H-SIGNATURE (probability) ==========
        // Following signature.py compute_signature_h() EXACTLY
        // 
        // Key insight from signature.py:
        // - Query_table and Target_table use SIGNED coordinates
        // - Forward reads: positive coordinate (the 5' position)
        // - Reverse reads: negative coordinate (negative of the 5' position)
        // - For overlap o: target coord = -query_coord - overlap + 1
        //
        // This means: if query is forward at pos P, we look for reverse reads
        // whose 5' end is at position P + overlap - 1 (stored as negative)
        
        // Build Query_table and Target_table following signature.py convention
        // Query_table[coord] = count of query-sized reads at that signed position
        // Target_table[coord] = count of target-sized reads at that signed position
        const Query_table = {};
        const Target_table = {};
        
        // Process forward reads (positive coordinates)
        for (const posStr of Object.keys(fwdByPos)) {
            const pos = parseInt(posStr);
            for (const len of fwdByPos[pos]) {
                if (len >= qmin && len <= qmax) {
                    Query_table[pos] = (Query_table[pos] || 0) + 1;
                }
                if (len >= tmin && len <= tmax) {
                    Target_table[pos] = (Target_table[pos] || 0) + 1;
                }
            }
        }
        
        // Process reverse reads (NEGATIVE coordinates, following signature.py)
        for (const posStr of Object.keys(revByPos)) {
            const pos = parseInt(posStr);
            // Reverse reads stored with negative coordinate
            if (revByPos[pos]) {
                for (const len of revByPos[pos]) {
                    if (len >= qmin && len <= qmax) {
                        Query_table[-pos] = (Query_table[-pos] || 0) + 1;
                    }
                    if (len >= tmin && len <= tmax) {
                        Target_table[-pos] = (Target_table[-pos] || 0) + 1;
                    }
                }
            }
        }
        
        // Calculate Total_Query_Numb (total query reads)
        let Total_Query_Numb = 0;
        for (const coord of Object.keys(Query_table)) {
            Total_Query_Numb += Query_table[coord];
        }
        
        // Initialize h-signature probability table
        const probs = { 'all': {} };
        for (let o = omin; o <= omax; o++) probs['all'][o] = 0;
        
        // Following signature.py compute_signature_h() exactly:
        // for coord in Query_table[chrom]:
        //     local_table = dict([(overlap, 0) for overlap in scope])
        //     number_of_targets = 0
        //     for overlap in scope:
        //         local_table[overlap] += Query_table[chrom][coord] * Target_table[chrom].get(-coord - overlap + 1, 0)
        //         number_of_targets += Target_table[chrom].get(-coord - overlap + 1, 0)
        //     for overlap in scope:
        //         frequency_table[chrom][overlap] += local_table[overlap] / number_of_targets / Total_Query_Numb
        
        for (const coordStr of Object.keys(Query_table)) {
            const coord = parseInt(coordStr);
            const queryCount = Query_table[coord];
            
            // Build local_table and count number_of_targets
            const local_table = {};
            let number_of_targets = 0;
            
            for (let overlap = omin; overlap <= omax; overlap++) {
                // Target coordinate: -coord - overlap + 1
                // This is the key formula from signature.py
                const targetCoord = -coord - overlap + 1;
                const targetCount = Target_table[targetCoord] || 0;
                
                local_table[overlap] = queryCount * targetCount;
                number_of_targets += targetCount;
            }
            
            // Add to frequency table with normalization
            if (number_of_targets > 0 && Total_Query_Numb > 0) {
                for (let overlap = omin; overlap <= omax; overlap++) {
                    probs['all'][overlap] += local_table[overlap] / number_of_targets / Total_Query_Numb;
                }
            }
        }
        
        // Per-query-length h-signature probabilities
        // For these, we need to track by query length as well
        for (let qlen = qmin; qlen <= qmax; qlen++) {
            probs[qlen] = {};
            for (let o = omin; o <= omax; o++) probs[qlen][o] = 0;
            
            // Build length-specific query table
            const Query_table_len = {};
            let Total_Query_Numb_len = 0;
            
            // Forward reads of this length
            for (const posStr of Object.keys(fwdByPos)) {
                const pos = parseInt(posStr);
                const count = fwdByPos[pos].filter(len => len === qlen).length;
                if (count > 0) {
                    Query_table_len[pos] = count;
                    Total_Query_Numb_len += count;
                }
            }
            // Reverse reads of this length (negative coords)
            for (const posStr of Object.keys(revByPos)) {
                const pos = parseInt(posStr);
                const count = revByPos[pos].filter(len => len === qlen).length;
                if (count > 0) {
                    Query_table_len[-pos] = count;
                    Total_Query_Numb_len += count;
                }
            }
            
            // Calculate h-signature for this length
            for (const coordStr of Object.keys(Query_table_len)) {
                const coord = parseInt(coordStr);
                const queryCount = Query_table_len[coord];
                
                const local_table = {};
                let number_of_targets = 0;
                
                for (let overlap = omin; overlap <= omax; overlap++) {
                    const targetCoord = -coord - overlap + 1;
                    const targetCount = Target_table[targetCoord] || 0;
                    
                    local_table[overlap] = queryCount * targetCount;
                    number_of_targets += targetCount;
                }
                
                if (number_of_targets > 0 && Total_Query_Numb_len > 0) {
                    for (let overlap = omin; overlap <= omax; overlap++) {
                        probs[qlen][overlap] += local_table[overlap] / number_of_targets / Total_Query_Numb_len;
                    }
                }
            }
        }
        
        // ========== Z-SCORE CALCULATIONS ==========
        // Following signature.py stringify_table():
        // z_mean = numpy.mean(accumulator)
        // z_std = numpy.std(accumulator)
        // z_score = (value - z_mean) / z_std
        
        const countZscores = {}, probZscores = {};
        
        for (const key of Object.keys(counts)) {
            const countsObj = counts[key];
            const probsObj = probs[key];
            
            // Get values as arrays
            const countArr = [];
            const probArr = [];
            for (let o = omin; o <= omax; o++) {
                countArr.push(countsObj[o] || 0);
                probArr.push(probsObj[o] || 0);
            }
            
            // Z-scores for counts (z-signature)
            countZscores[key] = {};
            const cMean = countArr.reduce((a, b) => a + b, 0) / countArr.length;
            const cStd = Math.sqrt(countArr.reduce((a, b) => a + (b - cMean) ** 2, 0) / countArr.length) || 1;
            for (let o = omin; o <= omax; o++) {
                countZscores[key][o] = ((countsObj[o] || 0) - cMean) / cStd;
            }
            
            // Z-scores for probabilities (h-signature z-scores)
            probZscores[key] = {};
            const pMean = probArr.reduce((a, b) => a + b, 0) / probArr.length;
            const pStd = Math.sqrt(probArr.reduce((a, b) => a + (b - pMean) ** 2, 0) / probArr.length) || 1;
            for (let o = omin; o <= omax; o++) {
                probZscores[key][o] = ((probsObj[o] || 0) - pMean) / pStd;
            }
        }
        
        return { 
            counts, 
            probs, 
            countZscores, 
            probZscores,
            zscores: probZscores,
            settings: { qmin, qmax, tmin, tmax, omin, omax }
        };
    }

    *parseFQ(text) {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length - 3; i++) {
            if (lines[i].startsWith('@')) {
                const seq = lines[i + 1].trim().toUpperCase();
                if (seq.length > 0 && !seq.includes('N')) yield seq;
                i += 3;
            }
        }
    }

    *parseFA2(text) {
        let seq = '';
        for (const line of text.split('\n')) {
            const t = line.trim();
            if (t.startsWith('>')) { if (seq && !seq.includes('N')) yield seq; seq = ''; }
            else seq += t.toUpperCase().replace(/[^ATGC]/g, '');
        }
        if (seq && !seq.includes('N')) yield seq;
    }

    reset() {
        this.stats = { total: 0, mapped: 0, multiMapped: 0 };
        this.replicates = [];
        for (const seg of this.refOrder) { 
            this.covFwd[seg].fill(0); this.covRev[seg].fill(0);
            this.cov5Fwd[seg].fill(0); this.cov5Rev[seg].fill(0);
            this.cov3Fwd[seg].fill(0); this.cov3Rev[seg].fill(0);
        }
        this.stop = false;
    }
}

// SVG Builder - Complete Canvas 2D API compatible SVG renderer
// This class mimics the Canvas 2D context API but outputs SVG
class SVGBuilder {
    constructor(w, h) {
        this.w = w;
        this.h = h;
        this.elements = [];
        this.defs = [];
        this.gradientId = 0;
        this.currentState = {
            fill: '#000',
            stroke: '#000',
            lineWidth: 1,
            font: '10px system-ui',
            textAlign: 'left',
            textBaseline: 'alphabetic',
            lineDash: [],
            globalAlpha: 1
        };
        this.stateStack = [];
        this.currentPath = [];
        this._openGroups = 0;
        this._transformStack = [];
    }
    
    // State management
    save() { 
        this.stateStack.push({
            ...this.currentState, 
            lineDash: [...this.currentState.lineDash]
        });
        this._transformStack.push(this._openGroups);
    }
    
    restore() { 
        if (this.stateStack.length) {
            this.currentState = this.stateStack.pop();
            const prevGroups = this._transformStack.pop() || 0;
            while (this._openGroups > prevGroups) {
                this.elements.push('</g>');
                this._openGroups--;
            }
        }
    }
    
    // Style setters/getters
    set fillStyle(v) { 
        // Finalize gradient if it's being used
        if (v && typeof v === 'object' && v._finalize) {
            v._finalize();
        }
        this.currentState.fill = v; 
    }
    get fillStyle() { return this.currentState.fill; }
    set strokeStyle(v) { 
        if (v && typeof v === 'object' && v._finalize) {
            v._finalize();
        }
        this.currentState.stroke = v; 
    }
    get strokeStyle() { return this.currentState.stroke; }
    set lineWidth(v) { this.currentState.lineWidth = v; }
    get lineWidth() { return this.currentState.lineWidth; }
    set font(v) { this.currentState.font = v; }
    get font() { return this.currentState.font; }
    set textAlign(v) { this.currentState.textAlign = v; }
    get textAlign() { return this.currentState.textAlign; }
    set textBaseline(v) { this.currentState.textBaseline = v; }
    get textBaseline() { return this.currentState.textBaseline; }
    set globalAlpha(v) { this.currentState.globalAlpha = v; }
    get globalAlpha() { return this.currentState.globalAlpha; }
    
    setLineDash(arr) { this.currentState.lineDash = arr || []; }
    getLineDash() { return this.currentState.lineDash; }
    
    // Escape XML special characters
    esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
    
    // Parse font string
    parseFont() {
        const f = this.currentState.font;
        const match = f.match(/^(bold\s+|italic\s+)?([\d.]+)px\s+(.+)$/i);
        if (match) {
            return {
                weight: match[1]?.includes('bold') ? 'bold' : 'normal',
                style: match[1]?.includes('italic') ? 'italic' : 'normal',
                size: parseFloat(match[2]),
                family: match[3]
            };
        }
        return { weight: 'normal', style: 'normal', size: 10, family: 'system-ui, sans-serif' };
    }
    
    // Get opacity from current fill/stroke including globalAlpha
    getOpacity(color) {
        let alpha = this.currentState.globalAlpha;
        if (typeof color === 'string') {
            const rgbaMatch = color.match(/rgba?\([\d.]+,\s*[\d.]+,\s*[\d.]+(?:,\s*([\d.]+))?\)/);
            if (rgbaMatch && rgbaMatch[1]) {
                alpha *= parseFloat(rgbaMatch[1]);
            }
        }
        return alpha;
    }
    
    // Convert color to SVG-compatible format
    formatColor(color) {
        if (!color) return '#000';
        if (typeof color === 'object' && color._gradientId) {
            return `url(#${color._gradientId})`;
        }
        return color;
    }
    
    // Get dash array attribute
    getDashAttr() {
        return this.currentState.lineDash.length ? ` stroke-dasharray="${this.currentState.lineDash.join(',')}"` : '';
    }
    
    // Drawing methods
    fillRect(x, y, w, h) {
        const fill = this.formatColor(this.currentState.fill);
        const opacity = this.getOpacity(this.currentState.fill);
        const opacityAttr = opacity < 1 ? ` fill-opacity="${opacity.toFixed(2)}"` : '';
        this.elements.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${Math.max(0,w).toFixed(2)}" height="${Math.max(0,h).toFixed(2)}" fill="${fill}"${opacityAttr}/>`);
    }
    
    clearRect(x, y, w, h) {
        this.elements.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w.toFixed(2)}" height="${h.toFixed(2)}" fill="#fff"/>`);
    }
    
    strokeRect(x, y, w, h) {
        const stroke = this.formatColor(this.currentState.stroke);
        const opacity = this.getOpacity(this.currentState.stroke);
        const opacityAttr = opacity < 1 ? ` stroke-opacity="${opacity.toFixed(2)}"` : '';
        this.elements.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w.toFixed(2)}" height="${h.toFixed(2)}" fill="none" stroke="${stroke}" stroke-width="${this.currentState.lineWidth}"${this.getDashAttr()}${opacityAttr}/>`);
    }
    
    fillText(text, x, y) {
        const f = this.parseFont();
        const anchor = this.currentState.textAlign === 'center' ? 'middle' : 
                       this.currentState.textAlign === 'right' ? 'end' : 'start';
        const fill = this.formatColor(this.currentState.fill);
        const opacity = this.getOpacity(this.currentState.fill);
        const opacityAttr = opacity < 1 ? ` fill-opacity="${opacity.toFixed(2)}"` : '';
        const weightAttr = f.weight === 'bold' ? ' font-weight="bold"' : '';
        const styleAttr = f.style === 'italic' ? ' font-style="italic"' : '';
        // Adjust y for baseline
        const baseline = this.currentState.textBaseline;
        let dy = 0;
        if (baseline === 'top') dy = f.size * 0.8;
        else if (baseline === 'middle') dy = f.size * 0.35;
        else if (baseline === 'bottom') dy = -f.size * 0.2;
        this.elements.push(`<text x="${x.toFixed(2)}" y="${(y + dy).toFixed(2)}" fill="${fill}" font-size="${f.size}" font-family="${this.esc(f.family)}" text-anchor="${anchor}"${weightAttr}${styleAttr}${opacityAttr}>${this.esc(text)}</text>`);
    }
    
    strokeText(text, x, y) {
        const f = this.parseFont();
        const anchor = this.currentState.textAlign === 'center' ? 'middle' : 
                       this.currentState.textAlign === 'right' ? 'end' : 'start';
        const stroke = this.formatColor(this.currentState.stroke);
        const weightAttr = f.weight === 'bold' ? ' font-weight="bold"' : '';
        this.elements.push(`<text x="${x.toFixed(2)}" y="${y.toFixed(2)}" fill="none" stroke="${stroke}" stroke-width="${this.currentState.lineWidth}" font-size="${f.size}" font-family="${this.esc(f.family)}" text-anchor="${anchor}"${weightAttr}>${this.esc(text)}</text>`);
    }
    
    measureText(text) {
        const f = this.parseFont();
        // Approximate width based on font size and character count
        return { width: text.length * f.size * 0.6 };
    }
    
    // Path building
    beginPath() { this.currentPath = []; }
    
    moveTo(x, y) { 
        if (isFinite(x) && isFinite(y)) {
            this.currentPath.push(`M${x.toFixed(2)},${y.toFixed(2)}`); 
        }
    }
    
    lineTo(x, y) { 
        if (isFinite(x) && isFinite(y)) {
            this.currentPath.push(`L${x.toFixed(2)},${y.toFixed(2)}`); 
        }
    }
    
    closePath() { this.currentPath.push('Z'); }
    
    quadraticCurveTo(cpx, cpy, x, y) {
        if (isFinite(cpx) && isFinite(cpy) && isFinite(x) && isFinite(y)) {
            this.currentPath.push(`Q${cpx.toFixed(2)},${cpy.toFixed(2)} ${x.toFixed(2)},${y.toFixed(2)}`);
        }
    }
    
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.currentPath.push(`C${cp1x.toFixed(2)},${cp1y.toFixed(2)} ${cp2x.toFixed(2)},${cp2y.toFixed(2)} ${x.toFixed(2)},${y.toFixed(2)}`);
    }
    
    arc(x, y, r, startAngle, endAngle, counterclockwise = false) {
        if (!isFinite(x) || !isFinite(y) || !isFinite(r) || r <= 0) return;
        
        // Full circle
        if (Math.abs(endAngle - startAngle) >= Math.PI * 2 - 0.001) {
            this.currentPath.push(`M${(x + r).toFixed(2)},${y.toFixed(2)}`);
            this.currentPath.push(`A${r.toFixed(2)},${r.toFixed(2)} 0 1,0 ${(x - r).toFixed(2)},${y.toFixed(2)}`);
            this.currentPath.push(`A${r.toFixed(2)},${r.toFixed(2)} 0 1,0 ${(x + r).toFixed(2)},${y.toFixed(2)}`);
            return;
        }
        
        // Partial arc
        const startX = x + r * Math.cos(startAngle);
        const startY = y + r * Math.sin(startAngle);
        const endX = x + r * Math.cos(endAngle);
        const endY = y + r * Math.sin(endAngle);
        
        let diff = endAngle - startAngle;
        if (counterclockwise) diff = -diff;
        while (diff < 0) diff += Math.PI * 2;
        while (diff > Math.PI * 2) diff -= Math.PI * 2;
        
        const largeArc = diff > Math.PI ? 1 : 0;
        const sweep = counterclockwise ? 0 : 1;
        
        if (this.currentPath.length === 0) {
            this.currentPath.push(`M${startX.toFixed(2)},${startY.toFixed(2)}`);
        } else {
            this.currentPath.push(`L${startX.toFixed(2)},${startY.toFixed(2)}`);
        }
        this.currentPath.push(`A${r.toFixed(2)},${r.toFixed(2)} 0 ${largeArc},${sweep} ${endX.toFixed(2)},${endY.toFixed(2)}`);
    }
    
    arcTo(x1, y1, x2, y2, r) {
        // Simplified - just draw lines
        this.lineTo(x1, y1);
        this.lineTo(x2, y2);
    }
    
    rect(x, y, w, h) {
        this.currentPath.push(`M${x.toFixed(2)},${y.toFixed(2)}`);
        this.currentPath.push(`L${(x+w).toFixed(2)},${y.toFixed(2)}`);
        this.currentPath.push(`L${(x+w).toFixed(2)},${(y+h).toFixed(2)}`);
        this.currentPath.push(`L${x.toFixed(2)},${(y+h).toFixed(2)}`);
        this.currentPath.push('Z');
    }
    
    fill(fillRule) {
        if (this.currentPath?.length) {
            const fill = this.formatColor(this.currentState.fill);
            const opacity = this.getOpacity(this.currentState.fill);
            const opacityAttr = opacity < 1 ? ` fill-opacity="${opacity.toFixed(2)}"` : '';
            const ruleAttr = fillRule === 'evenodd' ? ' fill-rule="evenodd"' : '';
            this.elements.push(`<path d="${this.currentPath.join('')}" fill="${fill}"${opacityAttr}${ruleAttr}/>`);
        }
    }
    
    stroke() {
        if (this.currentPath?.length) {
            const stroke = this.formatColor(this.currentState.stroke);
            const opacity = this.getOpacity(this.currentState.stroke);
            const opacityAttr = opacity < 1 ? ` stroke-opacity="${opacity.toFixed(2)}"` : '';
            this.elements.push(`<path d="${this.currentPath.join('')}" fill="none" stroke="${stroke}" stroke-width="${this.currentState.lineWidth}"${this.getDashAttr()}${opacityAttr} stroke-linecap="round" stroke-linejoin="round"/>`);
        }
    }
    
    clip() {
        if (this.currentPath?.length) {
            const clipId = `clip${this.gradientId++}`;
            this.defs.push(`<clipPath id="${clipId}"><path d="${this.currentPath.join('')}"/></clipPath>`);
            this.elements.push(`<g clip-path="url(#${clipId})">`);
            this._openGroups++;
        }
    }
    
    // Transforms
    translate(x, y) { 
        this.elements.push(`<g transform="translate(${x.toFixed(2)},${y.toFixed(2)})">`); 
        this._openGroups++; 
    }
    
    rotate(angle) { 
        const deg = angle * 180 / Math.PI;
        this.elements.push(`<g transform="rotate(${deg.toFixed(2)})">`); 
        this._openGroups++; 
    }
    
    scale(x, y = x) { 
        this.elements.push(`<g transform="scale(${x.toFixed(4)},${y.toFixed(4)})">`); 
        this._openGroups++; 
    }
    
    transform(a, b, c, d, e, f) {
        this.elements.push(`<g transform="matrix(${a},${b},${c},${d},${e},${f})">`);
        this._openGroups++;
    }
    
    setTransform(a, b, c, d, e, f) {
        // Reset and apply - close all groups and start fresh
        while (this._openGroups > 0) {
            this.elements.push('</g>');
            this._openGroups--;
        }
        if (a !== 1 || b !== 0 || c !== 0 || d !== 1 || e !== 0 || f !== 0) {
            this.elements.push(`<g transform="matrix(${a},${b},${c},${d},${e},${f})">`);
            this._openGroups++;
        }
    }
    
    resetTransform() {
        this.setTransform(1, 0, 0, 1, 0, 0);
    }
    
    // Gradient support - returns an object that can be used as fillStyle
    createLinearGradient(x0, y0, x1, y1) {
        const id = `grad${this.gradientId++}`;
        const self = this;
        const gradient = {
            _gradientId: id,
            _type: 'linear',
            _x0: x0, _y0: y0, _x1: x1, _y1: y1,
            _stops: [],
            _finalized: false,
            addColorStop: function(offset, color) {
                this._stops.push({ offset, color });
            }
        };
        // We'll add the gradient to defs when it's actually used
        gradient._finalize = () => {
            if (gradient._finalized) return; // Only finalize once
            gradient._finalized = true;
            const stops = gradient._stops.map(s => 
                `<stop offset="${(s.offset * 100).toFixed(1)}%" stop-color="${s.color}"/>`
            ).join('');
            self.defs.push(`<linearGradient id="${id}" x1="${x0}" y1="${y0}" x2="${x1}" y2="${y1}" gradientUnits="userSpaceOnUse">${stops}</linearGradient>`);
        };
        return gradient;
    }
    
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        const id = `grad${this.gradientId++}`;
        const self = this;
        const gradient = {
            _gradientId: id,
            _type: 'radial',
            _stops: [],
            _finalized: false,
            addColorStop: function(offset, color) {
                this._stops.push({ offset, color });
            }
        };
        gradient._finalize = () => {
            if (gradient._finalized) return;
            gradient._finalized = true;
            const stops = gradient._stops.map(s => 
                `<stop offset="${(s.offset * 100).toFixed(1)}%" stop-color="${s.color}"/>`
            ).join('');
            self.defs.push(`<radialGradient id="${id}" cx="${x1}" cy="${y1}" r="${r1}" fx="${x0}" fy="${y0}" gradientUnits="userSpaceOnUse">${stops}</radialGradient>`);
        };
        return gradient;
    }
    
    // Image drawing (not supported in pure SVG, skip or embed as data URL)
    drawImage() {
        // Skip - images require special handling
    }
    
    // Finalize any pending gradients before converting to string
    _finalizeGradients() {
        // Find all gradient references and finalize them
        const findGradients = (obj) => {
            if (obj && typeof obj === 'object' && obj._gradientId && obj._finalize) {
                obj._finalize();
            }
        };
        findGradients(this.currentState.fill);
        findGradients(this.currentState.stroke);
    }
    
    // Close any open groups
    closeGroups() {
        while (this._openGroups > 0) {
            this.elements.push('</g>');
            this._openGroups--;
        }
    }
    
    // Generate final SVG string
    toSVG() {
        this._finalizeGradients();
        this.closeGroups();
        
        const defs = this.defs.length ? `<defs>\n${this.defs.join('\n')}\n</defs>` : '';
        return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${this.w}" height="${this.h}" viewBox="0 0 ${this.w} ${this.h}">
<style>text { dominant-baseline: middle; }</style>
${defs}
<rect width="100%" height="100%" fill="#fff"/>
${this.elements.join('\n')}
</svg>`;
    }
}

class UI {
    constructor() {
        this.M = new Mapper(); this.files = []; this.ovlData = {}; this.ovlSettings = {}; this.aggData = null; this.plotInfo = {};
        this.cacheKey = null;
        this.init();
    }

    init() {
        this.setupDrop('ref-drop', 'ref-file', f => this.loadRef(f));
        this.setupDrop('reads-drop', 'reads-file', f => this.loadReads(f), true);
        document.getElementById('ref-text').addEventListener('input', () => this.procRef());
        document.getElementById('run-btn').addEventListener('click', () => this.run());
        document.getElementById('stop-btn').addEventListener('click', () => { this.M.stop = true; });
        document.getElementById('reset-btn').addEventListener('click', () => this.resetAll());
        
        // Cache controls
        document.getElementById('cache-load-btn').addEventListener('click', () => this.loadFromCache());
        document.getElementById('cache-delete-btn').addEventListener('click', () => this.deleteFromCache());
        document.getElementById('cache-clear-btn').addEventListener('click', () => this.clearCache());
        document.getElementById('import-json-btn').addEventListener('click', () => document.getElementById('import-json-file').click());
        document.getElementById('import-json-file').addEventListener('change', (e) => this.importJSON(e.target.files[0]));
        this.initCache();
        
        // Aesthetics panel toggle
        document.getElementById('aesthetics-toggle').addEventListener('click', () => {
            document.getElementById('aesthetics-panel').classList.toggle('collapsed');
        });
        
        // Recent references controls
        document.getElementById('save-ref-btn').addEventListener('click', () => this.saveReference());
        document.getElementById('delete-ref-btn').addEventListener('click', () => this.deleteReference());
        document.getElementById('recent-refs').addEventListener('change', (e) => this.loadReference(e.target.value));
        this.refreshRecentRefs();
        
        const ctrls = ['cov-w','cov-h','cov-ymax-fwd','cov-ymax-rev','cov-seg','cov-err','cov-lw','cov-fwd-col','cov-rev-col','cov-data','cov-type','cov-font','cov-len-min','cov-len-max','cov-xoff','cov-yoff',
            'cov-range-start','cov-range-end','cov-show-seq','cov-lock-y','cov-pan-mode','cov-xtick','cov-xstart','cov-ytick','cov-xbold','cov-ybold',
            'len-w','len-h','len-ymax-fwd','len-ymax-rev','len-err','len-top-end','len-bot-end','len-data','len-xtick','len-ytick','len-font','len-pts','len-jitter','len-seg','len-xoff','len-yoff','len-show-legend','len-leg-font','len-leg-pos','len-leg-bold',
            'bias-w','bias-h','bias-end','bias-strand','bias-type','bias-maxbits','bias-xtick','bias-err','bias-font','bias-seg','bias-len-min','bias-len-max','bias-show-legend','bias-leg-font','bias-leg-pos','bias-leg-bold','bias-leg-xoff','bias-leg-yoff',
            'ovl-w','ovl-h','ovl-seg','ovl-font','ovl-qmin','ovl-qmax','ovl-tmin','ovl-tmax','ovl-omin','ovl-omax','ovl-err','ovl-pts','ovl-normalize-rpm','ovl-ymax-counts','ovl-ymax-probs','ovl-ymax-z','ovl-ytick-counts','ovl-ytick-probs','ovl-ytick-z','ovl-xtick',
            'ovl-panel-w','ovl-panel-h','ovl-title-size','ovl-title-bold','ovl-xoff','ovl-yoff','ovl-show-border','ovl-show-10line','ovl-show-subtitles',
            'ovl-hm-w','ovl-hm-h','ovl-hm-font','ovl-hm-seg','ovl-hm-data','ovl-hm-colors','ovl-hm-xtick','ovl-hm-zmin','ovl-hm-zmax','ovl-hm-qmin','ovl-hm-qmax','ovl-hm-omin','ovl-hm-omax',
            'err-type','err-opacity','col-A','col-C','col-G','col-T',
            'color-palette','font-family','font-size','label-size',
            'hist5-w','hist5-h','hist5-ymax','hist5-ytick','hist5-xstart','hist5-xtick','hist5-cap','hist5-barw','hist5-err','hist5-pts','hist5-data','hist5-font','hist5-jitter','hist5-pt-opacity','hist5-xoff','hist5-yoff','hist5-show-legend','hist5-leg-font','hist5-leg-pos','hist5-leg-bold',
            'hist3-w','hist3-h','hist3-ymax','hist3-ytick','hist3-xstart','hist3-xtick','hist3-cap','hist3-barw','hist3-err','hist3-pts','hist3-data','hist3-font','hist3-jitter','hist3-pt-opacity','hist3-xoff','hist3-yoff','hist3-show-legend','hist3-leg-font','hist3-leg-pos','hist3-leg-bold',
            'len-pt-opacity','len-barw'];
        ctrls.forEach(id => { const el = document.getElementById(id); if (el) el.addEventListener('change', () => this.redraw()); });
        
        // Zoom and pan controls for coverage
        document.getElementById('cov-reset-zoom').addEventListener('click', () => {
            document.getElementById('cov-range-start').value = 0;
            document.getElementById('cov-range-end').value = 0;
            this.redraw();
        });
        document.getElementById('cov-zoom-in').addEventListener('click', () => this.covZoom(0.5));
        document.getElementById('cov-zoom-out').addEventListener('click', () => this.covZoom(2));
        document.getElementById('cov-pan-left').addEventListener('click', () => this.covPan(-0.25));
        document.getElementById('cov-pan-right').addEventListener('click', () => this.covPan(0.25));
        
        // Pan mode with mouse drag
        const covCanvas = document.getElementById('cov-canvas');
        covCanvas.style.cursor = 'default';
        let panStart = null;
        covCanvas.addEventListener('mousedown', e => {
            if (document.getElementById('cov-pan-mode')?.checked) {
                panStart = { x: e.clientX, rangeStart: +document.getElementById('cov-range-start').value, rangeEnd: +document.getElementById('cov-range-end').value };
                covCanvas.style.cursor = 'grabbing';
            }
        });
        covCanvas.addEventListener('mousemove', e => {
            if (panStart && document.getElementById('cov-pan-mode')?.checked) {
                const info = this.plotInfo.cov;
                if (!info) return;
                const dx = e.clientX - panStart.x;
                const posPerPx = info.refLen / info.pw;
                const shift = Math.round(-dx * posPerPx);
                let newStart = panStart.rangeStart + shift;
                let newEnd = panStart.rangeEnd + shift;
                const maxLen = info.fullRefLen || this.M.refs[info.seg]?.length || 10000;
                if (newStart < 0) { newEnd -= newStart; newStart = 0; }
                if (newEnd > maxLen) { newStart -= (newEnd - maxLen); newEnd = maxLen; }
                document.getElementById('cov-range-start').value = Math.max(0, newStart);
                document.getElementById('cov-range-end').value = newEnd;
                this.drawCov();
            } else if (document.getElementById('cov-pan-mode')?.checked) {
                covCanvas.style.cursor = 'grab';
            }
        });
        covCanvas.addEventListener('mouseup', () => { panStart = null; covCanvas.style.cursor = document.getElementById('cov-pan-mode')?.checked ? 'grab' : 'default'; });
        covCanvas.addEventListener('mouseleave', () => { panStart = null; });
        
        // Update color pickers when palette changes
        document.getElementById('color-palette').addEventListener('change', () => this.applyPalette());
        // Revert buttons
        document.getElementById('rev-hist5').addEventListener('click', () => this.revertPanel('hist5'));
        document.getElementById('rev-hist3').addEventListener('click', () => this.revertPanel('hist3'));
        document.getElementById('rev-cov').addEventListener('click', () => this.revertPanel('cov'));
        document.getElementById('rev-len').addEventListener('click', () => this.revertPanel('len'));
        document.getElementById('rev-bias').addEventListener('click', () => this.revertPanel('bias'));
        document.getElementById('rev-ovl').addEventListener('click', () => this.revertPanel('ovl'));
        document.getElementById('rev-ovl-hm')?.addEventListener('click', () => this.revertPanel('ovl-hm'));
        document.getElementById('exp-cov-svg').addEventListener('click', () => this.expSVG('cov-canvas', 'coverage'));
        document.getElementById('exp-cov-png').addEventListener('click', () => this.expPNG('cov-canvas', 'coverage'));
        document.getElementById('exp-cov-pdf')?.addEventListener('click', () => this.expPDF('cov-canvas', 'coverage'));
        document.getElementById('exp-cov-tsv').addEventListener('click', () => this.expCovTSV());
        document.getElementById('exp-len-svg').addEventListener('click', () => this.expSVG('len-canvas', 'length'));
        document.getElementById('exp-len-png').addEventListener('click', () => this.expPNG('len-canvas', 'length'));
        document.getElementById('exp-len-pdf').addEventListener('click', () => this.expPDF('len-canvas', 'length'));
        document.getElementById('exp-len-tsv').addEventListener('click', () => this.expLenTSV());
        document.getElementById('exp-bias-svg').addEventListener('click', () => this.expSVG('bias-canvas', 'bias'));
        document.getElementById('exp-bias-png').addEventListener('click', () => this.expPNG('bias-canvas', 'bias'));
        document.getElementById('exp-bias-pdf').addEventListener('click', () => this.expPDF('bias-canvas', 'bias'));
        document.getElementById('exp-ovl-svg').addEventListener('click', () => this.expSVG('ovl-canvas', 'overlap_4panel'));
        document.getElementById('exp-ovl-png').addEventListener('click', () => this.expPNG('ovl-canvas', 'overlap_4panel'));
        document.getElementById('exp-ovl-pdf')?.addEventListener('click', () => this.expPDF('ovl-canvas', 'overlap_4panel'));
        document.getElementById('exp-ovl-tsv').addEventListener('click', () => this.expOvlTSV());
        document.getElementById('exp-ovl-hm-svg')?.addEventListener('click', () => this.expSVG('ovl-hm-canvas', 'overlap_heatmap'));
        document.getElementById('exp-ovl-hm-png')?.addEventListener('click', () => this.expPNG('ovl-hm-canvas', 'overlap_heatmap'));
        document.getElementById('exp-ovl-hm-pdf')?.addEventListener('click', () => this.expPDF('ovl-hm-canvas', 'overlap_heatmap'));
        document.getElementById('exp-all').addEventListener('click', () => this.expStats());
        document.getElementById('exp-hist5-svg').addEventListener('click', () => this.expSVG('hist5-canvas', 'hist5'));
        document.getElementById('exp-hist5-png').addEventListener('click', () => this.expPNG('hist5-canvas', 'hist5'));
        document.getElementById('exp-hist5-pdf').addEventListener('click', () => this.expPDF('hist5-canvas', 'hist5'));
        document.getElementById('exp-hist5-tsv').addEventListener('click', () => this.expHistTSV('5'));
        document.getElementById('exp-hist3-svg').addEventListener('click', () => this.expSVG('hist3-canvas', 'hist3'));
        document.getElementById('exp-hist3-png').addEventListener('click', () => this.expPNG('hist3-canvas', 'hist3'));
        document.getElementById('exp-hist3-pdf').addEventListener('click', () => this.expPDF('hist3-canvas', 'hist3'));
        document.getElementById('exp-hist3-tsv').addEventListener('click', () => this.expHistTSV('3'));
        document.getElementById('exp-rep-tsv').addEventListener('click', () => this.exportRepTSV());
        document.getElementById('exp-standalone').addEventListener('click', () => this.exportStandaloneHTML());
        document.getElementById('recalc-ovl').addEventListener('click', () => {
            if (this.M.replicates.length > 0) {
                this.recalcOverlap();
                this.drawOvl();
                this.drawOvlHeatmap();
            }
        });
        document.getElementById('cov-canvas').addEventListener('mousemove', e => { if (!panStart) this.hoverCov(e); });
        document.getElementById('len-canvas').addEventListener('mousemove', e => this.hoverLen(e));
        document.getElementById('ovl-canvas').addEventListener('mousemove', e => this.hoverOvl(e));
        document.getElementById('ovl-hm-canvas')?.addEventListener('mousemove', e => this.hoverOvlHeatmap(e));
        document.getElementById('hist5-canvas').addEventListener('mousemove', e => this.hoverHist(e, '5'));
        document.getElementById('hist3-canvas').addEventListener('mousemove', e => this.hoverHist(e, '3'));
        this.updateLegends();
    }
    
    // Coverage zoom helper
    covZoom(factor) {
        const seg = document.getElementById('cov-seg').value;
        if (!seg || !this.M.refs[seg]) return;
        const fullLen = this.M.refs[seg].length;
        let start = +document.getElementById('cov-range-start').value || 0;
        let end = +document.getElementById('cov-range-end').value || fullLen;
        if (end <= start) end = fullLen;
        const center = (start + end) / 2;
        const halfRange = (end - start) / 2 * factor;
        let newStart = Math.round(center - halfRange);
        let newEnd = Math.round(center + halfRange);
        if (newStart < 0) { newEnd -= newStart; newStart = 0; }
        if (newEnd > fullLen) { newStart -= (newEnd - fullLen); newEnd = fullLen; }
        if (newStart < 0) newStart = 0;
        if (newEnd - newStart < 10) return; // Minimum range
        document.getElementById('cov-range-start').value = newStart;
        document.getElementById('cov-range-end').value = newEnd;
        this.drawCov();
    }
    
    // Coverage pan helper
    covPan(fraction) {
        const seg = document.getElementById('cov-seg').value;
        if (!seg || !this.M.refs[seg]) return;
        const fullLen = this.M.refs[seg].length;
        let start = +document.getElementById('cov-range-start').value || 0;
        let end = +document.getElementById('cov-range-end').value || fullLen;
        if (end <= start) end = fullLen;
        const range = end - start;
        const shift = Math.round(range * fraction);
        let newStart = start + shift;
        let newEnd = end + shift;
        if (newStart < 0) { newEnd -= newStart; newStart = 0; }
        if (newEnd > fullLen) { newStart -= (newEnd - fullLen); newEnd = fullLen; }
        if (newStart < 0) newStart = 0;
        document.getElementById('cov-range-start').value = newStart;
        document.getElementById('cov-range-end').value = newEnd;
        this.drawCov();
    }

    updateLegends() {
        const c = getNtColors();
        const html = ['A','C','G','T'].map(nt => `<div class="legend-item"><div class="legend-color" style="background:${c[nt]}"></div>${nt==='T'?'T/U':nt}</div>`).join('');
        // Only update legends that still exist as external elements
        const biasLegend = document.getElementById('bias-legend');
        if (biasLegend) biasLegend.innerHTML = html;
        // hist5-legend, hist3-legend, nt-legend are now drawn inside canvas
    }

    applyPalette() {
        const palette = document.getElementById('color-palette').value;
        const colors = COLOR_PALETTES[palette] || COLOR_PALETTES.default;
        document.getElementById('col-A').value = colors.A;
        document.getElementById('col-C').value = colors.C;
        document.getElementById('col-G').value = colors.G;
        document.getElementById('col-T').value = colors.T;
        this.redraw();
    }

    revertPanel(panel) {
        const defaults = {
            hist5: { w: 420, h: 220, ymax: 0, cap: 4, data: 'counts', font: 10, err: true, pts: false },
            hist3: { w: 420, h: 220, ymax: 0, cap: 4, data: 'counts', font: 10, err: true, pts: false },
            cov: { w: 900, h: 240, 'ymax-fwd': 0, 'ymax-rev': 0, data: 'counts', type: 'full', font: 10, err: true },
            len: { w: 700, h: 320, ymax: 0, 'top-end': '5', 'bot-end': '5', data: 'counts', xtick: '1', font: 10, err: true, pts: false },
            bias: { w: 700, h: 180, end: '5', strand: 'both', type: 'prop', maxbits: 2, xtick: '2', font: 10, err: false },
            ovl: { w: 450, h: 400, data: 'z', font: 10 }
        };
        const d = defaults[panel];
        if (!d) return;
        for (const [key, val] of Object.entries(d)) {
            const el = document.getElementById(`${panel}-${key}`);
            if (!el) continue;
            if (el.type === 'checkbox') el.checked = val;
            else el.value = val;
        }
        this.redraw();
    }

    setupDrop(dropId, inputId, handler, multi = false) {
        const drop = document.getElementById(dropId), input = document.getElementById(inputId);
        
        // Click to browse
        drop.onclick = () => input.click();
        
        // Prevent default drag behaviors on all relevant events
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            drop.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        
        // Highlight on dragover
        drop.addEventListener('dragover', e => {
            drop.style.borderColor = 'var(--accent)';
        }, false);
        
        // Remove highlight on dragleave
        drop.addEventListener('dragleave', e => {
            drop.style.borderColor = '';
        }, false);
        
        // Handle drop
        drop.addEventListener('drop', e => {
            drop.style.borderColor = '';
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                handler(multi ? [...files] : files[0]);
            }
        }, false);
        
        // Handle file input change
        input.onchange = e => { 
            const f = multi ? [...e.target.files] : e.target.files[0]; 
            if (f) handler(f); 
        };
    }

    async loadRef(file) {
        const txt = await file.text();
        document.getElementById('ref-text').value = txt;
        this.procRef();
        document.getElementById('ref-info').textContent = file.name;
        document.getElementById('ref-info').classList.add('show');
    }

    procRef() {
        const txt = document.getElementById('ref-text').value.trim();
        if (!txt) return;
        this.updateSettings();
        const order = this.M.setRef(txt);
        if (order.length === 0) { alert('No valid sequences found'); return; }
        document.getElementById('cov-seg').innerHTML = order.map(n => `<option value="${n}">${n}</option>`).join('');
        document.getElementById('len-seg').innerHTML = `<option value="all">All segments</option>` + order.map(n => `<option value="${n}">${n}</option>`).join('');
        document.getElementById('bias-seg').innerHTML = `<option value="all">All segments</option>` + order.map(n => `<option value="${n}">${n}</option>`).join('');
        document.getElementById('ovl-seg').innerHTML = `<option value="all">All segments</option>` + order.map(n => `<option value="${n}">${n}</option>`).join('');
        document.getElementById('ovl-hm-seg').innerHTML = `<option value="all">All segments</option>` + order.map(n => `<option value="${n}">${n}</option>`).join('');
        this.checkReady();
    }

    loadReads(files) {
        this.files = Array.isArray(files) ? files : [files];
        document.getElementById('reads-info').textContent = `${this.files.length} file(s): ${this.files.map(f => f.name).join(', ')}`;
        document.getElementById('reads-info').classList.add('show');
        document.getElementById('rep-info').textContent = this.files.length > 1 ? `${this.files.length} replicates ‚Äî mean ¬± error` : '';
        this.checkReady();
    }

    checkReady() { document.getElementById('run-btn').disabled = !(this.M.refOrder.length > 0 && this.files.length > 0); }

    updateSettings() {
        const s = this.M.settings;
        s.kmer = +document.getElementById('kmer').value || 11;
        s.seeds = +document.getElementById('seeds').value || 1;
        s.mm = +document.getElementById('mismatch').value || 2;
        s.mmPenalty = +document.getElementById('mm-penalty').value || 2;
        s.minLen = +document.getElementById('minlen').value || 18;
        s.maxLen = +document.getElementById('maxlen').value || 30;
        s.qmin = +document.getElementById('qmin').value || 18;
        s.qmax = +document.getElementById('qmax').value || 23;
        s.tmin = +document.getElementById('tmin').value || 24;
        s.tmax = +document.getElementById('tmax').value || 30;
        s.omin = +document.getElementById('omin').value || 1;
        s.omax = +document.getElementById('omax').value || 30;
        s.adaptiveSeed = document.getElementById('adaptive-seed').checked;
        s.multiMap = document.getElementById('multi-map').value || 'best';
        s.maxLoci = +document.getElementById('max-loci').value || 10;
        s.no3PrimeMM = document.getElementById('no-3prime-mm')?.checked || false;
        s.nAsMatch = document.getElementById('n-as-match')?.checked || false;
    }

    async run() {
        if (this.M.running) return;
        this.updateSettings(); this.M.buildIdx(); this.M.reset(); this.M.running = true;
        document.getElementById('run-btn').disabled = true;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('progress').classList.add('show');
        document.getElementById('results').classList.add('show');
        
        const maxReads = +document.getElementById('max-reads').value || 0;
        const lowMemMode = document.getElementById('low-memory-mode')?.checked || false;
        const CHUNK = 4 * 1024 * 1024;
        const BATCH_SIZE = lowMemMode ? 2000 : 5000; // Smaller batches in low memory mode
        const totalBytes = this.files.reduce((s, f) => s + f.size, 0);
        let bytesProc = 0;
        
        // Check if Web Workers are supported
        const useWorkers = typeof Worker !== 'undefined' && navigator.hardwareConcurrency > 1;
        let workerPool = null;
        
        if (useWorkers) {
            try {
                // Get user-specified worker count or auto-detect
                let numWorkers = +document.getElementById('num-workers')?.value || 0;
                if (numWorkers <= 0) {
                    numWorkers = Math.min(navigator.hardwareConcurrency || 4, 8);
                }
                numWorkers = Math.min(Math.max(1, numWorkers), 16); // Clamp 1-16
                document.getElementById('prog-status').textContent = `Initializing ${numWorkers} parallel workers...`;
                workerPool = new WorkerPool(numWorkers);
                await workerPool.init(this.M);
            } catch (err) {
                console.warn('Failed to initialize workers, falling back to single-threaded:', err);
                workerPool = null;
            }
        }
        
        // Progress tracking
        let lastUpdateTime = Date.now();
        const UPDATE_INTERVAL = 100; // Update UI every 100ms max
        
        for (let fi = 0; fi < this.files.length; fi++) {
            if (this.M.stop) break;
            const file = this.files[fi];
            const isGzip = /\.gz$/i.test(file.name);
            const isFasta = /\.(fasta|fa|fna)(\.gz)?$/i.test(file.name);
            const rep = this.M.initRep();
            rep.name = file.name;
            let readsInFile = 0;
            const workerMode = workerPool ? ` [${workerPool.numWorkers} threads]` : '';
            const memMode = lowMemMode ? ' [low memory]' : '';
            document.getElementById('prog-status').textContent = `Replicate ${fi + 1}/${this.files.length}: ${file.name}${isGzip ? ' (streaming decompress)' : ''}${workerMode}${memMode}`;
            
            // For parallel processing: batch reads and track pending results
            let readBatch = [];
            let batchId = 0;
            let pendingBatches = 0;
            let batchResults = [];
            
            // Setup batch result handler
            if (workerPool) {
                workerPool.onBatchComplete = (result) => {
                    pendingBatches--;
                    batchResults.push(result);
                };
            }
            
            // Helper to process a batch of mapping results
            const processBatchResults = () => {
                for (const result of batchResults) {
                    this.M.stats.total += result.total;
                    rep.stats.total += result.total;
                    this.M.stats.mapped += result.mapped;
                    rep.stats.mapped += result.mapped;
                    for (const hit of result.results) {
                        this.M.addMap(hit, rep, lowMemMode);
                    }
                }
                batchResults = [];
            };
            
            // Helper to update progress display with live plotting
            const startTime = Date.now();
            let lastPlotTime = 0;
            let plotUpdateCount = 0;
            const PLOT_INTERVAL = 2000; // Update plots every 2 seconds
            
            const updateProgress = async (force = false) => {
                const now = Date.now();
                if (!force && now - lastUpdateTime < UPDATE_INTERVAL) return;
                lastUpdateTime = now;
                
                // Process any pending batch results
                processBatchResults();
                
                // Calculate progress stats
                const pct = this.M.stats.total > 0 ? (this.M.stats.mapped / this.M.stats.total * 100).toFixed(1) : '0.0';
                const bytePct = totalBytes > 0 ? (bytesProc / totalBytes * 100) : 0;
                
                // Calculate ETA
                const elapsed = (now - startTime) / 1000; // seconds
                let etaStr = '';
                if (bytePct > 1 && elapsed > 2) {
                    const remaining = elapsed * (100 - bytePct) / bytePct;
                    if (remaining < 60) {
                        etaStr = ` | ETA: ${Math.round(remaining)}s`;
                    } else if (remaining < 3600) {
                        etaStr = ` | ETA: ${Math.round(remaining / 60)}m ${Math.round(remaining % 60)}s`;
                    } else {
                        etaStr = ` | ETA: ${Math.round(remaining / 3600)}h ${Math.round((remaining % 3600) / 60)}m`;
                    }
                }
                
                // Calculate reads per second
                const readsPerSec = elapsed > 0 ? Math.round(this.M.stats.total / elapsed) : 0;
                const rpsStr = readsPerSec > 0 ? ` | ${readsPerSec.toLocaleString()}/s` : '';
                
                // Update progress display
                document.getElementById('prog-stats').textContent = 
                    `${this.M.stats.total.toLocaleString()} reads | ${this.M.stats.mapped.toLocaleString()} mapped (${pct}%)${rpsStr}${etaStr}`;
                document.getElementById('prog-bar').style.width = bytePct.toFixed(0) + '%';
                
                // Live plot update - more aggressive
                const shouldPlot = (now - lastPlotTime > PLOT_INTERVAL) && this.M.stats.mapped > 50;
                if (shouldPlot || force) {
                    lastPlotTime = now;
                    plotUpdateCount++;
                    
                    try {
                        // On first plot update, ensure segment dropdowns are populated and selected
                        if (plotUpdateCount <= 2) {
                            const segSelects = ['cov-seg', 'len-seg', 'bias-seg', 'ovl-seg', 'ovl-hm-seg'];
                            for (const id of segSelects) {
                                const sel = document.getElementById(id);
                                if (sel && sel.options.length <= 1 && this.M.refOrder.length > 0) {
                                    sel.innerHTML = '<option value="all">All segments</option>';
                                    for (const seg of this.M.refOrder) {
                                        sel.innerHTML += `<option value="${seg}">${seg}</option>`;
                                    }
                                }
                                // Select first segment for coverage/bias
                                if ((id === 'cov-seg' || id === 'bias-seg') && sel && this.M.refOrder.length > 0) {
                                    if (!sel.value || sel.value === 'all') {
                                        sel.value = this.M.refOrder[0];
                                    }
                                }
                            }
                        }
                        
                        // Aggregate and draw
                        this.aggReps();
                        this.updateStats();
                        this.drawCov();
                        this.drawLen();
                        this.drawHist('5');
                        this.drawHist('3');
                        
                    } catch (e) { 
                        console.log('Live plot update error (non-fatal):', e.message, e.stack);
                    }
                }
                
                // Yield to UI - give browser time to render
                await new Promise(r => setTimeout(r, 5));
            };
            
            // Helper to submit batch to workers
            const submitBatch = () => {
                if (readBatch.length === 0) return;
                if (workerPool) {
                    workerPool.submitBatch([...readBatch], batchId++);
                    pendingBatches++;
                } else {
                    // Single-threaded fallback
                    for (const seq of readBatch) {
                        this.M.stats.total++; rep.stats.total++; readsInFile++;
                        const m = this.M.mapRead(seq);
                        if (m) {
                            if (Array.isArray(m)) {
                                this.M.stats.mapped++; rep.stats.mapped++;
                                for (const hit of m) this.M.addMap(hit, rep, lowMemMode);
                            } else {
                                this.M.stats.mapped++; rep.stats.mapped++;
                                this.M.addMap(m, rep, lowMemMode);
                            }
                        }
                    }
                }
                readBatch = [];
            };
            
            // Helper to wait for all pending batches
            const waitForBatches = async () => {
                while (pendingBatches > 0) {
                    await new Promise(r => setTimeout(r, 10));
                    processBatchResults();
                }
                processBatchResults();
            };
            
            try {
                if (isGzip) {
                    // Use fflate streaming decompression for better performance
                    if (typeof fflate !== 'undefined') {
                        document.getElementById('prog-status').textContent = `Replicate ${fi + 1}/${this.files.length}: ${file.name} (streaming decompress)`;
                        
                        // Use streaming decompression for large files
                        const CHUNK_SIZE = 512 * 1024; // 512KB chunks for reading
                        let textDecoder = new TextDecoder();
                        let pendingText = '';
                        let readsBuffer = [];
                        let processingComplete = false;
                        
                        // Create streaming gunzip decompressor
                        const gunzip = new fflate.Gunzip((chunk, final) => {
                            // Decode decompressed chunk to text
                            const text = textDecoder.decode(chunk, { stream: !final });
                            pendingText += text;
                            
                            // Process complete lines as they come in
                            const lines = pendingText.split('\n');
                            // Keep the last incomplete line
                            pendingText = lines.pop() || '';
                            
                            // Parse reads from complete lines
                            if (isFasta) {
                                // FASTA parsing: collect sequences
                                for (let i = 0; i < lines.length; i++) {
                                    const line = lines[i].trim();
                                    if (line.startsWith('>')) {
                                        // Header line - if we have a pending sequence, push it
                                        if (readsBuffer.length > 0 && readsBuffer[readsBuffer.length - 1].seq) {
                                            // The last item has a sequence, process it
                                        }
                                        readsBuffer.push({ header: line, seq: '' });
                                    } else if (line && readsBuffer.length > 0) {
                                        // Sequence line
                                        readsBuffer[readsBuffer.length - 1].seq += line.toUpperCase();
                                    }
                                }
                            } else {
                                // FASTQ parsing: every 4 lines is one read (id, seq, +, qual)
                                let lineBuffer = readsBuffer.lineBuffer || [];
                                for (const line of lines) {
                                    lineBuffer.push(line);
                                    if (lineBuffer.length === 4) {
                                        const seq = lineBuffer[1].trim().toUpperCase();
                                        if (seq.length > 0 && !seq.includes('N')) {
                                            readsBuffer.push(seq);
                                        }
                                        lineBuffer = [];
                                    }
                                }
                                readsBuffer.lineBuffer = lineBuffer;
                            }
                            
                            if (final) processingComplete = true;
                        });
                        
                        // Read and decompress in chunks
                        const arrayBuffer = await file.arrayBuffer();
                        const compressedData = new Uint8Array(arrayBuffer);
                        const totalSize = compressedData.length;
                        let offset = 0;
                        
                        while (offset < totalSize) {
                            if (this.M.stop) break;
                            
                            const chunkEnd = Math.min(offset + CHUNK_SIZE, totalSize);
                            const chunk = compressedData.subarray(offset, chunkEnd);
                            const isFinal = chunkEnd >= totalSize;
                            
                            gunzip.push(chunk, isFinal);
                            
                            // Process accumulated reads
                            while (readsBuffer.length > 100 || (processingComplete && readsBuffer.length > 0)) {
                                if (this.M.stop) break;
                                if (maxReads > 0 && readsInFile >= maxReads) break;
                                
                                const item = readsBuffer.shift();
                                if (!item) break;
                                
                                // Skip lineBuffer property
                                if (typeof item === 'object' && item.lineBuffer !== undefined) continue;
                                
                                const seq = isFasta ? (item.seq || '') : item;
                                if (!seq || seq.length === 0) continue;
                                
                                readBatch.push(seq);
                                this.M.trackLibRead(seq, rep);
                                readsInFile++;
                                
                                if (readBatch.length >= BATCH_SIZE) {
                                    submitBatch();
                                    processBatchResults();
                                }
                                
                                if (readsInFile % 10000 === 0) {
                                    await updateProgress();
                                }
                            }
                            
                            offset = chunkEnd;
                            
                            // Update progress
                            const pct = (offset / totalSize * 100).toFixed(0);
                            document.getElementById('prog-bar').style.width = (bytesProc / totalBytes * 100 + parseFloat(pct) * (file.size / totalBytes)).toFixed(1) + '%';
                            document.getElementById('prog-status').textContent = `Replicate ${fi + 1}/${this.files.length}: ${file.name} (${pct}% - ${(readsInFile / 1000).toFixed(0)}k reads)`;
                            
                            await new Promise(r => setTimeout(r, 0)); // Allow UI update
                        }
                        
                        // Process any remaining reads
                        while (readsBuffer.length > 0) {
                            if (this.M.stop) break;
                            if (maxReads > 0 && readsInFile >= maxReads) break;
                            
                            const item = readsBuffer.shift();
                            if (!item || (typeof item === 'object' && item.lineBuffer !== undefined)) continue;
                            
                            const seq = isFasta ? (item.seq || '') : item;
                            if (!seq || seq.length === 0) continue;
                            
                            readBatch.push(seq);
                            this.M.trackLibRead(seq, rep);
                            readsInFile++;
                            
                            if (readBatch.length >= BATCH_SIZE) {
                                submitBatch();
                                processBatchResults();
                            }
                        }
                        
                        bytesProc += file.size;
                        document.getElementById('prog-bar').style.width = (bytesProc / totalBytes * 100).toFixed(1) + '%';
                        
                        submitBatch();
                        await waitForBatches();
                    } else if (typeof DecompressionStream !== 'undefined') {
                        // Fallback to native DecompressionStream if fflate not available
                        document.getElementById('prog-status').textContent = `Replicate ${fi + 1}/${this.files.length}: ${file.name} (browser fallback)`;
                        const ds = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(ds);
                        const reader = decompressedStream.getReader();
                        const decoder = new TextDecoder();
                        
                        let leftover = '';
                        let done = false;
                        let decompressedBytes = 0;
                        let lastProgressUpdate = 0;
                        
                        while (!done && !this.M.stop) {
                            if (maxReads > 0 && readsInFile >= maxReads) break;
                            
                            const { value, done: streamDone } = await reader.read();
                            done = streamDone;
                            
                            if (value) {
                                const chunkText = leftover + decoder.decode(value, { stream: !done });
                                const splitCh = isFasta ? '\n>' : '\n@';
                                const lastSplit = chunkText.lastIndexOf(splitCh);
                                
                                // Track decompressed bytes for smoother progress
                                decompressedBytes += value.length;
                                
                                let proc;
                                if (lastSplit !== -1) {
                                    proc = chunkText.slice(0, lastSplit + 1);
                                    leftover = chunkText.slice(lastSplit + 1);
                                } else if (done) {
                                    proc = chunkText;
                                    leftover = '';
                                } else {
                                    leftover = chunkText;
                                    continue;
                                }
                                
                                const parser = isFasta ? this.M.parseFA2(proc) : this.M.parseFQ(proc);
                                for (const seq of parser) {
                                    if (this.M.stop) break;
                                    if (maxReads > 0 && readsInFile >= maxReads) break;
                                    
                                    readBatch.push(seq);
                                    this.M.trackLibRead(seq, rep); // Track library-wide length distribution
                                    readsInFile++;
                                    
                                    if (readBatch.length >= BATCH_SIZE) {
                                        submitBatch();
                                        // Process any completed results
                                        processBatchResults();
                                    }
                                }
                                
                                // Update progress more frequently (every 500 reads or every chunk)
                                if (readsInFile % 500 === 0) {
                                    await updateProgress();
                                }
                            }
                        }
                        
                        // Submit remaining reads
                        submitBatch();
                        
                        // Cancel the stream if we hit max reads
                        if (maxReads > 0 && readsInFile >= maxReads) {
                            try { await reader.cancel(); } catch(e) {}
                        }
                        
                        // Process leftover
                        if (leftover && !this.M.stop && !(maxReads > 0 && readsInFile >= maxReads)) {
                            const parser = isFasta ? this.M.parseFA2(leftover) : this.M.parseFQ(leftover);
                            for (const seq of parser) {
                                if (maxReads > 0 && readsInFile >= maxReads) break;
                                readBatch.push(seq);
                                this.M.trackLibRead(seq, rep); // Track library-wide length distribution
                                readsInFile++;
                            }
                            submitBatch();
                        }
                        
                        // Wait for all batches to complete
                        await waitForBatches();
                        
                        bytesProc += file.size;
                        document.getElementById('prog-bar').style.width = (bytesProc / totalBytes * 100).toFixed(1) + '%';
                    } else {
                        document.getElementById('prog-status').textContent = `Error: No gzip support available`;
                        continue;
                    }
                } else {
                    // Stream uncompressed file in chunks
                    let offset = 0, leftover = '';
                    while (offset < file.size && !this.M.stop) {
                        if (maxReads > 0 && readsInFile >= maxReads) break;
                        const chunk = file.slice(offset, offset + CHUNK);
                        const chunkText = leftover + await chunk.text();
                        const splitCh = isFasta ? '\n>' : '\n@';
                        const lastSplit = chunkText.lastIndexOf(splitCh);
                        const isLastChunk = (offset + CHUNK >= file.size);
                        
                        let proc;
                        if (lastSplit !== -1) {
                            proc = chunkText.slice(0, lastSplit + 1);
                            leftover = chunkText.slice(lastSplit + 1);
                        } else if (isLastChunk) {
                            proc = chunkText;
                            leftover = '';
                        } else {
                            leftover = chunkText;
                            offset += CHUNK;
                            bytesProc = Math.min(bytesProc + CHUNK, totalBytes);
                            continue;
                        }
                        
                        const parser = isFasta ? this.M.parseFA2(proc) : this.M.parseFQ(proc);
                        for (const seq of parser) {
                            if (maxReads > 0 && readsInFile >= maxReads) break;
                            
                            readBatch.push(seq);
                            this.M.trackLibRead(seq, rep); // Track library-wide length distribution
                            readsInFile++;
                            
                            if (readBatch.length >= BATCH_SIZE) {
                                submitBatch();
                                processBatchResults();
                            }
                        }
                        
                        offset += CHUNK;
                        bytesProc = Math.min(bytesProc + CHUNK, totalBytes);
                        await updateProgress(true); // Force update with plots
                    }
                    
                    // Process remaining
                    if (leftover && !this.M.stop && !(maxReads > 0 && readsInFile >= maxReads)) {
                        const parser = isFasta ? this.M.parseFA2(leftover) : this.M.parseFQ(leftover);
                        for (const seq of parser) {
                            if (maxReads > 0 && readsInFile >= maxReads) break;
                            readBatch.push(seq);
                            this.M.trackLibRead(seq, rep); // Track library-wide length distribution
                            readsInFile++;
                        }
                    }
                    submitBatch();
                    await waitForBatches();
                }
            } catch (err) {
                console.error('Error processing file:', file.name, err);
                document.getElementById('prog-status').textContent = `Error processing ${file.name}: ${err.message}`;
            }
            this.M.replicates.push(rep);
        }
        
        // Cleanup workers
        if (workerPool) {
            workerPool.terminate();
        }
        
        this.finish();
    }

    finish() {
        this.M.running = false;
        document.getElementById('run-btn').disabled = false;
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('prog-status').textContent = 'Calculating signatures...';
        this.recalcOverlap();
        this.aggReps();
        this.updateStats();
        this.redraw();
        document.getElementById('prog-status').textContent = this.M.stop ? 'Stopped' : 'Complete';
        document.getElementById('prog-bar').style.width = '100%';
        
        // Save to cache if enabled
        if (document.getElementById('cache-enabled')?.checked && !this.M.stop) {
            this.saveToCache();
        }
    }
    
    // Initialize cache and update UI
    async initCache() {
        try {
            await resultsCache.init();
            await this.updateCacheUI();
        } catch (err) {
            console.warn('IndexedDB not available:', err);
            document.getElementById('cache-info').textContent = 'Cache: not available';
        }
    }
    
    // ========== Recent References Management ==========
    
    refreshRecentRefs() {
        try {
            const refs = JSON.parse(localStorage.getItem('sRNAMap_recentRefs') || '[]');
            const select = document.getElementById('recent-refs');
            select.innerHTML = '<option value="">-- Select saved reference (' + refs.length + ') --</option>';
            
            for (const ref of refs) {
                const option = document.createElement('option');
                option.value = ref.id;
                const segCount = (ref.content.match(/>/g) || []).length;
                const totalLen = ref.content.replace(/>[^\n]+\n/g, '').replace(/\s/g, '').length;
                option.textContent = `${ref.name} (${segCount} seg, ${totalLen.toLocaleString()} nt)`;
                select.appendChild(option);
            }
        } catch (err) {
            console.warn('Error loading recent refs:', err);
        }
    }
    
    saveReference() {
        const refText = document.getElementById('ref-text').value.trim();
        if (!refText || !refText.includes('>')) {
            alert('No reference loaded. Please upload or paste a reference first.');
            return;
        }
        
        const defaultName = Object.keys(this.M.refs || {}).join(', ') || 'Reference';
        const name = prompt('Name for this reference:', defaultName);
        if (!name) return;
        
        try {
            const refs = JSON.parse(localStorage.getItem('sRNAMap_recentRefs') || '[]');
            
            // Check if name already exists
            const existingIdx = refs.findIndex(r => r.name === name);
            if (existingIdx >= 0) {
                if (!confirm(`Reference "${name}" already exists. Overwrite?`)) return;
                refs.splice(existingIdx, 1);
            }
            
            // Add new reference at the beginning
            refs.unshift({
                id: Date.now().toString(),
                name: name,
                content: refText,
                timestamp: Date.now()
            });
            
            // Keep only the last 10 references
            if (refs.length > 10) refs.length = 10;
            
            localStorage.setItem('sRNAMap_recentRefs', JSON.stringify(refs));
            this.refreshRecentRefs();
            alert(`Reference "${name}" saved!`);
        } catch (err) {
            console.error('Error saving reference:', err);
            alert('Error saving reference: ' + err.message);
        }
    }
    
    loadReference(id) {
        if (!id) return;
        
        try {
            const refs = JSON.parse(localStorage.getItem('sRNAMap_recentRefs') || '[]');
            const ref = refs.find(r => r.id === id);
            if (!ref) {
                alert('Reference not found');
                return;
            }
            
            document.getElementById('ref-text').value = ref.content;
            this.procRef();
            document.getElementById('ref-info').textContent = `Loaded: ${ref.name}`;
        } catch (err) {
            console.error('Error loading reference:', err);
            alert('Error loading reference: ' + err.message);
        }
    }
    
    deleteReference() {
        const select = document.getElementById('recent-refs');
        const id = select.value;
        if (!id) {
            alert('Please select a reference to delete');
            return;
        }
        
        const selectedOption = select.options[select.selectedIndex];
        if (!confirm(`Delete reference "${selectedOption.textContent}"?`)) return;
        
        try {
            const refs = JSON.parse(localStorage.getItem('sRNAMap_recentRefs') || '[]');
            const newRefs = refs.filter(r => r.id !== id);
            localStorage.setItem('sRNAMap_recentRefs', JSON.stringify(newRefs));
            this.refreshRecentRefs();
        } catch (err) {
            console.error('Error deleting reference:', err);
            alert('Error deleting reference: ' + err.message);
        }
    }
    
    // Update cache dropdown and info
    async updateCacheUI() {
        try {
            const results = await resultsCache.listResults();
            const select = document.getElementById('cache-select');
            select.innerHTML = '<option value="">-- Select saved analysis (' + results.length + ' cached) --</option>';
            
            // Sort by timestamp descending
            results.sort((a, b) => b.timestamp - a.timestamp);
            
            for (const r of results) {
                const date = new Date(r.timestamp).toLocaleString();
                const stats = r.stats ? ` (${r.stats.mapped.toLocaleString()} mapped)` : '';
                const option = document.createElement('option');
                option.value = r.id;
                option.textContent = r.name + stats + ' - ' + date;
                select.appendChild(option);
            }
            
            // Update cache size
            const size = await resultsCache.getCacheSize();
            const sizeMB = (size / 1024 / 1024).toFixed(1);
            document.getElementById('cache-info').textContent = 'Cache: ' + results.length + ' analyses, ~' + sizeMB + ' MB';
        } catch (err) {
            console.warn('Error updating cache UI:', err);
        }
    }
    
    // Save current results to cache
    async saveToCache() {
        if (!this.M.replicates.length) return;
        
        try {
            document.getElementById('prog-status').textContent = 'Saving to cache...';
            
            // Generate cache key
            this.cacheKey = await resultsCache.generateCacheKey(this.files, this.M.refs, this.M.settings);
            
            // Use experiment name if provided, otherwise use filenames
            const expName = document.getElementById('experiment-name')?.value?.trim();
            const name = expName || this.files.map(f => f.name.replace(/\.(fastq|fq|fasta|fa)(\.gz)?$/i, '')).join(', ');
            
            // Prepare replicates for caching - strip large mappedReads, keep counts
            const cacheReplicates = this.M.replicates.map(rep => {
                // Compute segment counts from mappedReads if not already done
                const segCounts = {};
                if (rep.mappedReads) {
                    for (const seg of this.M.refOrder) {
                        segCounts[seg] = rep.mappedReads[seg]?.length || 0;
                    }
                }
                // Return replicate without mappedReads to save space
                return {
                    name: rep.name,
                    stats: rep.stats,
                    covFwd: rep.covFwd,
                    covRev: rep.covRev,
                    cov5Fwd: rep.cov5Fwd,
                    cov5Rev: rep.cov5Rev,
                    lenDist5: rep.lenDist5,
                    lenDist3: rep.lenDist3,
                    lenDistBySeg: rep.lenDistBySeg,
                    bias: rep.bias,
                    biasBySeg: rep.biasBySeg,
                    segCounts: segCounts
                    // mappedReads intentionally omitted - too large
                };
            });
            
            // Prepare data - include overlap data so we don't need to recalculate
            const data = {
                refs: this.M.refs,
                refOrder: this.M.refOrder,
                settings: this.M.settings,
                stats: this.M.stats,
                covFwd: this.M.covFwd,
                covRev: this.M.covRev,
                cov5Fwd: this.M.cov5Fwd,
                cov5Rev: this.M.cov5Rev,
                replicates: cacheReplicates,
                // Save pre-calculated overlap data
                ovlData: this.ovlData,
                ovlSettings: this.ovlSettings
            };
            
            await resultsCache.saveResults(this.cacheKey, name, data);
            await this.updateCacheUI();
            
            document.getElementById('prog-status').textContent = 'Complete (cached)';
        } catch (err) {
            console.error('Error saving to cache:', err);
            document.getElementById('prog-status').textContent = 'Complete (cache failed)';
        }
    }
    
    // Load results from cache
    async loadFromCache() {
        const select = document.getElementById('cache-select');
        const cacheKey = select.value;
        if (!cacheKey) {
            alert('Please select a cached analysis to load');
            return;
        }
        
        try {
            document.getElementById('prog-status').textContent = 'Loading from cache...';
            document.getElementById('progress').classList.add('show');
            document.getElementById('prog-bar').style.width = '50%';
            
            const data = await resultsCache.loadResults(cacheKey);
            if (!data) {
                alert('Cache entry not found');
                return;
            }
            
            // Restore reference sequences to Mapper
            this.M.refs = data.refs;
            this.M.refOrder = data.refOrder;
            
            // Rebuild reference text for display
            let refText = '';
            for (const seg of data.refOrder) {
                refText += '>' + seg + '\n' + data.refs[seg] + '\n';
            }
            document.getElementById('ref-text').value = refText;
            document.getElementById('ref-info').textContent = data.refOrder.length + ' segment(s) loaded from cache';
            
            // Ensure coverage objects exist
            if (!data.covFwd) data.covFwd = {};
            if (!data.covRev) data.covRev = {};
            if (!data.cov5Fwd) data.cov5Fwd = {};
            if (!data.cov5Rev) data.cov5Rev = {};
            
            // Initialize coverage arrays for each segment
            for (const seg of data.refOrder) {
                const len = data.refs[seg].length;
                // Create arrays if missing
                if (!data.covFwd[seg]) data.covFwd[seg] = new Uint32Array(len);
                if (!data.covRev[seg]) data.covRev[seg] = new Uint32Array(len);
                if (!data.cov5Fwd[seg]) data.cov5Fwd[seg] = new Uint32Array(len);
                if (!data.cov5Rev[seg]) data.cov5Rev[seg] = new Uint32Array(len);
            }
            
            // Initialize replicate coverage arrays and bias structures
            if (data.replicates) {
                const { minLen, maxLen } = data.settings || { minLen: 18, maxLen: 30 };
                for (const rep of data.replicates) {
                    // Coverage arrays
                    if (!rep.covFwd) rep.covFwd = {};
                    if (!rep.covRev) rep.covRev = {};
                    if (!rep.cov5Fwd) rep.cov5Fwd = {};
                    if (!rep.cov5Rev) rep.cov5Rev = {};
                    
                    // Stats
                    if (!rep.stats) rep.stats = { total: 0, mapped: 0, multiMapped: 0 };
                    
                    // Bias structures - ensure they exist
                    if (!rep.bias) {
                        rep.bias = { fwd5: [], fwd3: [], rev5: [], rev3: [] };
                        for (let i = 0; i < 20; i++) {
                            rep.bias.fwd5[i] = { A: 0, C: 0, G: 0, T: 0 };
                            rep.bias.fwd3[i] = { A: 0, C: 0, G: 0, T: 0 };
                            rep.bias.rev5[i] = { A: 0, C: 0, G: 0, T: 0 };
                            rep.bias.rev3[i] = { A: 0, C: 0, G: 0, T: 0 };
                        }
                    }
                    
                    // Length distribution structures
                    if (!rep.lenDist5) {
                        rep.lenDist5 = { fwd: {}, rev: {} };
                        for (let l = minLen; l <= maxLen; l++) {
                            rep.lenDist5.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                            rep.lenDist5.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
                        }
                    }
                    if (!rep.lenDist3) {
                        rep.lenDist3 = { fwd: {}, rev: {} };
                        for (let l = minLen; l <= maxLen; l++) {
                            rep.lenDist3.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                            rep.lenDist3.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
                        }
                    }
                    
                    // Per-segment structures
                    if (!rep.biasBySeg) rep.biasBySeg = {};
                    if (!rep.lenDistBySeg) rep.lenDistBySeg = {};
                    if (!rep.mappedReads) rep.mappedReads = {};
                    if (!rep.multiMapCounts) rep.multiMapCounts = {};
                    
                    for (const seg of data.refOrder) {
                        const len = data.refs[seg].length;
                        if (!rep.covFwd[seg]) rep.covFwd[seg] = new Uint32Array(len);
                        if (!rep.covRev[seg]) rep.covRev[seg] = new Uint32Array(len);
                        if (!rep.cov5Fwd[seg]) rep.cov5Fwd[seg] = new Uint32Array(len);
                        if (!rep.cov5Rev[seg]) rep.cov5Rev[seg] = new Uint32Array(len);
                        if (!rep.mappedReads[seg]) rep.mappedReads[seg] = [];
                        if (!rep.multiMapCounts[seg]) rep.multiMapCounts[seg] = 0;
                        
                        // Per-segment bias
                        if (!rep.biasBySeg[seg]) {
                            rep.biasBySeg[seg] = { fwd5: [], fwd3: [], rev5: [], rev3: [] };
                            for (let i = 0; i < 20; i++) {
                                rep.biasBySeg[seg].fwd5[i] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.biasBySeg[seg].fwd3[i] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.biasBySeg[seg].rev5[i] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.biasBySeg[seg].rev3[i] = { A: 0, C: 0, G: 0, T: 0 };
                            }
                        }
                        
                        // Per-segment length distribution
                        if (!rep.lenDistBySeg[seg]) {
                            rep.lenDistBySeg[seg] = {
                                len5: { fwd: {}, rev: {} },
                                len3: { fwd: {}, rev: {} }
                            };
                            for (let l = minLen; l <= maxLen; l++) {
                                rep.lenDistBySeg[seg].len5.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.lenDistBySeg[seg].len5.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.lenDistBySeg[seg].len3.fwd[l] = { A: 0, C: 0, G: 0, T: 0 };
                                rep.lenDistBySeg[seg].len3.rev[l] = { A: 0, C: 0, G: 0, T: 0 };
                            }
                        }
                    }
                }
            }
            
            // Restore Mapper state
            this.M.settings = data.settings || this.M.settings;
            this.M.stats = data.stats || { total: 0, mapped: 0 };
            
            // Restore global coverage arrays (convert from plain arrays to typed arrays if needed)
            this.M.covFwd = {};
            this.M.covRev = {};
            this.M.cov5Fwd = {};
            this.M.cov5Rev = {};
            for (const seg of data.refOrder) {
                if (data.covFwd && data.covFwd[seg]) {
                    this.M.covFwd[seg] = new Uint32Array(data.covFwd[seg]);
                }
                if (data.covRev && data.covRev[seg]) {
                    this.M.covRev[seg] = new Uint32Array(data.covRev[seg]);
                }
                if (data.cov5Fwd && data.cov5Fwd[seg]) {
                    this.M.cov5Fwd[seg] = new Uint32Array(data.cov5Fwd[seg]);
                }
                if (data.cov5Rev && data.cov5Rev[seg]) {
                    this.M.cov5Rev[seg] = new Uint32Array(data.cov5Rev[seg]);
                }
            }
            
            // Restore replicates with proper typed array conversion
            this.M.replicates = (data.replicates || []).map(rep => {
                const restored = { ...rep };
                restored.covFwd = {};
                restored.covRev = {};
                restored.cov5Fwd = {};
                restored.cov5Rev = {};
                // Convert coverage arrays back to typed arrays
                for (const seg of data.refOrder) {
                    if (rep.covFwd && rep.covFwd[seg]) {
                        restored.covFwd[seg] = new Uint32Array(rep.covFwd[seg]);
                    }
                    if (rep.covRev && rep.covRev[seg]) {
                        restored.covRev[seg] = new Uint32Array(rep.covRev[seg]);
                    }
                    if (rep.cov5Fwd && rep.cov5Fwd[seg]) {
                        restored.cov5Fwd[seg] = new Uint32Array(rep.cov5Fwd[seg]);
                    }
                    if (rep.cov5Rev && rep.cov5Rev[seg]) {
                        restored.cov5Rev[seg] = new Uint32Array(rep.cov5Rev[seg]);
                    }
                }
                // Ensure bias data is properly preserved (deep copy from cache)
                if (rep.bias) {
                    restored.bias = JSON.parse(JSON.stringify(rep.bias));
                }
                if (rep.biasBySeg) {
                    restored.biasBySeg = JSON.parse(JSON.stringify(rep.biasBySeg));
                }
                // Ensure length distribution data is properly preserved
                if (rep.lenDist5) {
                    restored.lenDist5 = JSON.parse(JSON.stringify(rep.lenDist5));
                }
                if (rep.lenDist3) {
                    restored.lenDist3 = JSON.parse(JSON.stringify(rep.lenDist3));
                }
                if (rep.lenDistBySeg) {
                    restored.lenDistBySeg = JSON.parse(JSON.stringify(rep.lenDistBySeg));
                }
                // Ensure mappedReads structure exists (may be empty from cache)
                if (!restored.mappedReads) restored.mappedReads = {};
                for (const seg of data.refOrder) {
                    if (!restored.mappedReads[seg]) restored.mappedReads[seg] = [];
                }
                return restored;
            });
            this.cacheKey = cacheKey;
            
            // Rebuild k-mer index (needed for overlap calculations)
            this.M.buildIdx();
            
            // Update UI settings from cached settings
            if (data.settings) {
                if (data.settings.kmer) document.getElementById('kmer').value = data.settings.kmer;
                if (data.settings.seeds) document.getElementById('seeds').value = data.settings.seeds;
                if (data.settings.mm) document.getElementById('mismatch').value = data.settings.mm;
                if (data.settings.minLen) document.getElementById('minlen').value = data.settings.minLen;
                if (data.settings.maxLen) document.getElementById('maxlen').value = data.settings.maxLen;
            }
            
            // Update UI
            document.getElementById('prog-bar').style.width = '80%';
            
            // Update segment dropdowns - select first segment for coverage/bias (they need specific segment)
            const segSelects = ['cov-seg', 'len-seg', 'bias-seg', 'ovl-seg', 'ovl-hm-seg'];
            for (const id of segSelects) {
                const sel = document.getElementById(id);
                if (sel) {
                    sel.innerHTML = '<option value="all">All segments</option>';
                    for (const seg of data.refOrder) {
                        sel.innerHTML += '<option value="' + seg + '">' + seg + '</option>';
                    }
                    // Coverage and bias plots need a specific segment selected
                    if ((id === 'cov-seg' || id === 'bias-seg') && data.refOrder.length > 0) {
                        sel.value = data.refOrder[0];
                    }
                }
            }
            
            // Restore overlap data if available, otherwise skip recalculation
            if (data.ovlData) {
                this.ovlData = data.ovlData;
                this.ovlSettings = data.ovlSettings || {};
            } else {
                // No overlap data cached - initialize empty
                this.ovlData = {};
                this.ovlSettings = {};
            }
            
            // Aggregate and redraw
            this.aggReps();
            this.updateStats();
            this.redraw();
            
            document.getElementById('results').classList.add('show');
            document.getElementById('prog-bar').style.width = '100%';
            document.getElementById('prog-status').textContent = 'Loaded from cache';
            document.getElementById('prog-stats').textContent = (data.stats?.total || 0).toLocaleString() + ' reads | ' + (data.stats?.mapped || 0).toLocaleString() + ' mapped';
            
        } catch (err) {
            console.error('Error loading from cache:', err);
            alert('Error loading cached results: ' + err.message);
            document.getElementById('prog-status').textContent = 'Load failed';
        }
    }
    
    // Delete selected cache entry
    async deleteFromCache() {
        const select = document.getElementById('cache-select');
        const cacheKey = select.value;
        if (!cacheKey) {
            alert('Please select a cached analysis to delete');
            return;
        }
        
        if (!confirm('Delete this cached analysis?')) return;
        
        try {
            await resultsCache.deleteResult(cacheKey);
            await this.updateCacheUI();
        } catch (err) {
            console.error('Error deleting from cache:', err);
            alert('Error deleting: ' + err.message);
        }
    }
    
    // Clear all cache
    async clearCache() {
        if (!confirm('Delete ALL cached analyses? This cannot be undone.')) return;
        
        try {
            await resultsCache.clearAll();
            await this.updateCacheUI();
        } catch (err) {
            console.error('Error clearing cache:', err);
            alert('Error clearing cache: ' + err.message);
        }
    }
    
    // Import results from JSON file
    async importJSON(file) {
        if (!file) return;
        
        try {
            document.getElementById('prog-status').textContent = 'Importing JSON...';
            document.getElementById('progress').classList.add('show');
            document.getElementById('prog-bar').style.width = '30%';
            
            const text = await file.text();
            const data = JSON.parse(text);
            
            // Check if this is a stats-only export (has 'version' and 'overlap' but no 'refs')
            if (data.version && data.overlap && !data.refs) {
                // Stats-only import
                await this.importStatsJSON(data);
                return;
            }
            
            if (!data.refs || !data.refOrder || !data.replicates) {
                alert('Invalid JSON format. Expected sRNAMap export file with refs, refOrder, and replicates.');
                return;
            }
            
            document.getElementById('prog-bar').style.width = '50%';
            
            // Restore reference sequences
            this.M.refs = data.refs;
            this.M.refOrder = data.refOrder;
            
            // Rebuild reference text for display
            let refText = '';
            for (const seg of data.refOrder) {
                refText += '>' + seg + '\n' + data.refs[seg] + '\n';
            }
            document.getElementById('ref-text').value = refText;
            document.getElementById('ref-info').textContent = data.refOrder.length + ' segment(s) imported from JSON';
            
            // Initialize coverage arrays
            for (const seg of data.refOrder) {
                const len = data.refs[seg].length;
                this.M.covFwd[seg] = new Uint32Array(len);
                this.M.covRev[seg] = new Uint32Array(len);
                this.M.cov5Fwd[seg] = new Uint32Array(len);
                this.M.cov5Rev[seg] = new Uint32Array(len);
            }
            
            // Restore coverage data if present
            if (data.covFwd) {
                for (const seg of data.refOrder) {
                    if (data.covFwd[seg]) this.M.covFwd[seg] = new Uint32Array(data.covFwd[seg]);
                    if (data.covRev[seg]) this.M.covRev[seg] = new Uint32Array(data.covRev[seg]);
                    if (data.cov5Fwd && data.cov5Fwd[seg]) this.M.cov5Fwd[seg] = new Uint32Array(data.cov5Fwd[seg]);
                    if (data.cov5Rev && data.cov5Rev[seg]) this.M.cov5Rev[seg] = new Uint32Array(data.cov5Rev[seg]);
                }
            }
            
            // Restore settings
            if (data.settings) {
                this.M.settings = data.settings;
                if (data.settings.kmer) document.getElementById('kmer').value = data.settings.kmer;
                if (data.settings.seeds) document.getElementById('seeds').value = data.settings.seeds;
                if (data.settings.mm) document.getElementById('mismatch').value = data.settings.mm;
                if (data.settings.minLen) document.getElementById('minlen').value = data.settings.minLen;
                if (data.settings.maxLen) document.getElementById('maxlen').value = data.settings.maxLen;
            }
            
            // Restore stats
            if (data.stats) this.M.stats = data.stats;
            
            // Restore replicates
            this.M.replicates = data.replicates.map(rep => {
                const restored = { ...rep };
                // Convert coverage arrays back to Uint32Array
                for (const seg of data.refOrder) {
                    if (rep.covFwd && rep.covFwd[seg]) restored.covFwd[seg] = new Uint32Array(rep.covFwd[seg]);
                    if (rep.covRev && rep.covRev[seg]) restored.covRev[seg] = new Uint32Array(rep.covRev[seg]);
                    if (rep.cov5Fwd && rep.cov5Fwd[seg]) restored.cov5Fwd[seg] = new Uint32Array(rep.cov5Fwd[seg]);
                    if (rep.cov5Rev && rep.cov5Rev[seg]) restored.cov5Rev[seg] = new Uint32Array(rep.cov5Rev[seg]);
                }
                return restored;
            });
            
            document.getElementById('prog-bar').style.width = '70%';
            
            // Rebuild k-mer index
            this.M.buildIdx();
            
            // Update segment dropdowns
            const segSelects = ['cov-seg', 'len-seg', 'bias-seg', 'ovl-seg'];
            for (const id of segSelects) {
                const sel = document.getElementById(id);
                if (sel) {
                    sel.innerHTML = '<option value="all">All segments</option>';
                    for (const seg of data.refOrder) {
                        sel.innerHTML += '<option value="' + seg + '">' + seg + '</option>';
                    }
                }
            }
            
            // Set experiment name if available
            if (data.name) {
                document.getElementById('experiment-name').value = data.name;
            }
            
            document.getElementById('prog-bar').style.width = '90%';
            
            // Restore overlap data if present (skip recalculation)
            if (data.overlap && Object.keys(data.overlap).length > 0) {
                this.ovlData = data.overlap;
                if (data.ovlSettings) {
                    this.ovlSettings = data.ovlSettings;
                    // Update UI with these settings
                    if (this.ovlSettings.qmin) document.getElementById('ovl-qmin').value = this.ovlSettings.qmin;
                    if (this.ovlSettings.qmax) document.getElementById('ovl-qmax').value = this.ovlSettings.qmax;
                    if (this.ovlSettings.tmin) document.getElementById('ovl-tmin').value = this.ovlSettings.tmin;
                    if (this.ovlSettings.tmax) document.getElementById('ovl-tmax').value = this.ovlSettings.tmax;
                    if (this.ovlSettings.omin) document.getElementById('ovl-omin').value = this.ovlSettings.omin;
                    if (this.ovlSettings.omax) document.getElementById('ovl-omax').value = this.ovlSettings.omax;
                }
                if (data.ovlDataPerRep) {
                    this.ovlDataPerRep = data.ovlDataPerRep;
                }
            } else {
                // Only recalculate if not present
                this.recalcOverlap();
            }
            
            this.aggReps();
            this.updateStats();
            this.redraw();
            
            document.getElementById('results').classList.add('show');
            document.getElementById('prog-bar').style.width = '100%';
            document.getElementById('prog-status').textContent = 'Imported from JSON';
            document.getElementById('prog-stats').textContent = (data.stats?.total || 0).toLocaleString() + ' reads | ' + (data.stats?.mapped || 0).toLocaleString() + ' mapped';
            
        } catch (err) {
            console.error('Error importing JSON:', err);
            alert('Error importing JSON: ' + err.message);
            document.getElementById('prog-status').textContent = 'Import failed';
        }
    }
    
    // Import stats-only JSON (lightweight export without full read data)
    async importStatsJSON(data) {
        try {
            document.getElementById('prog-bar').style.width = '50%';
            document.getElementById('prog-status').textContent = 'Importing stats...';
            
            // Restore settings
            if (data.settings) {
                this.M.settings = { ...this.M.settings, ...data.settings };
                if (data.settings.kmer) document.getElementById('kmer').value = data.settings.kmer;
                if (data.settings.seeds) document.getElementById('seeds').value = data.settings.seeds;
                if (data.settings.mm) document.getElementById('mismatch').value = data.settings.mm;
                if (data.settings.minLen) document.getElementById('minlen').value = data.settings.minLen;
                if (data.settings.maxLen) document.getElementById('maxlen').value = data.settings.maxLen;
            }
            
            // Restore mapping stats
            if (data.mapping) {
                this.M.stats = data.mapping;
            }
            
            // Set up segments from the stats file
            if (data.segments && data.segments.length > 0) {
                // Create placeholder references (just store names and lengths)
                this.M.refOrder = data.segments.map(s => s.name);
                this.M.refs = {};
                for (const seg of data.segments) {
                    // Create placeholder sequence of correct length
                    this.M.refs[seg.name] = 'N'.repeat(seg.length);
                }
                
                // Update segment dropdowns
                const segSelects = ['cov-seg', 'len-seg', 'bias-seg', 'ovl-seg', 'ovl-hm-seg'];
                for (const id of segSelects) {
                    const sel = document.getElementById(id);
                    if (sel) {
                        sel.innerHTML = '<option value="all">All segments</option>';
                        for (const seg of this.M.refOrder) {
                            sel.innerHTML += `<option value="${seg}">${seg}</option>`;
                        }
                    }
                }
                
                document.getElementById('ref-info').textContent = data.segments.length + ' segment(s) imported from stats JSON';
            }
            
            // Set number of replicates
            const nReps = data.replicates || 1;
            // Create placeholder replicates if needed
            if (this.M.replicates.length === 0) {
                for (let i = 0; i < nReps; i++) {
                    this.M.replicates.push({
                        name: `Rep${i + 1}`,
                        stats: { total: Math.round((data.mapping?.total || 0) / nReps), mapped: Math.round((data.mapping?.mapped || 0) / nReps) },
                        mappedReads: {}
                    });
                }
            }
            
            document.getElementById('prog-bar').style.width = '70%';
            
            // Restore overlap data
            if (data.overlap) {
                this.ovlData = data.overlap;
                
                // Also restore ovlSettings from first segment's settings
                const firstSeg = Object.keys(data.overlap)[0];
                if (firstSeg && data.overlap[firstSeg]?.settings) {
                    this.ovlSettings = data.overlap[firstSeg].settings;
                    // Update UI with these settings
                    if (this.ovlSettings.qmin) document.getElementById('ovl-qmin').value = this.ovlSettings.qmin;
                    if (this.ovlSettings.qmax) document.getElementById('ovl-qmax').value = this.ovlSettings.qmax;
                    if (this.ovlSettings.tmin) document.getElementById('ovl-tmin').value = this.ovlSettings.tmin;
                    if (this.ovlSettings.tmax) document.getElementById('ovl-tmax').value = this.ovlSettings.tmax;
                    if (this.ovlSettings.omin) document.getElementById('ovl-omin').value = this.ovlSettings.omin;
                    if (this.ovlSettings.omax) document.getElementById('ovl-omax').value = this.ovlSettings.omax;
                }
            }
            
            document.getElementById('prog-bar').style.width = '90%';
            
            // Update UI to show imported data
            this.updateUI();
            this.redraw();
            
            document.getElementById('prog-bar').style.width = '100%';
            document.getElementById('prog-status').textContent = 'Stats imported successfully';
            document.getElementById('prog-stats').textContent = 
                (data.mapping?.total || 0).toLocaleString() + ' reads | ' + 
                (data.mapping?.mapped || 0).toLocaleString() + ' mapped | ' +
                'v' + (data.version || '?');
            
            // Show a note about limitations
            console.log('Stats-only import: overlap data restored. Coverage, length distribution, and bias plots require full data.');
            
        } catch (err) {
            console.error('Error importing stats JSON:', err);
            alert('Error importing stats JSON: ' + err.message);
            document.getElementById('prog-status').textContent = 'Stats import failed';
        }
    }
    
    recalcOverlap() {
        // Get overlap settings from UI
        const qmin = +document.getElementById('ovl-qmin')?.value || 23;
        const qmax = +document.getElementById('ovl-qmax')?.value || 29;
        const tmin = +document.getElementById('ovl-tmin')?.value || 23;
        const tmax = +document.getElementById('ovl-tmax')?.value || 29;
        const omin = +document.getElementById('ovl-omin')?.value || 1;
        const omax = +document.getElementById('ovl-omax')?.value || 19;
        
        this.ovlData = {};
        this.ovlDataPerRep = {}; // Store per-replicate data for export
        this.ovlSettings = { qmin, qmax, tmin, tmax, omin, omax };
        
        for (const seg of this.M.refOrder) {
            // Calculate for each replicate and store
            const allRepData = this.M.replicates.map(r => this.M.calcOverlap(r, seg, qmin, qmax, tmin, tmax, omin, omax));
            this.ovlDataPerRep[seg] = allRepData;
            
            if (this.M.replicates.length === 1) {
                this.ovlData[seg] = allRepData[0];
            } else {
                this.ovlData[seg] = this.avgOvl(allRepData.filter(x => x !== null), omin, omax);
            }
        }
        this.ovlData['all'] = this.combineSegs(omin, omax);
    }

    avgOvl(all, omin, omax) {
        if (!all.length) return null;
        
        // Get omin/omax from first result's settings or use passed values
        const firstSettings = all[0]?.settings || {};
        const actualOmin = firstSettings.omin ?? omin;
        const actualOmax = firstSettings.omax ?? omax;
        
        // Get all keys from first result (includes query lengths and 'all')
        const keys = Object.keys(all[0]?.counts || {});
        const res = { 
            counts: {}, 
            probs: {}, 
            countZscores: {},
            probZscores: {},
            zscores: {},
            // Store per-replicate raw values for error bars
            perRep: {
                counts: {},
                probs: {},
                countZscores: {},
                probZscores: {}
            },
            // Store SEM for each metric
            sem: {
                counts: {},
                probs: {},
                countZscores: {},
                probZscores: {}
            },
            settings: firstSettings,
            nReps: all.length
        };
        
        for (const key of keys) {
            res.counts[key] = {};
            res.probs[key] = {};
            res.countZscores[key] = {};
            res.probZscores[key] = {};
            res.perRep.counts[key] = {};
            res.perRep.probs[key] = {};
            res.perRep.countZscores[key] = {};
            res.perRep.probZscores[key] = {};
            res.sem.counts[key] = {};
            res.sem.probs[key] = {};
            res.sem.countZscores[key] = {};
            res.sem.probZscores[key] = {};
            
            // Iterate over overlap range (now using objects, not arrays)
            for (let o = actualOmin; o <= actualOmax; o++) {
                // Collect values from each replicate
                const countVals = all.map(r => r?.counts?.[key]?.[o] || 0);
                const probVals = all.map(r => r?.probs?.[key]?.[o] || 0);
                const countZVals = all.map(r => r?.countZscores?.[key]?.[o] || 0);
                const probZVals = all.map(r => r?.probZscores?.[key]?.[o] || 0);
                
                // Store per-replicate values
                res.perRep.counts[key][o] = countVals;
                res.perRep.probs[key][o] = probVals;
                res.perRep.countZscores[key][o] = countZVals;
                res.perRep.probZscores[key][o] = probZVals;
                
                // Calculate means for counts and probs
                res.counts[key][o] = this.mean(countVals);
                res.probs[key][o] = this.mean(probVals);
                
                // CRITICAL FIX: Mean z-scores should be AVERAGE of per-rep z-scores
                // Not the z-score of the averaged value!
                res.countZscores[key][o] = this.mean(countZVals);
                res.probZscores[key][o] = this.mean(probZVals);
                
                // Calculate SEM (standard error of mean)
                res.sem.counts[key][o] = this.sem(countVals);
                res.sem.probs[key][o] = this.sem(probVals);
                res.sem.countZscores[key][o] = this.sem(countZVals);
                res.sem.probZscores[key][o] = this.sem(probZVals);
            }
            
            res.zscores[key] = res.probZscores[key];
        }
        return res;
    }

    combineSegs(omin, omax) {
        // Get qmin/qmax from ovlSettings
        const qmin = this.ovlSettings?.qmin || 18;
        const qmax = this.ovlSettings?.qmax || 30;
        const nReps = this.M.replicates.length;
        
        // Initialize counts for each query length and 'all' (using objects for negative index support)
        const counts = {};
        const perRep = { counts: {}, probs: {}, countZscores: {}, probZscores: {} };
        
        for (let qlen = qmin; qlen <= qmax; qlen++) {
            counts[qlen] = {};
            perRep.counts[qlen] = {};
            perRep.probs[qlen] = {};
            perRep.countZscores[qlen] = {};
            perRep.probZscores[qlen] = {};
            for (let o = omin; o <= omax; o++) {
                counts[qlen][o] = 0;
                perRep.counts[qlen][o] = new Array(nReps).fill(0);
                perRep.probs[qlen][o] = new Array(nReps).fill(0);
                perRep.countZscores[qlen][o] = new Array(nReps).fill(0);
                perRep.probZscores[qlen][o] = new Array(nReps).fill(0);
            }
        }
        counts['all'] = {};
        perRep.counts['all'] = {};
        perRep.probs['all'] = {};
        perRep.countZscores['all'] = {};
        perRep.probZscores['all'] = {};
        for (let o = omin; o <= omax; o++) {
            counts['all'][o] = 0;
            perRep.counts['all'][o] = new Array(nReps).fill(0);
            perRep.probs['all'][o] = new Array(nReps).fill(0);
            perRep.countZscores['all'][o] = new Array(nReps).fill(0);
            perRep.probZscores['all'][o] = new Array(nReps).fill(0);
        }
        
        // Sum across segments - both means and per-replicate values
        for (const seg of this.M.refOrder) {
            const sd = this.ovlData[seg]; 
            if (!sd || !sd.counts) continue;
            
            for (const key of Object.keys(sd.counts)) {
                if (!counts[key]) {
                    counts[key] = {};
                    perRep.counts[key] = {};
                    perRep.probs[key] = {};
                    perRep.countZscores[key] = {};
                    perRep.probZscores[key] = {};
                    for (let o = omin; o <= omax; o++) {
                        counts[key][o] = 0;
                        perRep.counts[key][o] = new Array(nReps).fill(0);
                        perRep.probs[key][o] = new Array(nReps).fill(0);
                        perRep.countZscores[key][o] = new Array(nReps).fill(0);
                        perRep.probZscores[key][o] = new Array(nReps).fill(0);
                    }
                }
                for (let o = omin; o <= omax; o++) {
                    counts[key][o] += sd.counts[key]?.[o] || 0;
                    // Sum per-replicate values if available
                    if (sd.perRep?.counts?.[key]?.[o]) {
                        for (let ri = 0; ri < nReps; ri++) {
                            perRep.counts[key][o][ri] += sd.perRep.counts[key][o][ri] || 0;
                        }
                    } else if (nReps === 1) {
                        // Single replicate - use the counts directly
                        perRep.counts[key][o][0] += sd.counts[key]?.[o] || 0;
                    }
                }
            }
        }
        
        // Calculate probs and z-scores for each key (both mean and per-replicate)
        const probs = {}, countZscores = {}, probZscores = {};
        const sem = { counts: {}, probs: {}, countZscores: {}, probZscores: {} };
        
        for (const key of Object.keys(counts)) {
            const countsObj = counts[key];
            
            // Get values as array for stats
            const valuesArr = [];
            for (let o = omin; o <= omax; o++) valuesArr.push(countsObj[o] || 0);
            
            const totalPairs = valuesArr.reduce((a, b) => a + b, 0) || 1;
            
            probs[key] = {};
            countZscores[key] = {};
            probZscores[key] = {};
            sem.counts[key] = {};
            sem.probs[key] = {};
            sem.countZscores[key] = {};
            sem.probZscores[key] = {};
            
            // Calculate probabilities (mean)
            for (let o = omin; o <= omax; o++) {
                probs[key][o] = (countsObj[o] || 0) / totalPairs;
            }
            
            // z-scores will be calculated as mean of per-replicate z-scores below
            // Initialize them to 0 first
            for (let o = omin; o <= omax; o++) {
                countZscores[key][o] = 0;
                probZscores[key][o] = 0;
            }
            
            // Now calculate per-replicate probs and z-scores FIRST
            // Then we'll compute the mean z-score as the average of per-rep z-scores
            for (let o = omin; o <= omax; o++) {
                const repCounts = perRep.counts[key][o];
                
                // Per-replicate totals for probability calculation
                const repTotals = repCounts.map((_, ri) => {
                    let tot = 0;
                    for (let ov = omin; ov <= omax; ov++) tot += perRep.counts[key][ov][ri] || 0;
                    return tot || 1;
                });
                
                // Per-replicate probs
                for (let ri = 0; ri < nReps; ri++) {
                    perRep.probs[key][o][ri] = repCounts[ri] / repTotals[ri];
                }
                
                // Per-replicate count z-scores (each rep has its own mean/std across overlaps)
                for (let ri = 0; ri < nReps; ri++) {
                    const repVals = [];
                    for (let ov = omin; ov <= omax; ov++) repVals.push(perRep.counts[key][ov][ri] || 0);
                    const rm = repVals.reduce((a,b) => a+b, 0) / repVals.length;
                    const rs = Math.sqrt(repVals.reduce((a,b) => a + (b-rm)**2, 0) / repVals.length) || 1;
                    perRep.countZscores[key][o][ri] = (repCounts[ri] - rm) / rs;
                }
                
                // Per-replicate prob z-scores (deviation from mean probability)
                for (let ri = 0; ri < nReps; ri++) {
                    const repProbVals = [];
                    for (let ov = omin; ov <= omax; ov++) repProbVals.push(perRep.probs[key][ov][ri] || 0);
                    const rpm = repProbVals.reduce((a,b) => a+b, 0) / repProbVals.length;
                    const rps = Math.sqrt(repProbVals.reduce((a,b) => a + (b-rpm)**2, 0) / repProbVals.length) || 1;
                    perRep.probZscores[key][o][ri] = (perRep.probs[key][o][ri] - rpm) / rps;
                }
                
                // Calculate SEM for each metric
                sem.counts[key][o] = this.sem(repCounts);
                sem.probs[key][o] = this.sem(perRep.probs[key][o]);
                sem.countZscores[key][o] = this.sem(perRep.countZscores[key][o]);
                sem.probZscores[key][o] = this.sem(perRep.probZscores[key][o]);
                
                // CRITICAL FIX: Mean z-scores should be AVERAGE of per-rep z-scores
                // Not the z-score of the averaged value!
                countZscores[key][o] = this.mean(perRep.countZscores[key][o]);
                probZscores[key][o] = this.mean(perRep.probZscores[key][o]);
            }
        }
        
        return { counts, probs, countZscores, probZscores, zscores: probZscores, perRep, sem, settings: this.ovlSettings, nReps };
    }

    mean(a) { return a.length ? a.reduce((x, y) => x + y, 0) / a.length : 0; }
    std(a) { if (a.length < 2) return 0; const m = this.mean(a); return Math.sqrt(a.reduce((x, y) => x + (y - m) ** 2, 0) / (a.length - 1)); }
    sem(a) { return a.length > 1 ? this.std(a) / Math.sqrt(a.length) : 0; }
    calcErr(a) { const t = document.getElementById('err-type').value; if (t === 'sem') return this.sem(a); if (t === 'ci95') return this.sem(a) * 1.96; return this.std(a); }

    aggReps() {
        const reps = this.M.replicates; if (!reps.length) return;
        const { minLen, maxLen } = this.M.settings;
        this.aggData = { 
            cov: {}, 
            len5: { fwd: {}, rev: {}, fE: {}, rE: {} }, 
            len3: { fwd: {}, rev: {}, fE: {}, rE: {} },
            // Library-wide (all reads, not just mapped) length distribution
            libLen5: { all: {}, err: {} },
            libLen3: { all: {}, err: {} }
        };
        
        // Aggregate library-wide length distribution (all reads, regardless of mapping)
        for (let l = minLen; l <= maxLen; l++) {
            const lib5 = reps.map(r => {
                if (!r.libLenDist5 || !r.libLenDist5[l]) return { total: 0, props: {A:0,C:0,G:0,T:0} };
                const d = r.libLenDist5[l];
                return { total: d.A + d.C + d.G + d.T, props: {...d} };
            });
            const lib3 = reps.map(r => {
                if (!r.libLenDist3 || !r.libLenDist3[l]) return { total: 0, props: {A:0,C:0,G:0,T:0} };
                const d = r.libLenDist3[l];
                return { total: d.A + d.C + d.G + d.T, props: {...d} };
            });
            
            // Aggregate props across all replicates for library-wide
            const libProps5 = { A: 0, C: 0, G: 0, T: 0 }, libProps3 = { A: 0, C: 0, G: 0, T: 0 };
            for (const item of lib5) {
                for (const nt of 'ACGT') libProps5[nt] += item.props[nt] || 0;
            }
            for (const item of lib3) {
                for (const nt of 'ACGT') libProps3[nt] += item.props[nt] || 0;
            }
            
            this.aggData.libLen5.all[l] = { mean: this.mean(lib5.map(x => x.total)), props: libProps5 };
            this.aggData.libLen5.err[l] = this.calcErr(lib5.map(x => x.total));
            this.aggData.libLen3.all[l] = { mean: this.mean(lib3.map(x => x.total)), props: libProps3 };
            this.aggData.libLen3.err[l] = this.calcErr(lib3.map(x => x.total));
        }
        
        // Aggregate mapped reads length distribution (existing code)
        for (let l = minLen; l <= maxLen; l++) {
            for (const strand of ['fwd', 'rev']) {
                const t5 = reps.map(r => { 
                    if (!r.lenDist5 || !r.lenDist5[strand]) return 0;
                    const d = r.lenDist5[strand][l] || {A:0,C:0,G:0,T:0}; 
                    return d.A + d.C + d.G + d.T; 
                });
                const t3 = reps.map(r => { 
                    if (!r.lenDist3 || !r.lenDist3[strand]) return 0;
                    const d = r.lenDist3[strand][l] || {A:0,C:0,G:0,T:0}; 
                    return d.A + d.C + d.G + d.T; 
                });
                // Aggregate props across all replicates
                const props5 = { A: 0, C: 0, G: 0, T: 0 }, props3 = { A: 0, C: 0, G: 0, T: 0 };
                for (const r of reps) {
                    if (r.lenDist5 && r.lenDist5[strand]) {
                        const d5 = r.lenDist5[strand][l] || {A:0,C:0,G:0,T:0};
                        for (const nt of 'ACGT') { props5[nt] += d5[nt] || 0; }
                    }
                    if (r.lenDist3 && r.lenDist3[strand]) {
                        const d3 = r.lenDist3[strand][l] || {A:0,C:0,G:0,T:0};
                        for (const nt of 'ACGT') { props3[nt] += d3[nt] || 0; }
                    }
                }
                this.aggData.len5[strand][l] = { mean: this.mean(t5), props: props5 };
                this.aggData.len5[(strand === 'fwd' ? 'fE' : 'rE')][l] = this.calcErr(t5);
                this.aggData.len3[strand][l] = { mean: this.mean(t3), props: props3 };
                this.aggData.len3[(strand === 'fwd' ? 'fE' : 'rE')][l] = this.calcErr(t3);
            }
        }
        // Coverage error from replicate variation
        for (const seg of this.M.refOrder) {
            const repTotals = reps.map(r => r.stats?.mapped || 0);
            const cv = this.mean(repTotals) > 0 ? this.std(repTotals) / this.mean(repTotals) : 0;
            this.aggData.cov[seg] = { cv };
        }
    }

    updateStats() {
        const { total, mapped } = this.M.stats;
        let tc = 0, tl = 0, cov = 0;
        for (const seg of this.M.refOrder) {
            const len = this.M.refs[seg]?.length || 0; 
            tl += len;
            const covFwd = this.M.covFwd[seg];
            const covRev = this.M.covRev[seg];
            if (covFwd && covRev) {
                for (let i = 0; i < len; i++) { 
                    const d = (covFwd[i] || 0) + (covRev[i] || 0); 
                    tc += d; 
                    if (d > 0) cov++; 
                }
            }
        }
        document.getElementById('s-total').textContent = total.toLocaleString();
        document.getElementById('s-mapped').textContent = mapped.toLocaleString();
        document.getElementById('s-pct').textContent = total > 0 ? (mapped / total * 100).toFixed(1) + '%' : '0%';
        document.getElementById('s-cov').textContent = tl > 0 ? (tc / tl).toFixed(1) + '√ó' : '0√ó';
        document.getElementById('s-breadth').textContent = tl > 0 ? (cov / tl * 100).toFixed(1) + '%' : '0%';
        document.getElementById('s-segs').textContent = this.M.refOrder.length;
        document.getElementById('s-reps').textContent = this.M.replicates.length;
        
        // Generate per-replicate breakdown table
        this.updateRepBreakdown();
    }
    
    updateRepBreakdown() {
        const container = document.getElementById('rep-breakdown');
        if (!this.M.replicates.length) {
            container.innerHTML = '<p style="color:var(--muted);">No data yet</p>';
            return;
        }
        
        const MAX_DISPLAY_SEGS = 10;
        const totalSegs = this.M.refOrder.length;
        const displaySegs = this.M.refOrder.slice(0, MAX_DISPLAY_SEGS);
        const hasMoreSegs = totalSegs > MAX_DISPLAY_SEGS;
        
        // Build table with replicate stats per segment
        let html = '';
        if (hasMoreSegs) {
            html += `<p style="color:var(--accent);font-size:0.8rem;margin-bottom:0.5rem;"><strong>Note:</strong> ${totalSegs} segments detected. Showing first ${MAX_DISPLAY_SEGS} in table. Download TSV for complete data.</p>`;
        }
        
        html += '<table style="width:100%;border-collapse:collapse;font-size:0.8rem;">';
        html += '<thead><tr style="background:var(--bg-alt);"><th style="padding:6px 10px;text-align:left;border:1px solid var(--border);">File</th>';
        html += '<th style="padding:6px 10px;text-align:right;border:1px solid var(--border);">Total</th>';
        html += '<th style="padding:6px 10px;text-align:right;border:1px solid var(--border);">Mapped</th>';
        html += '<th style="padding:6px 10px;text-align:right;border:1px solid var(--border);">%</th>';
        
        // Add column for each displayed segment
        for (const seg of displaySegs) {
            const shortName = seg.length > 15 ? seg.slice(0, 12) + '...' : seg;
            html += `<th style="padding:6px 10px;text-align:right;border:1px solid var(--border);max-width:100px;overflow:hidden;text-overflow:ellipsis;" title="${seg}">${shortName}</th>`;
        }
        if (hasMoreSegs) {
            html += `<th style="padding:6px 10px;text-align:center;border:1px solid var(--border);color:var(--muted);">+${totalSegs - MAX_DISPLAY_SEGS} more</th>`;
        }
        html += '</tr></thead><tbody>';
        
        // Add row for each replicate
        for (let ri = 0; ri < this.M.replicates.length; ri++) {
            const rep = this.M.replicates[ri];
            const fileName = this.files[ri]?.name || `Rep ${ri + 1}`;
            const shortFileName = fileName.length > 25 ? fileName.slice(0, 22) + '...' : fileName;
            const pct = rep.stats.total > 0 ? (rep.stats.mapped / rep.stats.total * 100).toFixed(1) : '0.0';
            
            // Highlight rows with no mapped reads
            const rowStyle = rep.stats.mapped === 0 ? 'background:rgba(255,0,0,0.1);' : '';
            
            html += `<tr style="${rowStyle}">`;
            html += `<td style="padding:6px 10px;border:1px solid var(--border);" title="${fileName}">${shortFileName}</td>`;
            html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${rep.stats.total.toLocaleString()}</td>`;
            html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);font-weight:${rep.stats.mapped > 0 ? '600' : '400'};">${rep.stats.mapped.toLocaleString()}</td>`;
            html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${pct}%</td>`;
            
            // Count mapped reads per displayed segment for this replicate
            for (const seg of displaySegs) {
                const segMapped = rep.mappedReads?.[seg]?.length || rep.segCounts?.[seg] || 0;
                const cellStyle = segMapped === 0 ? 'color:var(--muted);' : 'font-weight:500;';
                html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);${cellStyle}">${segMapped.toLocaleString()}</td>`;
            }
            if (hasMoreSegs) {
                // Sum remaining segments
                let otherTotal = 0;
                for (let si = MAX_DISPLAY_SEGS; si < totalSegs; si++) {
                    const seg = this.M.refOrder[si];
                    otherTotal += rep.mappedReads?.[seg]?.length || rep.segCounts?.[seg] || 0;
                }
                html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);color:var(--muted);">${otherTotal.toLocaleString()}</td>`;
            }
            html += '</tr>';
        }
        
        // Add totals row
        html += '<tr style="background:var(--bg-alt);font-weight:600;">';
        html += '<td style="padding:6px 10px;border:1px solid var(--border);">TOTAL</td>';
        html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${this.M.stats.total.toLocaleString()}</td>`;
        html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${this.M.stats.mapped.toLocaleString()}</td>`;
        const totalPct = this.M.stats.total > 0 ? (this.M.stats.mapped / this.M.stats.total * 100).toFixed(1) : '0.0';
        html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${totalPct}%</td>`;
        
        for (const seg of displaySegs) {
            let segTotal = 0;
            for (const rep of this.M.replicates) segTotal += rep.mappedReads?.[seg]?.length || rep.segCounts?.[seg] || 0;
            html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);">${segTotal.toLocaleString()}</td>`;
        }
        if (hasMoreSegs) {
            let otherGrandTotal = 0;
            for (let si = MAX_DISPLAY_SEGS; si < totalSegs; si++) {
                for (const rep of this.M.replicates) otherGrandTotal += rep.mappedReads[this.M.refOrder[si]]?.length || 0;
            }
            html += `<td style="padding:6px 10px;text-align:right;border:1px solid var(--border);color:var(--muted);">${otherGrandTotal.toLocaleString()}</td>`;
        }
        html += '</tr>';
        
        html += '</tbody></table>';
        container.innerHTML = html;
    }
    
    exportRepTSV() {
        if (!this.M.replicates.length) return;
        
        // Build TSV with ALL segments
        let tsv = 'File\tTotal\tMapped\tMapped_Pct';
        for (const seg of this.M.refOrder) tsv += `\t${seg}`;
        tsv += '\n';
        
        for (let ri = 0; ri < this.M.replicates.length; ri++) {
            const rep = this.M.replicates[ri];
            const fileName = this.files[ri]?.name || `Rep_${ri + 1}`;
            const pct = rep.stats.total > 0 ? (rep.stats.mapped / rep.stats.total * 100).toFixed(2) : '0.00';
            tsv += `${fileName}\t${rep.stats.total}\t${rep.stats.mapped}\t${pct}`;
            for (const seg of this.M.refOrder) {
                tsv += `\t${rep.mappedReads[seg]?.length || 0}`;
            }
            tsv += '\n';
        }
        
        // Add totals row
        tsv += `TOTAL\t${this.M.stats.total}\t${this.M.stats.mapped}\t${this.M.stats.total > 0 ? (this.M.stats.mapped / this.M.stats.total * 100).toFixed(2) : '0.00'}`;
        for (const seg of this.M.refOrder) {
            let segTotal = 0;
            for (const rep of this.M.replicates) segTotal += rep.mappedReads[seg]?.length || 0;
            tsv += `\t${segTotal}`;
        }
        tsv += '\n';
        
        const blob = new Blob([tsv], { type: 'text/tab-separated-values' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'replicate_mapping_summary.tsv';
        a.click();
        URL.revokeObjectURL(url);
    }

    redraw() { this.updateLegends(); this.drawHist('5'); this.drawHist('3'); this.drawCov(); this.drawLen(); this.drawBias(); this.drawOvl(); this.drawOvlHeatmap(); }

    niceNum(v, r = true) {
        if (v <= 0) return 10;
        const e = Math.floor(Math.log10(v)), f = v / Math.pow(10, e);
        let n; if (r) { n = f < 1.5 ? 1 : f < 3 ? 2 : f < 7 ? 5 : 10; } else { n = f <= 1 ? 1 : f <= 2 ? 2 : f <= 5 ? 5 : 10; }
        return n * Math.pow(10, e);
    }
    niceTicks(min, max, c = 5, forceIncludeMax = true) {
        if (max <= 0) return [0];
        const range = this.niceNum(max - min, false), step = this.niceNum(range / (c - 1), true), ticks = [];
        for (let v = 0; v <= max + step * 0.5; v += step) if (v <= max * 1.1) ticks.push(Math.round(v));
        // Ensure max value is included as a tick
        if (forceIncludeMax && ticks.length > 0 && ticks[ticks.length - 1] < max) {
            ticks.push(Math.round(max));
        }
        return ticks;
    }
    
    // Generate nice ticks with custom interval
    niceTicksWithInterval(min, max, interval, forceIncludeMax = true) {
        if (max <= 0) return [0];
        const ticks = [];
        for (let v = min; v <= max; v += interval) {
            ticks.push(Math.round(v * 1000) / 1000); // Handle float precision
        }
        // Ensure max value is included as a tick
        if (forceIncludeMax && ticks.length > 0 && ticks[ticks.length - 1] < max) {
            ticks.push(max);
        }
        return ticks;
    }
    // Format number - plain numbers WITHOUT commas
    fmtNum(n) { 
        // Simple number formatting - no k/M suffixes
        return Math.round(n).toLocaleString(); 
    }
    
    // Get magnitude info for axis labels (returns {divisor, suffix} for values >= 50000)
    getAxisMagnitude(maxVal) {
        if (maxVal >= 1e6) return { divisor: 1e6, suffix: ' (millions)' };
        if (maxVal >= 50000) return { divisor: 1e3, suffix: ' (thousands)' };
        return { divisor: 1, suffix: '' };
    }
    hexRgba(hex, a) { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r},${g},${b},${a})`; }

    /**
     * Draw read length histogram with stacked nucleotide bars
     * @param {string} endType - '5' or '3' for 5' or 3' bias
     */
    drawHist(endType) {
        const canvas = document.getElementById(`hist${endType}-canvas`), ctx = canvas.getContext('2d');
        const w = +document.getElementById(`hist${endType}-w`).value || 420;
        const h = +document.getElementById(`hist${endType}-h`).value || 220;
        const yMaxIn = +document.getElementById(`hist${endType}-ymax`).value || 0;
        const capW = +document.getElementById(`hist${endType}-cap`).value || 4;
        const showErr = document.getElementById(`hist${endType}-err`).checked && this.M.replicates.length > 1;
        const showPts = document.getElementById(`hist${endType}-pts`).checked && this.M.replicates.length > 1;
        const showJitter = document.getElementById(`hist${endType}-jitter`)?.checked || false;
        const dataType = document.getElementById(`hist${endType}-data`).value || 'counts';
        const colors = getNtColors();
        const errType = document.getElementById('err-type').value;
        const font = getFont();
        const fontSize = +document.getElementById(`hist${endType}-font`).value || 10;
        const xOff = +document.getElementById(`hist${endType}-xoff`)?.value || 0;
        const yOff = +document.getElementById(`hist${endType}-yoff`)?.value || 0;
        const labelSize = fontSize + 1;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        const pad = { t: 25, r: 20, b: 40 + xOff, l: 55 + yOff }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        if (!this.M.replicates.length) return;
        const { minLen, maxLen } = this.M.settings;
        const numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        // Get per-replicate library sizes for proper CPM normalization
        const libSizes = reps.map(rep => rep.stats.total || 1);
        
        // Collect data per length per nucleotide across all replicates
        // CRITICAL: For CPM, normalize EACH replicate by ITS OWN library size
        const dataByLen = {};
        for (let l = minLen; l <= maxLen; l++) {
            dataByLen[l] = { A: [], C: [], G: [], T: [], total: [] };
            for (let ri = 0; ri < reps.length; ri++) {
                const rep = reps[ri];
                const libLenDistKey = `libLenDist${endType}`;
                const libLenDist = rep[libLenDistKey];
                if (!libLenDist || !libLenDist[l]) {
                    for (const nt of 'ACGT') dataByLen[l][nt].push(0);
                    dataByLen[l].total.push(0);
                    continue;
                }
                const combined = libLenDist[l];
                const total = combined.A + combined.C + combined.G + combined.T;
                
                // Apply per-replicate normalization for CPM
                const repScale = dataType === 'cpm' ? 1e6 / libSizes[ri] : 1;
                for (const nt of 'ACGT') dataByLen[l][nt].push(combined[nt] * repScale);
                dataByLen[l].total.push(total * repScale);
            }
        }
        
        // For percentage, calculate grand total from mean of already-normalized values
        let grandTotal = 0;
        for (let l = minLen; l <= maxLen; l++) grandTotal += this.mean(dataByLen[l].total);
        
        // For percentage mode, apply percentage scaling to already-collected data
        if (dataType === 'pct') {
            const pctScale = 100 / (grandTotal || 1);
            for (let l = minLen; l <= maxLen; l++) {
                for (const nt of 'ACGT') {
                    dataByLen[l][nt] = dataByLen[l][nt].map(v => v * pctScale);
                }
                dataByLen[l].total = dataByLen[l].total.map(v => v * pctScale);
            }
        }
        
        // Calculate means and errors from properly normalized data
        const meanData = {}, errData = {}, rawData = {};
        let maxV = 0;
        for (let l = minLen; l <= maxLen; l++) {
            meanData[l] = {};
            errData[l] = {};
            rawData[l] = {};
            let stackTotal = 0;
            for (const nt of 'ACGT') {
                const vals = dataByLen[l][nt]; // Already normalized per-replicate
                rawData[l][nt] = vals;
                meanData[l][nt] = this.mean(vals);
                stackTotal += meanData[l][nt];
                if (errType === 'sem') errData[l][nt] = this.sem(vals);
                else if (errType === 'ci95') errData[l][nt] = this.sem(vals) * 1.96;
                else errData[l][nt] = this.std(vals);
            }
            rawData[l].total = dataByLen[l].total;
            // Calculate total error for Y-axis scaling
            // Use error of total (sum across nucleotides for each replicate)
            const totalErr = showErr ? this.calcErr(dataByLen[l].total) : 0;
            maxV = Math.max(maxV, stackTotal + totalErr);
        }
        // Add 20% margin to ensure data + error bars stay within bounds
        const maxWithMargin = maxV * 1.20;
        const niceMax = yMaxIn > 0 ? yMaxIn : this.niceNum(maxWithMargin) || 100;
        // Y-axis label - CPM shows values in millions
        const yLabel = dataType === 'cpm' ? 'CPM' : dataType === 'pct' ? 'Percentage (%)' : 'Read count';
        // Axes
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h - pad.b); ctx.lineTo(w - pad.r, h - pad.b); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = `${fontSize}px ${font}`; ctx.textAlign = 'right';
        const yTicks = this.niceTicks(0, niceMax, 4);
        for (const t of yTicks) {
            const y = h - pad.b - (t / niceMax) * ph;
            // Tick mark
            ctx.strokeStyle = '#000';
            ctx.beginPath(); ctx.moveTo(pad.l - 4, y); ctx.lineTo(pad.l, y); ctx.stroke();
            // CPM values are already scaled, just format them nicely
            let tickLabel;
            if (dataType === 'pct') {
                tickLabel = t.toFixed(1);
            } else {
                tickLabel = this.fmtNum(t);
            }
            ctx.fillText(tickLabel, pad.l - 6, y + 3);
            // Grid line
            if (t > 0) { ctx.strokeStyle = '#eee'; ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w - pad.r, y); ctx.stroke(); }
        }
        ctx.strokeStyle = '#000';
        ctx.textAlign = 'center';
        const xStart = +document.getElementById(`hist${endType}-xstart`)?.value || minLen;
        const xTickInt = +document.getElementById(`hist${endType}-xtick`)?.value || 2;
        // Start from xStart if it's >= minLen, otherwise use minLen
        const firstTick = Math.max(minLen, xStart);
        for (let l = firstTick; l <= maxLen; l += xTickInt) {
            const x = pad.l + (l - minLen + 0.5) * (pw / numL);
            // Tick mark
            ctx.beginPath(); ctx.moveTo(x, h - pad.b); ctx.lineTo(x, h - pad.b + 4); ctx.stroke();
            ctx.fillText(l.toString(), x, h - pad.b + 15);
        }
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText('Read length', w / 2, h - 5);
        // Y-axis label
        ctx.save(); ctx.translate(12, h / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText(yLabel, 0, 0); ctx.restore();
        // Draw bars - bar width from setting (as percentage of slot width)
        const barWidthPct = (+document.getElementById(`hist${endType}-barw`)?.value || 75) / 100;
        const bw = (pw / numL) * barWidthPct, gap = (pw / numL) * (1 - barWidthPct) / 2;
        const ntW = bw / 4; // Width for each nucleotide's segment
        this.plotInfo[`hist${endType}`] = { pad, pw, ph, bw, gap, minLen, maxLen, niceMax, numL, dataByLen, meanData, rawData, bars: [], dataType };
        
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * (pw / numL) + gap;
            let y = h - pad.b;
            const barInfo = { x, l, segments: [] };
            
            // Stack nucleotides: A, C, G, T from bottom
            for (const nt of 'ACGT') {
                const mean = meanData[l][nt];
                const barH = (mean / niceMax) * ph;
                if (barH > 0.5) {
                    ctx.fillStyle = colors[nt];
                    ctx.fillRect(x, y - barH, bw, barH);
                    barInfo.segments.push({ nt, y: y - barH, h: barH, mean });
                    y -= barH;
                }
            }
            
            // Error bars for each nucleotide at its stacked position
            if (showErr && reps.length > 1) {
                let cumY = h - pad.b;
                for (const nt of 'ACGT') {
                    const mean = meanData[l][nt];
                    const barH = (mean / niceMax) * ph;
                    cumY -= barH;
                    const err = errData[l][nt];
                    const errH = (err / niceMax) * ph;
                    if (errH > 1 && mean > 0) {
                        const midX = x + bw / 2;
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
                        // Draw error bar centered on top of this nucleotide's segment
                        const yCenter = cumY; // Top of this nucleotide's bar
                        const yTop = yCenter - errH;
                        const yBot = yCenter + errH;
                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(midX, yTop);
                        ctx.lineTo(midX, yBot);
                        ctx.stroke();
                        // Top cap
                        ctx.beginPath();
                        ctx.moveTo(midX - capW / 2, yTop);
                        ctx.lineTo(midX + capW / 2, yTop);
                        ctx.stroke();
                        // Bottom cap
                        ctx.beginPath();
                        ctx.moveTo(midX - capW / 2, yBot);
                        ctx.lineTo(midX + capW / 2, yBot);
                        ctx.stroke();
                    }
                }
            }
            
            // Individual replicate points - show at cumulative stacked position
            // Points should appear around the mean bar height for each nucleotide in the stack
            if (showPts && reps.length > 1) {
                const ptOpacity = +document.getElementById(`hist${endType}-pt-opacity`)?.value || 0.7;
                const numReps = reps.length;
                
                // For each replicate, calculate cumulative heights
                for (let ri = 0; ri < numReps; ri++) {
                    let cumHeight = 0; // Cumulative height for this replicate
                    
                    for (const nt of 'ACGT') {
                        const val = dataByLen[l][nt][ri]; // Already normalized per-replicate
                        const mean = meanData[l][nt];
                        
                        // Point Y at the TOP of this nucleotide's contribution in the stack
                        // This shows where this replicate's value sits relative to the stacked bar
                        cumHeight += val;
                        const ptY = h - pad.b - (cumHeight / niceMax) * ph;
                        
                        if (val <= 0) continue;
                        
                        // Spread points horizontally across the bar
                        const ntIdx = 'ACGT'.indexOf(nt);
                        let ptX;
                        if (showJitter) {
                            // Jitter: random-ish spread based on replicate index
                            const jitterOffset = ((ri * 7 + ntIdx * 3) % 10) / 10 - 0.5;
                            ptX = x + bw / 2 + jitterOffset * bw * 0.6;
                        } else {
                            // Spread evenly: each NT gets a section of the bar
                            const sectionW = bw / 4;
                            const sectionStart = x + ntIdx * sectionW;
                            ptX = sectionStart + sectionW * 0.2 + (ri / Math.max(1, numReps - 1)) * sectionW * 0.6;
                        }
                        
                        ctx.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                        ctx.beginPath();
                        ctx.arc(ptX, ptY, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            this.plotInfo[`hist${endType}`].bars.push(barInfo);
        }
        
        // Draw legend inside canvas if enabled
        const showLegend = document.getElementById(`hist${endType}-show-legend`)?.checked;
        if (showLegend) {
            const legendItems = [
                { label: 'A', color: colors.A },
                { label: 'C', color: colors.C },
                { label: 'G', color: colors.G },
                { label: 'T/U', color: colors.T }
            ];
            const legFontSize = +document.getElementById(`hist${endType}-leg-font`)?.value || 12;
            const legPos = document.getElementById(`hist${endType}-leg-pos`)?.value || 'center';
            const legBold = document.getElementById(`hist${endType}-leg-bold`)?.checked;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            const legendFont = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            ctx.font = legendFont;
            
            // Calculate total legend width
            let totalWidth = 0;
            for (const item of legendItems) {
                totalWidth += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
            totalWidth -= itemGap; // Remove last gap
            
            // Position based on setting
            let lx;
            if (legPos === 'left') {
                lx = pad.l + 10;
            } else if (legPos === 'right') {
                lx = w - pad.r - totalWidth - 10;
            } else { // center
                lx = (w - totalWidth) / 2;
            }
            const ly = 6;
            
            for (const item of legendItems) {
                ctx.fillStyle = item.color;
                ctx.fillRect(lx, ly, boxSize, boxSize);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(lx, ly, boxSize, boxSize);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
        }
    }

    drawCov() {
        const canvas = document.getElementById('cov-canvas'), ctx = canvas.getContext('2d');
        const w = +document.getElementById('cov-w').value || 900, h = +document.getElementById('cov-h').value || 240;
        const seg = document.getElementById('cov-seg').value;
        const showErr = document.getElementById('cov-err').checked && this.M.replicates.length > 1;
        const errOp = +document.getElementById('err-opacity').value || 0.25;
        const lw = +document.getElementById('cov-lw').value || 1.5;
        const fwdCol = document.getElementById('cov-fwd-col').value || '#0066cc';
        const revCol = document.getElementById('cov-rev-col').value || '#cc3300';
        const yMaxFwdIn = +document.getElementById('cov-ymax-fwd').value || 0;
        const yMaxRevIn = +document.getElementById('cov-ymax-rev').value || 0;
        const dataType = document.getElementById('cov-data').value || 'counts';
        const covType = document.getElementById('cov-type').value || 'full';
        const font = getFont();
        const fontSize = +document.getElementById('cov-font').value || 10;
        const xOff = +document.getElementById('cov-xoff')?.value || 0;
        const yOff = +document.getElementById('cov-yoff')?.value || 0;
        const xTickInterval = +document.getElementById('cov-xtick')?.value || 0; // Custom x-tick interval (0=auto)
        const xTickStart = +document.getElementById('cov-xstart')?.value || 0; // Custom x-tick start
        const xBold = document.getElementById('cov-xbold')?.checked || false;
        const yBold = document.getElementById('cov-ybold')?.checked || false;
        const labelSize = fontSize + 1;
        // Length filter for coverage
        const covLenMin = +document.getElementById('cov-len-min').value || 18;
        const covLenMax = +document.getElementById('cov-len-max').value || 30;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        if (!seg || !this.M.refs[seg]) return;
        
        // Get per-replicate library sizes for proper CPM normalization
        const libSizes = this.M.replicates.map(rep => rep.stats?.total || 1);
        
        const fullRefLen = this.M.refs[seg].length;
        
        // Get zoom range
        let rangeStart = +document.getElementById('cov-range-start')?.value || 0;
        let rangeEnd = +document.getElementById('cov-range-end')?.value || 0;
        const showSeq = document.getElementById('cov-show-seq')?.checked || false;
        const lockY = document.getElementById('cov-lock-y')?.checked || false;
        
        // Validate and apply range
        if (rangeEnd <= rangeStart || rangeEnd > fullRefLen) rangeEnd = fullRefLen;
        if (rangeStart < 0) rangeStart = 0;
        const refLen = rangeEnd - rangeStart;
        const isZoomed = rangeStart > 0 || rangeEnd < fullRefLen;
        
        // Adjust padding for sequence display - estimate charW first
        const estPw = w - 75 - yOff; // Approximate plot width
        const estCharW = estPw / refLen;
        const seqHeight = showSeq && refLen <= 500 && estCharW >= 4 ? (estCharW >= 15 && refLen <= 100 ? 35 : 20) : 0;
        const pad = { t: 20, r: 20, b: 35 + xOff + seqHeight, l: 55 + yOff }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b, midY = pad.t + ph / 2;
        
        const bins = Math.min(Math.floor(pw * 2), refLen);
        const binSz = refLen / bins;
        const fwdM = new Float32Array(bins), revM = new Float32Array(bins);
        const fwdE = new Float32Array(bins), revE = new Float32Array(bins);
        
        // Choose coverage source based on type
        const covType5 = covType === '5end';
        const covType3 = covType === '3end';
        const reps = this.M.replicates;
        
        // Calculate per-replicate coverage arrays with length filtering
        // Note: repCovFwd/repCovRev are indexed by FULL reference position, not zoomed
        const repCovFwd = [], repCovRev = [];
        for (const rep of reps) {
            const fCov = new Float32Array(fullRefLen), rCov = new Float32Array(fullRefLen);
            
            // Check if we have mappedReads (fresh run) or need to use pre-calculated coverage (cached)
            if (rep.mappedReads && rep.mappedReads[seg]) {
                const reads = rep.mappedReads[seg] || [];
                for (const read of reads) {
                    // Filter by read length
                    if (read.len < covLenMin || read.len > covLenMax) continue;
                    if (covType5) {
                        // 5' end coverage
                        const end5 = read.strand === 'fwd' ? read.pos : read.pos + read.len - 1;
                        if (end5 >= 0 && end5 < fullRefLen) {
                            if (read.strand === 'fwd') fCov[end5]++;
                            else rCov[end5]++;
                        }
                    } else if (covType3) {
                        // 3' end coverage
                        const end3 = read.strand === 'fwd' ? read.pos + read.len - 1 : read.pos;
                        if (end3 >= 0 && end3 < fullRefLen) {
                            if (read.strand === 'fwd') fCov[end3]++;
                            else rCov[end3]++;
                        }
                    } else {
                        // Full coverage
                        const st = Math.max(0, read.pos), en = Math.min(fullRefLen, read.pos + read.len);
                        for (let j = st; j < en; j++) {
                            if (read.strand === 'fwd') fCov[j]++;
                            else rCov[j]++;
                        }
                    }
                }
            } else {
                // Use pre-calculated coverage from cache (no length filtering available)
                let srcFwd, srcRev;
                if (covType5) {
                    srcFwd = rep.cov5Fwd?.[seg] || this.M.cov5Fwd?.[seg];
                    srcRev = rep.cov5Rev?.[seg] || this.M.cov5Rev?.[seg];
                } else if (covType3) {
                    srcFwd = rep.cov3Fwd?.[seg] || this.M.cov3Fwd?.[seg];
                    srcRev = rep.cov3Rev?.[seg] || this.M.cov3Rev?.[seg];
                } else {
                    srcFwd = rep.covFwd?.[seg] || this.M.covFwd?.[seg];
                    srcRev = rep.covRev?.[seg] || this.M.covRev?.[seg];
                }
                if (srcFwd) for (let j = 0; j < fullRefLen; j++) fCov[j] = srcFwd[j] || 0;
                if (srcRev) for (let j = 0; j < fullRefLen; j++) rCov[j] = srcRev[j] || 0;
            }
            repCovFwd.push(fCov);
            repCovRev.push(rCov);
        }
        
        // Calculate per-bin mean and error (accounting for zoom range)
        for (let i = 0; i < bins; i++) {
            const st = rangeStart + Math.floor(i * binSz);
            const en = rangeStart + Math.floor((i + 1) * binSz);
            const binLen = en - st;
            const fwdVals = [], revVals = [];
            
            for (let ri = 0; ri < reps.length; ri++) {
                let fSum = 0, rSum = 0;
                for (let j = st; j < en; j++) {
                    fSum += repCovFwd[ri][j] || 0;
                    rSum += repCovRev[ri][j] || 0;
                }
                // CRITICAL: Per-replicate CPM normalization
                const repScale = dataType === 'cpm' ? 1e6 / libSizes[ri] : 1;
                fwdVals.push((fSum / binLen) * repScale);
                revVals.push((rSum / binLen) * repScale);
            }
            
            fwdM[i] = this.mean(fwdVals);
            revM[i] = this.mean(revVals);
            if (showErr && reps.length > 1) {
                fwdE[i] = this.calcErr(fwdVals);
                revE[i] = this.calcErr(revVals);
            }
        }
        
        // Calculate independent max values for each strand
        let maxFwd = Math.max(...fwdM, 1);
        let maxRev = Math.max(...revM, 1);
        if (showErr) {
            maxFwd = Math.max(maxFwd, ...fwdM.map((v, i) => v + fwdE[i]));
            maxRev = Math.max(maxRev, ...revM.map((v, i) => v + revE[i]));
        }
        
        // By default, use same max for both strands (symmetric Y-axis)
        // User can override with specific values if needed
        let niceMaxFwd, niceMaxRev;
        if (lockY && isZoomed && this.covYMaxFull) {
            niceMaxFwd = yMaxFwdIn > 0 ? yMaxFwdIn : this.covYMaxFull.fwd;
            niceMaxRev = yMaxRevIn > 0 ? yMaxRevIn : this.covYMaxFull.rev;
        } else {
            // If user specified values, use them; otherwise use symmetric max
            if (yMaxFwdIn > 0 && yMaxRevIn > 0) {
                niceMaxFwd = yMaxFwdIn;
                niceMaxRev = yMaxRevIn;
            } else if (yMaxFwdIn > 0) {
                niceMaxFwd = yMaxFwdIn;
                niceMaxRev = yMaxFwdIn; // Use same as fwd
            } else if (yMaxRevIn > 0) {
                niceMaxFwd = yMaxRevIn; // Use same as rev
                niceMaxRev = yMaxRevIn;
            } else {
                // Auto: use same max for both (symmetric)
                const maxBoth = Math.max(maxFwd, maxRev);
                const niceMax = this.niceNum(maxBoth);
                niceMaxFwd = niceMax;
                niceMaxRev = niceMax;
            }
            // Store full-range max for lock feature
            if (!isZoomed) {
                this.covYMaxFull = { fwd: niceMaxFwd, rev: niceMaxRev };
            }
        }
        const yLabel = dataType === 'cpm' ? 'CPM' : (covType === '5end' ? "5‚Ä≤ end depth" : covType === '3end' ? "3‚Ä≤ end depth" : 'Read depth');
        
        // Get magnitude for Y-axis label
        const yMag = this.getAxisMagnitude(Math.max(niceMaxFwd, niceMaxRev));
        
        // Draw axes - solid black line at bottom
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); 
        ctx.moveTo(pad.l, pad.t); 
        ctx.lineTo(pad.l, h - pad.b); 
        ctx.lineTo(w - pad.r, h - pad.b); 
        ctx.stroke();
        // Zero line (center)
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(pad.l, midY); ctx.lineTo(w - pad.r, midY); ctx.stroke();
        
        // Y-axis labels with bold option
        ctx.fillStyle = '#000'; 
        ctx.font = `${yBold ? 'bold ' : ''}${fontSize}px ${font}`; 
        ctx.textAlign = 'right';
        
        // Y-axis ticks - use same intervals for both strands (symmetric)
        const yTickInterval = +document.getElementById('cov-ytick')?.value || 0;
        let yTicksFwd, yTicksRev;
        const niceMaxBoth = Math.max(niceMaxFwd, niceMaxRev);
        if (yTickInterval > 0) {
            // Custom Y-tick interval
            yTicksFwd = [];
            yTicksRev = [];
            for (let v = 0; v <= niceMaxFwd; v += yTickInterval) yTicksFwd.push(v);
            for (let v = 0; v <= niceMaxRev; v += yTickInterval) yTicksRev.push(v);
        } else {
            // Auto ticks - use same tick interval for both strands, more granular
            const commonTicks = this.niceTicks(0, niceMaxBoth, 4);
            yTicksFwd = commonTicks.filter(t => t <= niceMaxFwd);
            yTicksRev = commonTicks.filter(t => t <= niceMaxRev);
        }
        
        // Draw Y-axis tick marks and labels
        ctx.strokeStyle = '#000';
        for (const tick of yTicksFwd) {
            const yUp = midY - (tick / niceMaxFwd) * (ph / 2);
            // Tick mark
            ctx.beginPath(); ctx.moveTo(pad.l - 3, yUp); ctx.lineTo(pad.l, yUp); ctx.stroke();
            ctx.fillText(Math.round(tick / yMag.divisor).toLocaleString(), pad.l - 5, yUp + 3);
        }
        for (const tick of yTicksRev) {
            if (tick > 0) {
                const yDn = midY + (tick / niceMaxRev) * (ph / 2);
                // Tick mark
                ctx.beginPath(); ctx.moveTo(pad.l - 3, yDn); ctx.lineTo(pad.l, yDn); ctx.stroke();
                ctx.fillText(Math.round(tick / yMag.divisor).toLocaleString(), pad.l - 5, yDn + 3);
            }
        }
        
        // X-axis labels with bold option
        ctx.textAlign = 'center';
        ctx.font = `${xBold ? 'bold ' : ''}${fontSize}px ${font}`;
        
        // X-axis ticks - default to 500nt intervals if not specified
        let xTicks;
        let effectiveXTickInterval = xTickInterval;
        if (effectiveXTickInterval === 0) {
            // Default to 500nt or auto based on ref length
            effectiveXTickInterval = refLen > 2000 ? 500 : (refLen > 500 ? 200 : 0);
        }
        
        if (effectiveXTickInterval > 0) {
            // Custom or default tick interval
            xTicks = [];
            let firstTick = xTickStart > 0 ? xTickStart : Math.ceil(rangeStart / effectiveXTickInterval) * effectiveXTickInterval;
            if (firstTick < rangeStart) firstTick += effectiveXTickInterval;
            for (let tick = firstTick; tick <= rangeStart + refLen; tick += effectiveXTickInterval) {
                xTicks.push(tick);
            }
        } else {
            // Auto ticks for small references
            xTicks = this.niceTicks(rangeStart, rangeStart + refLen, 6);
        }
        
        ctx.strokeStyle = '#000';
        for (const tick of xTicks) {
            const xPos = pad.l + ((tick - rangeStart) / refLen) * pw;
            if (xPos >= pad.l && xPos <= pad.l + pw) {
                // Draw tick mark at bottom axis
                ctx.beginPath();
                ctx.moveTo(xPos, h - pad.b);
                ctx.lineTo(xPos, h - pad.b + 4);
                ctx.stroke();
                ctx.fillText(this.fmtNum(tick), xPos, h - pad.b + 15);
            }
        }
        ctx.font = `${xBold ? 'bold ' : ''}${labelSize}px ${font}`;
        ctx.fillText(isZoomed ? `Position (nt) [${rangeStart+1}-${rangeEnd}]` : 'Position (nt)', w / 2, h - pad.b + 30);
        
        // Draw reference sequence if zoomed in enough and enabled
        if (showSeq && refLen <= 500) {
            const seq = this.M.refs[seg].substring(rangeStart, rangeEnd);
            const ntColors = getNtColors();
            const seqLen = seq.length; // Use actual sequence length for positioning
            const charW = pw / seqLen;
            
            // Only show nucleotides if there's enough space
            if (charW >= 4) {
                // Use larger, wider monospace font for better visibility
                const ntFontSize = Math.min(14, Math.max(8, charW * 0.9));
                ctx.font = `bold ${ntFontSize}px Consolas, Monaco, "Courier New", monospace`;
                ctx.textAlign = 'center';
                
                // Draw nucleotides centered in each bin - aligned with position numbers
                for (let i = 0; i < seqLen; i++) {
                    const nt = seq[i].toUpperCase();
                    // Center each nucleotide in its bin
                    const x = pad.l + (i + 0.5) * charW;
                    ctx.fillStyle = ntColors[nt] || '#000';
                    ctx.fillText(nt, x, h - pad.b + 45);
                }
                
                // If very zoomed in, also show position numbers
                if (charW >= 15 && seqLen <= 100) {
                    ctx.font = `${Math.min(9, charW * 0.6)}px ${font}`;
                    ctx.fillStyle = '#666';
                    ctx.textAlign = 'center';
                    for (let i = 0; i < seqLen; i++) {
                        const pos = rangeStart + i + 1; // 1-based
                        // Same x position as nucleotide
                        const x = pad.l + (i + 0.5) * charW;
                        ctx.fillText(pos.toString(), x, h - pad.b + 57);
                    }
                }
            }
            
            // Draw tick marks for each nucleotide position
            if (charW >= 2) {
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= seqLen; i++) {
                    const x = pad.l + i * charW;
                    ctx.beginPath();
                    ctx.moveTo(x, midY);
                    ctx.lineTo(x, midY + 3);
                    ctx.stroke();
                }
            }
        }
        
        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#000';
        // Y-axis label with magnitude suffix
        ctx.font = `${yBold ? 'bold ' : ''}${labelSize}px ${font}`;
        ctx.save(); ctx.translate(12, h / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText(yLabel + yMag.suffix, 0, 0); ctx.restore();
        
        // Helper functions with independent scaling
        const toYFwd = v => { const r = Math.max(0, Math.min(niceMaxFwd, v)); return midY - (r / niceMaxFwd) * (ph / 2); };
        const toYRev = v => { const r = Math.max(0, Math.min(niceMaxRev, v)); return midY + (r / niceMaxRev) * (ph / 2); };
        
        // Error ribbons
        if (showErr && this.M.replicates.length > 1) {
            ctx.fillStyle = this.hexRgba(fwdCol, errOp);
            ctx.beginPath(); ctx.moveTo(pad.l, toYFwd(fwdM[0] + fwdE[0]));
            for (let i = 1; i < bins; i++) ctx.lineTo(pad.l + (i / bins) * pw, toYFwd(fwdM[i] + fwdE[i]));
            for (let i = bins - 1; i >= 0; i--) ctx.lineTo(pad.l + (i / bins) * pw, toYFwd(Math.max(0, fwdM[i] - fwdE[i])));
            ctx.closePath(); ctx.fill();
            ctx.fillStyle = this.hexRgba(revCol, errOp);
            ctx.beginPath(); ctx.moveTo(pad.l, toYRev(revM[0] + revE[0]));
            for (let i = 1; i < bins; i++) ctx.lineTo(pad.l + (i / bins) * pw, toYRev(revM[i] + revE[i]));
            for (let i = bins - 1; i >= 0; i--) ctx.lineTo(pad.l + (i / bins) * pw, toYRev(Math.max(0, revM[i] - revE[i])));
            ctx.closePath(); ctx.fill();
        }
        // Main lines
        ctx.lineWidth = lw; ctx.setLineDash([]);
        ctx.strokeStyle = fwdCol; ctx.beginPath(); ctx.moveTo(pad.l, toYFwd(fwdM[0]));
        for (let i = 1; i < bins; i++) ctx.lineTo(pad.l + (i / bins) * pw, toYFwd(fwdM[i]));
        ctx.stroke();
        ctx.strokeStyle = revCol; ctx.beginPath(); ctx.moveTo(pad.l, toYRev(revM[0]));
        for (let i = 1; i < bins; i++) ctx.lineTo(pad.l + (i / bins) * pw, toYRev(revM[i]));
        ctx.stroke();
        this.plotInfo.cov = { pad, pw, ph, midY, bins, binSz, seg, refLen, fwdM, revM, fwdE, revE, niceMaxFwd, niceMaxRev, covLenMin, covLenMax, rangeStart, rangeEnd, fullRefLen };
        // Update info with length filter and range
        const rangeInfo = isZoomed ? ` [${rangeStart+1}-${rangeEnd}]` : '';
        document.getElementById('cov-info').textContent = `${seg}${rangeInfo}:${refLen}nt | + ${this.fmtNum(Math.max(...fwdM))} | ‚àí ${this.fmtNum(Math.max(...revM))} | Lengths: ${covLenMin}-${covLenMax}nt`;
    }

    drawLen() {
        const canvas = document.getElementById('len-canvas'), ctx = canvas.getContext('2d');
        const w = +document.getElementById('len-w').value || 700, h = +document.getElementById('len-h').value || 320;
        const yMaxFwdIn = +document.getElementById('len-ymax-fwd')?.value || 0;
        const yMaxRevIn = +document.getElementById('len-ymax-rev')?.value || 0;
        const showErr = document.getElementById('len-err').checked && this.M.replicates.length > 1;
        const showPts = document.getElementById('len-pts').checked && this.M.replicates.length > 1;
        const showJitter = document.getElementById('len-jitter')?.checked || false;
        const ptOpacity = +document.getElementById('len-pt-opacity')?.value || 0.7;
        const selectedSeg = document.getElementById('len-seg')?.value || 'all';
        const topEnd = document.getElementById('len-top-end').value;
        const botEnd = document.getElementById('len-bot-end').value;
        const dataType = document.getElementById('len-data').value || 'counts';
        const xTick = +document.getElementById('len-xtick').value || 1;
        const errOp = +document.getElementById('err-opacity').value || 0.25;
        const xOff = +document.getElementById('len-xoff')?.value || 0;
        const yOff = +document.getElementById('len-yoff')?.value || 0;
        const colors = getNtColors();
        const font = getFont();
        const fontSize = +document.getElementById('len-font').value || 10;
        const labelSize = fontSize + 1;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        const pad = { t: 25, r: 20, b: 40 + xOff, l: 55 + yOff }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b, midY = pad.t + ph / 2;
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        if (!this.M.replicates.length) return;
        
        const { minLen, maxLen } = this.M.settings, numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        // Collect data per length per nucleotide per strand - either all segments or specific segment
        const dataByLen = { fwd5: {}, rev5: {}, fwd3: {}, rev3: {} };
        for (let l = minLen; l <= maxLen; l++) {
            dataByLen.fwd5[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.rev5[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.fwd3[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.rev3[l] = { A: [], C: [], G: [], T: [], total: [] };
            
            for (const rep of reps) {
                let fwd5, rev5, fwd3, rev3;
                if (selectedSeg === 'all') {
                    // Use global data - with safety checks
                    if (rep.lenDist5?.fwd && rep.lenDist5?.rev) {
                        fwd5 = rep.lenDist5.fwd[l] || { A: 0, C: 0, G: 0, T: 0 };
                        rev5 = rep.lenDist5.rev[l] || { A: 0, C: 0, G: 0, T: 0 };
                    } else {
                        fwd5 = { A: 0, C: 0, G: 0, T: 0 };
                        rev5 = { A: 0, C: 0, G: 0, T: 0 };
                    }
                    if (rep.lenDist3?.fwd && rep.lenDist3?.rev) {
                        fwd3 = rep.lenDist3.fwd[l] || { A: 0, C: 0, G: 0, T: 0 };
                        rev3 = rep.lenDist3.rev[l] || { A: 0, C: 0, G: 0, T: 0 };
                    } else {
                        fwd3 = { A: 0, C: 0, G: 0, T: 0 };
                        rev3 = { A: 0, C: 0, G: 0, T: 0 };
                    }
                } else {
                    // Use segment-specific data
                    const segData = rep.lenDistBySeg?.[selectedSeg];
                    fwd5 = segData?.len5?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev5 = segData?.len5?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    fwd3 = segData?.len3?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev3 = segData?.len3?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                }
                
                for (const nt of 'ACGT') {
                    dataByLen.fwd5[l][nt].push(fwd5[nt] || 0);
                    dataByLen.rev5[l][nt].push(rev5[nt] || 0);
                    dataByLen.fwd3[l][nt].push(fwd3[nt] || 0);
                    dataByLen.rev3[l][nt].push(rev3[nt] || 0);
                }
                dataByLen.fwd5[l].total.push((fwd5.A || 0) + (fwd5.C || 0) + (fwd5.G || 0) + (fwd5.T || 0));
                dataByLen.rev5[l].total.push((rev5.A || 0) + (rev5.C || 0) + (rev5.G || 0) + (rev5.T || 0));
                dataByLen.fwd3[l].total.push((fwd3.A || 0) + (fwd3.C || 0) + (fwd3.G || 0) + (fwd3.T || 0));
                dataByLen.rev3[l].total.push((rev3.A || 0) + (rev3.C || 0) + (rev3.G || 0) + (rev3.T || 0));
            }
        }
        
        // Select the correct data based on top/bottom end preferences
        const fwdKey = topEnd === '5' ? 'fwd5' : 'fwd3';
        const revKey = botEnd === '5' ? 'rev5' : 'rev3';
        const fwdData = dataByLen[fwdKey];
        const revData = dataByLen[revKey];
        
        // Get per-replicate library sizes for proper CPM normalization
        const libSizes = reps.map(rep => rep.stats?.total || 1);
        
        // Calculate grandTotal for percentage mode
        let grandTotal = 0;
        for (let l = minLen; l <= maxLen; l++) {
            grandTotal += this.mean(fwdData[l].total) + this.mean(revData[l].total);
        }
        
        // For CPM: normalize EACH replicate by ITS OWN library size, then average
        // For pct: normalize by grand total
        // For counts: no normalization
        const normalizeValues = (vals, isTotal = false) => {
            if (dataType === 'cpm') {
                // Each replicate normalized by its own library size
                return vals.map((v, ri) => v * 1e6 / libSizes[ri]);
            } else if (dataType === 'pct') {
                return vals.map(v => v * 100 / (grandTotal || 1));
            }
            return vals;
        };
        
        // Calculate means and errors with proper per-replicate normalization
        const fMean = {}, rMean = {}, fErr = {}, rErr = {}, fNtErr = {}, rNtErr = {};
        const fRaw = {}, rRaw = {}; // Store per-replicate normalized values for points
        let maxFwd = 0, maxRev = 0;
        for (let l = minLen; l <= maxLen; l++) {
            fMean[l] = { A: 0, C: 0, G: 0, T: 0, total: 0 };
            rMean[l] = { A: 0, C: 0, G: 0, T: 0, total: 0 };
            fNtErr[l] = { A: 0, C: 0, G: 0, T: 0 };
            rNtErr[l] = { A: 0, C: 0, G: 0, T: 0 };
            fRaw[l] = { A: [], C: [], G: [], T: [], total: [] };
            rRaw[l] = { A: [], C: [], G: [], T: [], total: [] };
            
            for (const nt of 'ACGT') {
                const fNorm = normalizeValues(fwdData[l][nt]);
                const rNorm = normalizeValues(revData[l][nt]);
                fRaw[l][nt] = fNorm;
                rRaw[l][nt] = rNorm;
                fMean[l][nt] = this.mean(fNorm);
                rMean[l][nt] = this.mean(rNorm);
                fNtErr[l][nt] = this.calcErr(fNorm);
                rNtErr[l][nt] = this.calcErr(rNorm);
            }
            
            const fTotalNorm = normalizeValues(fwdData[l].total);
            const rTotalNorm = normalizeValues(revData[l].total);
            fRaw[l].total = fTotalNorm;
            rRaw[l].total = rTotalNorm;
            fMean[l].total = this.mean(fTotalNorm);
            rMean[l].total = this.mean(rTotalNorm);
            fErr[l] = this.calcErr(fTotalNorm);
            rErr[l] = this.calcErr(rTotalNorm);
            
            const fe = showErr ? fErr[l] : 0, re = showErr ? rErr[l] : 0;
            maxFwd = Math.max(maxFwd, fMean[l].total + fe);
            maxRev = Math.max(maxRev, rMean[l].total + re);
        }
        
        // By default, use same max for both strands (symmetric Y-axis)
        // Add 15% margin to ensure error bars fit
        let niceMaxFwd, niceMaxRev;
        if (yMaxFwdIn > 0 && yMaxRevIn > 0) {
            niceMaxFwd = yMaxFwdIn;
            niceMaxRev = yMaxRevIn;
        } else if (yMaxFwdIn > 0) {
            niceMaxFwd = yMaxFwdIn;
            niceMaxRev = yMaxFwdIn;
        } else if (yMaxRevIn > 0) {
            niceMaxFwd = yMaxRevIn;
            niceMaxRev = yMaxRevIn;
        } else {
            // Auto: use same max for both (symmetric) with extra margin for error bars
            const maxBothWithMargin = Math.max(maxFwd, maxRev) * 1.15;
            const niceMax = this.niceNum(maxBothWithMargin) || 100;
            niceMaxFwd = niceMax;
            niceMaxRev = niceMax;
        }
        const yLabel = dataType === 'cpm' ? 'CPM' : dataType === 'pct' ? 'Percentage (%)' : 'Read count';
        
        // Get magnitude for Y-axis label
        const yMag = this.getAxisMagnitude(Math.max(niceMaxFwd, niceMaxRev));
        
        // Axes
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(pad.l, midY); ctx.lineTo(w - pad.r, midY); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h - pad.b); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = `${fontSize}px ${font}`; ctx.textAlign = 'right';
        
        // Use same ticks for both strands (symmetric)
        const niceMaxBoth = Math.max(niceMaxFwd, niceMaxRev);
        const yTicksCommon = this.niceTicks(0, niceMaxBoth, 4);
        
        // Forward Y-axis ticks (above midline)
        for (const t of yTicksCommon.filter(t => t <= niceMaxFwd)) {
            const yPos = midY - (t / niceMaxFwd) * (ph / 2);
            ctx.fillText(dataType === 'pct' ? t.toFixed(1) : Math.round(t / yMag.divisor).toLocaleString(), pad.l - 5, yPos + 3);
        }
        
        // Reverse Y-axis ticks (below midline)
        for (const t of yTicksCommon.filter(t => t <= niceMaxRev)) {
            if (t > 0) {
                const yPos = midY + (t / niceMaxRev) * (ph / 2);
                ctx.fillText(dataType === 'pct' ? t.toFixed(1) : Math.round(t / yMag.divisor).toLocaleString(), pad.l - 5, yPos + 3);
            }
        }
        
        ctx.textAlign = 'center';
        for (let l = minLen; l <= maxLen; l += xTick) ctx.fillText(l.toString(), pad.l + (l - minLen + 0.5) * (pw / numL), h - pad.b + 15);
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText('Read length (nt)', w / 2, h - 5);
        // Y-axis label with magnitude suffix
        ctx.save(); ctx.translate(12, h / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText(yLabel + yMag.suffix, 0, 0); ctx.restore();
        
        // Bar width from setting
        const barWidthPct = (+document.getElementById('len-barw')?.value || 75) / 100;
        const bw = (pw / numL) * barWidthPct, gap = (pw / numL) * (1 - barWidthPct) / 2;
        this.plotInfo.len = { pad, pw, ph, midY, numL, bw, minLen, maxLen, niceMaxFwd, niceMaxRev, bars: [] };
        
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * (pw / numL) + gap;
            const fTotal = fMean[l].total;
            const rTotal = rMean[l].total;
            
            // Forward bars (upward) - stacked ACGT from midline
            let fy = midY;
            for (const nt of 'ACGT') {
                const val = fMean[l][nt];
                const barH = (val / niceMaxFwd) * (ph / 2);
                if (barH > 0.5) { 
                    ctx.fillStyle = colors[nt]; 
                    ctx.fillRect(x, fy - barH, bw, barH); 
                    fy -= barH; 
                }
            }
            
            // Forward per-NT error bars at each cumulative level
            if (showErr && reps.length > 1) {
                let cumY = midY;
                for (const nt of 'ACGT') {
                    const val = fMean[l][nt];
                    const barH = (val / niceMaxFwd) * (ph / 2);
                    cumY -= barH;
                    const err = fNtErr[l][nt];
                    const errH = (err / niceMaxFwd) * (ph / 2);
                    if (errH > 1 && barH > 0.5) {
                        const midX = x + bw / 2;
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(midX, cumY); ctx.lineTo(midX, cumY - errH);
                        ctx.moveTo(midX - bw / 6, cumY - errH); ctx.lineTo(midX + bw / 6, cumY - errH);
                        ctx.stroke();
                    }
                }
            }
            
            // Reverse bars (downward) - stacked ACGT from midline
            let ry = midY;
            for (const nt of 'ACGT') {
                const val = rMean[l][nt];
                const barH = (val / niceMaxRev) * (ph / 2);
                if (barH > 0.5) { 
                    ctx.fillStyle = colors[nt]; 
                    ctx.fillRect(x, ry, bw, barH); 
                    ry += barH; 
                }
            }
            
            // Reverse per-NT error bars at each cumulative level
            if (showErr && reps.length > 1) {
                let cumY = midY;
                for (const nt of 'ACGT') {
                    const val = rMean[l][nt];
                    const barH = (val / niceMaxRev) * (ph / 2);
                    cumY += barH;
                    const err = rNtErr[l][nt];
                    const errH = (err / niceMaxRev) * (ph / 2);
                    if (errH > 1 && barH > 0.5) {
                        const midX = x + bw / 2;
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(midX, cumY); ctx.lineTo(midX, cumY + errH);
                        ctx.moveTo(midX - bw / 6, cumY + errH); ctx.lineTo(midX + bw / 6, cumY + errH);
                        ctx.stroke();
                    }
                }
            }
            
            // Individual replicate points - show at cumulative stacked position
            if (showPts && reps.length > 1) {
                const numReps = reps.length;
                
                // Forward strand points (upward from midline) - cumulative stacking
                for (let ri = 0; ri < numReps; ri++) {
                    let cumHeight = 0;
                    for (const nt of 'ACGT') {
                        const val = fRaw[l][nt][ri];
                        cumHeight += val;
                        
                        if (val <= 0) continue;
                        
                        // Point at the TOP of this nucleotide's contribution in the stack
                        const ptY = midY - (cumHeight / niceMaxFwd) * (ph / 2);
                        
                        const ntIdx = 'ACGT'.indexOf(nt);
                        let ptX;
                        if (showJitter) {
                            const jitterOffset = ((ri * 7 + ntIdx * 3) % 10) / 10 - 0.5;
                            ptX = x + bw / 2 + jitterOffset * bw * 0.6;
                        } else {
                            const sectionW = bw / 4;
                            const sectionStart = x + ntIdx * sectionW;
                            ptX = sectionStart + sectionW * 0.2 + (ri / Math.max(1, numReps - 1)) * sectionW * 0.6;
                        }
                        
                        ctx.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                        ctx.beginPath();
                        ctx.arc(ptX, ptY, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
                
                // Reverse strand points (downward from midline) - cumulative stacking
                for (let ri = 0; ri < numReps; ri++) {
                    let cumHeight = 0;
                    for (const nt of 'ACGT') {
                        const val = rRaw[l][nt][ri];
                        cumHeight += val;
                        
                        if (val <= 0) continue;
                        
                        // Point at the BOTTOM of this nucleotide's contribution in the stack
                        const ptY = midY + (cumHeight / niceMaxRev) * (ph / 2);
                        
                        const ntIdx = 'ACGT'.indexOf(nt);
                        let ptX;
                        if (showJitter) {
                            const jitterOffset = ((ri * 7 + ntIdx * 3) % 10) / 10 - 0.5;
                            ptX = x + bw / 2 + jitterOffset * bw * 0.6;
                        } else {
                            const sectionW = bw / 4;
                            const sectionStart = x + ntIdx * sectionW;
                            ptX = sectionStart + sectionW * 0.2 + (ri / Math.max(1, numReps - 1)) * sectionW * 0.6;
                        }
                        
                        ctx.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                        ctx.beginPath();
                        ctx.arc(ptX, ptY, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            
            this.plotInfo.len.bars.push({ l, x, bw, fwdM: fMean[l].total, revM: rMean[l].total, fwd: fMean[l], rev: rMean[l] });
        }
        
        // Draw legend inside canvas if enabled
        const showLegend = document.getElementById('len-show-legend')?.checked;
        if (showLegend) {
            const legendItems = [
                { label: 'A', color: colors.A },
                { label: 'C', color: colors.C },
                { label: 'G', color: colors.G },
                { label: 'T/U', color: colors.T }
            ];
            const legFontSize = +document.getElementById('len-leg-font')?.value || 12;
            const legPos = document.getElementById('len-leg-pos')?.value || 'center';
            const legBold = document.getElementById('len-leg-bold')?.checked;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            const legendFont = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            ctx.font = legendFont;
            
            // Calculate total legend width
            let totalWidth = 0;
            for (const item of legendItems) {
                totalWidth += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
            totalWidth -= itemGap;
            
            // Position based on setting
            let lx;
            if (legPos === 'left') {
                lx = pad.l + 10;
            } else if (legPos === 'right') {
                lx = w - pad.r - totalWidth - 10;
            } else { // center
                lx = (w - totalWidth) / 2;
            }
            const ly = 6;
            
            for (const item of legendItems) {
                ctx.fillStyle = item.color;
                ctx.fillRect(lx, ly, boxSize, boxSize);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(lx, ly, boxSize, boxSize);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
        }
    }

    drawBias() {
        const canvas = document.getElementById('bias-canvas'), ctx = canvas.getContext('2d');
        const w = +document.getElementById('bias-w').value || 700, h = +document.getElementById('bias-h').value || 180;
        const endType = document.getElementById('bias-end').value;
        const strandType = document.getElementById('bias-strand').value;
        const displayType = document.getElementById('bias-type').value;
        const maxBits = +document.getElementById('bias-maxbits').value || 2;
        const xTick = +document.getElementById('bias-xtick').value || 2;
        const selectedSeg = document.getElementById('bias-seg')?.value || 'all';
        const showErr = document.getElementById('bias-err')?.checked && this.M.replicates.length > 1;
        const biasLenMin = +document.getElementById('bias-len-min')?.value || 18;
        const biasLenMax = +document.getElementById('bias-len-max')?.value || 30;
        const colors = getNtColors();
        const font = getFont();
        const fontSize = +document.getElementById('bias-font').value || 10;
        const labelSize = fontSize + 1;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        const pad = { t: 15, r: 15, b: 35, l: 50 }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        if (!this.M.replicates.length) return;
        
        const numPos = 20;
        const reps = this.M.replicates;
        const { minLen, maxLen } = this.M.settings;
        
        // Check if length filtering is active (different from full range)
        const filterActive = biasLenMin !== minLen || biasLenMax !== maxLen;
        
        // Helper function to get bias data for a replicate
        // If length filter is active, recalculate from mapped reads
        const getBiasData = (rep, strandEnd, pos) => {
            if (!filterActive) {
                // No filter - use pre-calculated data
                if (selectedSeg === 'all') {
                    return rep.bias[strandEnd][pos] || { A: 0, C: 0, G: 0, T: 0 };
                } else {
                    return rep.biasBySeg[selectedSeg]?.[strandEnd]?.[pos] || { A: 0, C: 0, G: 0, T: 0 };
                }
            }
            return null; // Will be calculated below
        };
        
        // Calculate length-filtered bias if needed
        let filteredBias = null;
        if (filterActive) {
            filteredBias = {};
            for (const rep of reps) {
                const repBias = {
                    fwd5: Array(numPos).fill(null).map(() => ({ A: 0, C: 0, G: 0, T: 0 })),
                    rev5: Array(numPos).fill(null).map(() => ({ A: 0, C: 0, G: 0, T: 0 })),
                    fwd3: Array(numPos).fill(null).map(() => ({ A: 0, C: 0, G: 0, T: 0 })),
                    rev3: Array(numPos).fill(null).map(() => ({ A: 0, C: 0, G: 0, T: 0 }))
                };
                
                // Get segments to process
                const segsToProcess = selectedSeg === 'all' ? this.M.refOrder : [selectedSeg];
                
                for (const seg of segsToProcess) {
                    const reads = rep.mappedReads[seg] || [];
                    const refSeq = this.M.refs[seg];
                    
                    for (const read of reads) {
                        // Apply length filter
                        if (read.len < biasLenMin || read.len > biasLenMax) continue;
                        
                        // Get sequence in aligned orientation
                        let seq = refSeq.substring(read.pos, read.pos + read.len);
                        if (read.strand === 'rev') {
                            seq = seq.split('').reverse().map(b => ({A:'T',T:'A',C:'G',G:'C'}[b] || 'N')).join('');
                        }
                        
                        const strand = read.strand === 'fwd' ? 'fwd' : 'rev';
                        const maxP = Math.min(numPos, seq.length);
                        
                        for (let i = 0; i < maxP; i++) {
                            const nt5 = seq[i];
                            const nt3 = seq[seq.length - 1 - i];
                            if ('ACGT'.includes(nt5)) repBias[strand + '5'][i][nt5]++;
                            if ('ACGT'.includes(nt3)) repBias[strand + '3'][i][nt3]++;
                        }
                    }
                }
                filteredBias[reps.indexOf(rep)] = repBias;
            }
        }
        
        // Collect per-replicate data for each position
        const dataByPos = [];
        for (let i = 0; i < numPos; i++) {
            const posData = { perRep: [], combined: { A: 0, C: 0, G: 0, T: 0 } };
            for (let ri = 0; ri < reps.length; ri++) {
                const rep = reps[ri];
                const c = { A: 0, C: 0, G: 0, T: 0 };
                
                if (filterActive) {
                    // Use filtered data
                    if (strandType === 'both' || strandType === 'fwd') {
                        const d = filteredBias[ri]['fwd' + endType][i];
                        for (const nt of 'ACGT') c[nt] += d[nt];
                    }
                    if (strandType === 'both' || strandType === 'rev') {
                        const d = filteredBias[ri]['rev' + endType][i];
                        for (const nt of 'ACGT') c[nt] += d[nt];
                    }
                } else {
                    // Use pre-calculated data
                    if (strandType === 'both' || strandType === 'fwd') {
                        const d = getBiasData(rep, 'fwd' + endType, i);
                        for (const nt of 'ACGT') c[nt] += d[nt];
                    }
                    if (strandType === 'both' || strandType === 'rev') {
                        const d = getBiasData(rep, 'rev' + endType, i);
                        for (const nt of 'ACGT') c[nt] += d[nt];
                    }
                }
                posData.perRep.push(c);
                for (const nt of 'ACGT') posData.combined[nt] += c[nt];
            }
            dataByPos.push(posData);
        }
        
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h - pad.b); ctx.lineTo(w - pad.r, h - pad.b); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = `${fontSize}px ${font}`;
        
        if (displayType === 'prop') {
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) ctx.fillText((i * 25) + '%', pad.l - 5, pad.t + ph - (ph * i / 4) + 3);
            ctx.textAlign = 'center';
            for (let i = 0; i < numPos; i += xTick) ctx.fillText((i + 1).toString(), pad.l + (i + 0.5) * (pw / numPos), h - pad.b + 12);
            ctx.font = `${labelSize}px ${font}`;
            ctx.fillText(`Position from ${endType}‚Ä≤ end`, w / 2, h - 5);
            const bw = pw / numPos * 0.8;
            
            for (let i = 0; i < numPos; i++) {
                const c = dataByPos[i].combined;
                const total = c.A + c.C + c.G + c.T;
                if (total === 0) continue;
                const x = pad.l + i * (pw / numPos) + (pw / numPos - bw) / 2;
                let y = h - pad.b;
                
                // Draw stacked bars
                for (const nt of 'ACGT') {
                    const barH = (c[nt] / total) * ph;
                    if (barH > 0.5) { 
                        ctx.fillStyle = colors[nt]; 
                        ctx.fillRect(x, y - barH, bw, barH); 
                        y -= barH; 
                    }
                }
                
                // Error bars per NT at top of each segment
                if (showErr && reps.length > 1) {
                    let cumY = h - pad.b;
                    for (const nt of 'ACGT') {
                        // Calculate per-replicate proportions for this NT
                        const props = dataByPos[i].perRep.map(rep => {
                            const t = rep.A + rep.C + rep.G + rep.T;
                            return t > 0 ? rep[nt] / t : 0;
                        });
                        const meanProp = this.mean(props);
                        const errProp = this.calcErr(props);
                        
                        const barH = meanProp * ph;
                        cumY -= barH;
                        const errH = errProp * ph;
                        
                        if (errH > 1 && barH > 0.5) {
                            const midX = x + bw / 2;
                            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(midX, cumY); ctx.lineTo(midX, cumY - errH);
                            ctx.moveTo(midX - 2, cumY - errH); ctx.lineTo(midX + 2, cumY - errH);
                            ctx.stroke();
                        }
                    }
                }
            }
        } else {
            // Bits (logo) mode
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) ctx.fillText((maxBits * i / 4).toFixed(1), pad.l - 5, pad.t + ph - (ph * i / 4) + 3);
            ctx.textAlign = 'center';
            for (let i = 0; i < numPos; i += xTick) ctx.fillText((i + 1).toString(), pad.l + (i + 0.5) * (pw / numPos), h - pad.b + 12);
            ctx.font = `${labelSize}px ${font}`;
            ctx.fillText(`Position from ${endType}‚Ä≤ end`, w / 2, h - 5);
            // Y-axis label
            ctx.save(); ctx.translate(12, h / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#000'; ctx.fillText('Bits', 0, 0); ctx.restore();
            
            const colW = pw / numPos;
            
            for (let i = 0; i < numPos; i++) {
                const c = dataByPos[i].combined;
                const total = c.A + c.C + c.G + c.T;
                if (total === 0) continue;
                
                const freqs = {}; let entropy = 0;
                for (const nt of 'ACGT') { 
                    freqs[nt] = c[nt] / total; 
                    if (freqs[nt] > 0) entropy -= freqs[nt] * Math.log2(freqs[nt]); 
                }
                // Information content = 2 bits (max for DNA) - entropy
                const info = Math.max(0, 2 - entropy);
                const sorted = 'ACGT'.split('').sort((a, b) => freqs[a] - freqs[b]);
                let y = h - pad.b;
                
                for (const nt of sorted) {
                    // Scale to display based on maxBits Y-axis
                    const lh = (freqs[nt] * info / maxBits) * ph;
                    if (lh < 3) continue;
                    ctx.fillStyle = colors[nt];
                    ctx.save(); 
                    ctx.translate(pad.l + i * colW + colW / 2, y - lh / 2);
                    ctx.scale(colW * 0.7 / 20, lh / 20);
                    ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(nt, 0, 0); 
                    ctx.restore();
                    y -= lh;
                }
                
                // Error bar for bits mode - calculate per-replicate info content
                if (showErr && reps.length > 1) {
                    const repInfos = dataByPos[i].perRep.map(rep => {
                        const t = rep.A + rep.C + rep.G + rep.T;
                        if (t === 0) return 0;
                        let e = 0;
                        for (const nt of 'ACGT') {
                            const f = rep[nt] / t;
                            if (f > 0) e -= f * Math.log2(f);
                        }
                        return Math.max(0, 2 - e);
                    });
                    const meanInfo = this.mean(repInfos);
                    const errInfo = this.calcErr(repInfos);
                    
                    // Draw error bar at top of stack
                    const stackTop = h - pad.b - (meanInfo / maxBits) * ph;
                    const errH = (errInfo / maxBits) * ph;
                    if (errH > 1) {
                        const midX = pad.l + i * colW + colW / 2;
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(midX, stackTop); ctx.lineTo(midX, stackTop - errH);
                        ctx.moveTo(midX - 3, stackTop - errH); ctx.lineTo(midX + 3, stackTop - errH);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Draw legend inside canvas if enabled
        const showLegend = document.getElementById('bias-show-legend')?.checked;
        if (showLegend) {
            const legendItems = [
                { label: 'A', color: colors.A },
                { label: 'C', color: colors.C },
                { label: 'G', color: colors.G },
                { label: 'T/U', color: colors.T }
            ];
            const legFontSize = +document.getElementById('bias-leg-font')?.value || 12;
            const legPos = document.getElementById('bias-leg-pos')?.value || 'center';
            const legBold = document.getElementById('bias-leg-bold')?.checked;
            const legXoff = +document.getElementById('bias-leg-xoff')?.value || 15;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            const legendFont = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            ctx.font = legendFont;
            
            // Calculate total legend width
            let totalWidth = 0;
            for (const item of legendItems) {
                totalWidth += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
            totalWidth -= itemGap;
            
            // Position based on setting - position above the plot area
            let lx;
            if (legPos === 'left') {
                lx = pad.l + legXoff;
            } else if (legPos === 'right') {
                lx = w - pad.r - totalWidth - legXoff;
            } else { // center
                lx = (w - totalWidth) / 2;
            }
            // Position legend at very top with minimal margin, with Y offset control
            const legYoff = +document.getElementById('bias-leg-yoff')?.value || 0;
            const ly = 2 + legYoff;
            
            for (const item of legendItems) {
                ctx.fillStyle = item.color;
                ctx.fillRect(lx, ly, boxSize, boxSize);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(lx, ly, boxSize, boxSize);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                // Vertically center text with box using font metrics
                ctx.fillText(item.label, lx + boxSize + 5, ly + boxSize * 0.75 + legFontSize * 0.1);
                lx += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
        }
    }

    drawOvl() {
        const canvas = document.getElementById('ovl-canvas'), ctx = canvas.getContext('2d');
        const w = +document.getElementById('ovl-w').value || 800, h = +document.getElementById('ovl-h').value || 500;
        const seg = document.getElementById('ovl-seg').value;
        const font = getFont();
        const fontSize = +document.getElementById('ovl-font').value || 10;
        const labelSize = fontSize + 1;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        // Get settings from ovlSettings (set by recalcOverlap)
        const qmin = this.ovlSettings?.qmin || +document.getElementById('ovl-qmin')?.value || 23;
        const qmax = this.ovlSettings?.qmax || +document.getElementById('ovl-qmax')?.value || 29;
        const tmin = this.ovlSettings?.tmin || +document.getElementById('ovl-tmin')?.value || 23;
        const tmax = this.ovlSettings?.tmax || +document.getElementById('ovl-tmax')?.value || 29;
        const omin = this.ovlSettings?.omin || +document.getElementById('ovl-omin')?.value || 1;
        const omax = this.ovlSettings?.omax || +document.getElementById('ovl-omax')?.value || 19;
        
        // Always draw 4-panel
        this.drawOvl4Panel(ctx, w, h, ovlData, omin, omax, font, fontSize, labelSize, qmin, qmax, tmin, tmax, seg);
    }
    
    // Separate heatmap drawing function - uses its own independent controls
    drawOvlHeatmap() {
        const canvas = document.getElementById('ovl-hm-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = +document.getElementById('ovl-hm-w')?.value || 700;
        const h = +document.getElementById('ovl-hm-h')?.value || 350;
        // Use heatmap-specific controls
        const dataType = document.getElementById('ovl-hm-data')?.value || 'z';
        const seg = document.getElementById('ovl-hm-seg')?.value || document.getElementById('ovl-seg')?.value || 'all';
        const font = getFont();
        const fontSize = +document.getElementById('ovl-hm-font')?.value || 14;
        const labelSize = fontSize + 1;
        const dpr = devicePixelRatio || 1;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = w * dpr; canvas.height = h * dpr; ctx.scale(dpr, dpr);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        // Use heatmap-specific range controls, falling back to 4-panel settings
        const qmin = +document.getElementById('ovl-hm-qmin')?.value || this.ovlSettings?.qmin || 18;
        const qmax = +document.getElementById('ovl-hm-qmax')?.value || this.ovlSettings?.qmax || 30;
        const omin = +document.getElementById('ovl-hm-omin')?.value || this.ovlSettings?.omin || -10;
        const omax = +document.getElementById('ovl-hm-omax')?.value || this.ovlSettings?.omax || 30;
        
        this.drawOvlHeatmapPanel(ctx, w, h, ovlData, omin, omax, qmin, qmax, font, fontSize, labelSize, dataType, seg);
    }
    
    // Hover handler for heatmap
    hoverOvlHeatmap(e) {
        // Similar to hoverOvl but for heatmap canvas
        const info = this.plotInfo.ovlHm;
        if (!info) return;
        const r = e.target.getBoundingClientRect();
        const x = e.clientX - r.left, y = e.clientY - r.top;
        const { pad, cw, ch, qmin, qmax, omin, omax, numLens, data, dataType, seg } = info;
        if (!pad) return;
        
        const li = Math.floor((x - pad.l) / cw), oi = Math.floor((y - pad.t) / ch), ovl = omin + oi;
        if (li >= 0 && li < numLens && oi >= 0 && ovl <= omax) {
            const isAgg = li === numLens - 1;
            const key = isAgg ? 'all' : (qmin + li);
            const v = data[key]?.[ovl] || 0;
            document.getElementById('ovl-hm-info').textContent = `${seg === 'all' ? 'All' : seg} | Query: ${isAgg ? `${qmin}-${qmax}` : key}nt | Overlap: ${ovl}nt | ${v.toFixed(4)}`;
        }
    }
    
    drawOvl4Panel(ctx, w, h, ovlData, omin, omax, font, fontSize, labelSize, qmin, qmax, tmin, tmax, seg) {
        // 4-panel layout: 2x2 grid
        // Top-left: Number of pairs (bar chart)
        // Top-right: Number of pairs z-scores (line chart)
        // Bottom-left: Overlap probabilities (bar chart)
        // Bottom-right: Overlap probability z-scores (line chart)
        
        // Get aesthetic settings from UI
        const titleSize = +document.getElementById('ovl-title-size')?.value || 11;
        const titleBold = document.getElementById('ovl-title-bold')?.checked !== false;
        const showBorder = document.getElementById('ovl-show-border')?.checked || false;
        const show10Line = document.getElementById('ovl-show-10line')?.checked || false;
        const showSubtitles = document.getElementById('ovl-show-subtitles')?.checked !== false;
        const xOff = +document.getElementById('ovl-xoff')?.value || 0;
        const yOff = +document.getElementById('ovl-yoff')?.value || 0;
        const panelW = +document.getElementById('ovl-panel-w')?.value || 0;
        const panelH = +document.getElementById('ovl-panel-h')?.value || 0;
        
        // Draw title with query/target ranges
        ctx.fillStyle = '#000';
        ctx.font = `${titleBold ? 'bold ' : ''}${titleSize + 2}px ${font}`;
        ctx.textAlign = 'center';
        ctx.fillText(`Overlap Signatures of ${qmin}-${qmax} against ${tmin}-${tmax}nt small RNAs`, w / 2, 15);
        
        const titleOffset = 25;
        const gap = 15;
        const pw = panelW > 0 ? panelW : (w - gap * 3) / 2;
        const ph = panelH > 0 ? panelH : (h - titleOffset - gap * 3) / 2;
        const panels = [
            { x: gap, y: titleOffset + gap, title: 'Number of pairs', data: 'counts', type: 'bar' },
            { x: gap * 2 + pw, y: titleOffset + gap, title: 'Number of pairs z-scores', data: 'countZscores', type: 'line' },
            { x: gap, y: titleOffset + gap * 2 + ph, title: 'Overlap probabilities', data: 'probs', type: 'bar' },
            { x: gap * 2 + pw, y: titleOffset + gap * 2 + ph, title: 'Overlap probability z-scores', data: 'probZscores', type: 'line' }
        ];
        
        // Data is now object-based (keyed by overlap value, not array index)
        const allCounts = ovlData.counts?.['all'] || {};
        const allProbs = ovlData.probs?.['all'] || {};
        const allCountZ = ovlData.countZscores?.['all'] || {};
        const allProbZ = ovlData.probZscores?.['all'] || {};
        
        // Check if we have data
        if (Object.keys(allCounts).length === 0) {
            ctx.fillStyle = '#999';
            ctx.font = `${fontSize}px ${font}`;
            ctx.fillText('No overlap data available. Click "Recalculate" to compute.', w / 2, h / 2);
            return;
        }
        
        // Check if we should normalize to RPM
        const normalizeRPM = document.getElementById('ovl-normalize-rpm')?.checked || false;
        
        // Get per-replicate library sizes for proper RPM normalization
        const repLibSizes = this.M.replicates.map(rep => rep.stats?.total || 1);
        
        // Extract data for valid overlap range as array
        // When RPM normalizing counts: apply per-replicate scaling then average
        const getData = (key) => {
            if (key === 'counts' && normalizeRPM) {
                // For counts with RPM: scale each replicate by its library size, then average
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                    if (perRepVals.length > 0) {
                        // Scale each replicate's count by 1e6 / that replicate's library size
                        const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                        arr.push(scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length);
                    } else {
                        arr.push(allCounts[o] || 0);
                    }
                }
                return arr;
            }
            const obj = key === 'counts' ? allCounts : 
                       key === 'probs' ? allProbs :
                       key === 'countZscores' ? allCountZ : 
                       key === 'probZscores' ? allProbZ : allProbZ;
            
            const arr = [];
            for (let o = omin; o <= omax; o++) {
                arr.push(obj[o] || 0);
            }
            return arr;
        };
        
        // Get Y-max settings from UI
        const yMaxCounts = +document.getElementById('ovl-ymax-counts')?.value || 0;
        const yMaxProbs = +document.getElementById('ovl-ymax-probs')?.value || 0;
        const yMaxZ = +document.getElementById('ovl-ymax-z')?.value || 0;
        
        // Helper for better auto Y-max calculation
        // Now accepts optional error data to ensure error bars fit
        const autoYMax = (data, semData, isProb = false) => {
            const validData = data.filter(v => !isNaN(v) && isFinite(v) && v > 0);
            if (validData.length === 0) return isProb ? 1 : 100;
            
            // Find max including error bars
            let maxVal = 0;
            for (let i = 0; i < data.length; i++) {
                const val = data[i] || 0;
                const err = semData ? (semData[i] || 0) : 0;
                maxVal = Math.max(maxVal, val + err);
            }
            if (maxVal <= 0) return isProb ? 1 : 100;
            
            // Add 15% headroom
            const withHeadroom = maxVal * 1.15;
            
            if (isProb) {
                // For probabilities (typically 0-10%), use sensible steps
                if (withHeadroom <= 0.05) return 0.05;
                if (withHeadroom <= 0.1) return 0.1;
                if (withHeadroom <= 0.2) return 0.2;
                if (withHeadroom <= 0.5) return 0.5;
                if (withHeadroom <= 1) return 1;
                if (withHeadroom <= 2) return 2;
                if (withHeadroom <= 5) return 5;
                if (withHeadroom <= 10) return 10;
                return Math.ceil(withHeadroom / 5) * 5;
            } else {
                // For counts, round to nice numbers
                const magnitude = Math.pow(10, Math.floor(Math.log10(withHeadroom)));
                const normalized = withHeadroom / magnitude;
                let nice;
                if (normalized <= 1.2) nice = 1;
                else if (normalized <= 2.5) nice = 2.5;
                else if (normalized <= 5) nice = 5;
                else nice = 10;
                return nice * magnitude;
            }
        };
        
        // Get SEM data for error bar consideration
        const getSEMForPanel = (key) => {
            if (!ovlData.sem?.[key]?.['all']) return null;
            if (key === 'counts' && normalizeRPM) {
                // Recalculate SEM from RPM-scaled per-replicate values
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                    if (perRepVals.length > 1) {
                        const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                        const mean = scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length;
                        const variance = scaledVals.reduce((a, v) => a + (v - mean) ** 2, 0) / scaledVals.length;
                        arr.push(Math.sqrt(variance / scaledVals.length));
                    } else {
                        arr.push(0);
                    }
                }
                return arr;
            }
            const arr = [];
            for (let o = omin; o <= omax; o++) {
                arr.push(ovlData.sem[key]['all'][o] || 0);
            }
            return arr;
        };
        
        for (const panel of panels) {
            const data = getData(panel.data);
            const semDataForYMax = getSEMForPanel(panel.data);
            const pad = { t: 25, r: 10, b: 35 + yOff, l: 50 + xOff };
            const plotW = pw - pad.l - pad.r;
            const plotH = ph - pad.t - pad.b;
            const x0 = panel.x + pad.l;
            const y0 = panel.y + pad.t;
            
            // For z-scores, center around 0
            const isZscore = panel.data.includes('Zscore');
            let minV, maxV;
            
            if (isZscore) {
                // Use user Y-max or auto
                if (yMaxZ > 0) {
                    maxV = yMaxZ;
                    minV = -yMaxZ;
                } else {
                    // Find max including error bars
                    let absMax = 1;
                    for (let i = 0; i < data.length; i++) {
                        const val = data[i] || 0;
                        const err = semDataForYMax ? (semDataForYMax[i] || 0) : 0;
                        absMax = Math.max(absMax, Math.abs(val) + err, Math.abs(val - err));
                    }
                    // Round to nice value with headroom
                    const withHeadroom = absMax * 1.2;
                    maxV = withHeadroom <= 2 ? 2 : withHeadroom <= 5 ? 5 : Math.ceil(withHeadroom);
                    minV = -maxV;
                }
            } else if (panel.data === 'counts') {
                minV = 0;
                maxV = yMaxCounts > 0 ? yMaxCounts : autoYMax(data, semDataForYMax, false);
            } else if (panel.data === 'probs') {
                minV = 0;
                maxV = yMaxProbs > 0 ? yMaxProbs : autoYMax(data, semDataForYMax, true);
            } else {
                minV = 0;
                maxV = autoYMax(data, semDataForYMax, false);
            }
            
            // Draw panel background (white, no border by default)
            ctx.fillStyle = '#fff';
            ctx.fillRect(panel.x, panel.y, pw, ph);
            if (showBorder) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(panel.x, panel.y, pw, ph);
            }
            
            // Draw title (subtitle)
            if (showSubtitles) {
                ctx.fillStyle = '#000';
                ctx.font = `${titleBold ? 'bold ' : ''}${titleSize}px ${font}`;
                ctx.textAlign = 'center';
                ctx.fillText(panel.title, panel.x + pw / 2, panel.y + 15);
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            // Y-axis
            ctx.moveTo(x0, y0);
            ctx.lineTo(x0, y0 + plotH);
            
            // X-axis (at y=0 for z-scores, at bottom otherwise)
            const xAxisY = isZscore ? y0 + plotH * (maxV / (maxV - minV)) : y0 + plotH;
            ctx.moveTo(x0, xAxisY);
            ctx.lineTo(x0 + plotW, xAxisY);
            ctx.stroke();
            
            // Draw Y-axis labels using nice ticks
            ctx.fillStyle = '#000';
            ctx.font = `${fontSize - 1}px ${font}`;
            ctx.textAlign = 'right';
            
            // Generate nice tick values
            const yTickCounts = +document.getElementById('ovl-ytick-counts')?.value || 0;
            const yTickProbs = +document.getElementById('ovl-ytick-probs')?.value || 0;
            const yTickZ = +document.getElementById('ovl-ytick-z')?.value || 0;
            
            let yTickValues = [];
            if (isZscore) {
                // For z-scores: symmetric ticks around 0
                const step = yTickZ > 0 ? yTickZ : (maxV <= 2 ? 1 : maxV <= 5 ? 1 : 2);
                for (let v = -maxV; v <= maxV; v += step) {
                    yTickValues.push(v);
                }
                // Ensure maxV is included
                if (yTickValues[yTickValues.length - 1] < maxV) yTickValues.push(maxV);
            } else if (panel.data === 'probs') {
                // For probabilities: use custom or appropriate decimal steps
                let step;
                if (yTickProbs > 0) {
                    step = yTickProbs;
                } else {
                    if (maxV <= 0.1) step = 0.02;
                    else if (maxV <= 0.5) step = 0.1;
                    else if (maxV <= 1) step = 0.2;
                    else if (maxV <= 2) step = 0.5;
                    else if (maxV <= 5) step = 1;
                    else step = Math.ceil(maxV / 5);
                }
                for (let v = 0; v <= maxV + step * 0.1; v += step) {
                    if (v <= maxV * 1.05) yTickValues.push(Math.round(v * 1000) / 1000);
                }
                // Ensure maxV is included
                if (yTickValues.length > 0 && yTickValues[yTickValues.length - 1] < maxV) yTickValues.push(maxV);
            } else {
                // For counts: use custom step, or calculate nice step
                let step;
                if (yTickCounts > 0) {
                    step = yTickCounts;
                } else {
                    // Use 4-5 ticks and nice step values
                    step = this.niceNum(maxV / 4, true);
                }
                // Generate ticks starting from 0 using nice step
                for (let v = 0; v <= maxV * 1.05; v += step) {
                    yTickValues.push(Math.round(v));
                }
            }
            
            for (const v of yTickValues) {
                const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                
                // Tick mark
                ctx.beginPath();
                ctx.moveTo(x0 - 3, y);
                ctx.lineTo(x0, y);
                ctx.stroke();
                
                // Label
                let label;
                if (panel.data === 'probs') {
                    label = v.toFixed(v < 0.1 ? 2 : 1);
                } else if (isZscore) {
                    label = v.toFixed(1);
                } else {
                    label = this.fmtNum(v);
                }
                ctx.fillText(label, x0 - 5, y + 3);
            }
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            const numBars = omax - omin + 1;
            const barW = plotW / numBars;
            
            for (let i = 0; i < numBars; i += 2) {
                const ovl = omin + i;
                const x = x0 + (i + 0.5) * barW;
                ctx.fillText(ovl.toString(), x, y0 + plotH + 12);
            }
            
            // X-axis label
            ctx.font = `${fontSize}px ${font}`;
            ctx.fillText('overlap (nt)', panel.x + pw / 2, panel.y + ph - 5);
            
            // Y-axis label
            ctx.save();
            ctx.translate(panel.x + 10, panel.y + ph / 2);
            ctx.rotate(-Math.PI / 2);
            const yLabel = panel.data === 'counts' ? (normalizeRPM ? 'Pairs per million' : 'Numbers of pairs') :
                          panel.data === 'probs' ? 'Probability [%]' : 'z-score';
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
            
            // Draw data
            const showErr = document.getElementById('ovl-err')?.checked && ovlData.sem;
            const showPts = document.getElementById('ovl-pts')?.checked && ovlData.perRep;
            
            // Get error/points data if available
            const getSEM = (key) => {
                if (!ovlData.sem?.[key]?.['all']) return null;
                if (key === 'counts' && normalizeRPM) {
                    // Recalculate SEM from RPM-scaled per-replicate values
                    const arr = [];
                    for (let o = omin; o <= omax; o++) {
                        const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                        if (perRepVals.length > 1) {
                            const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                            const mean = scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length;
                            const variance = scaledVals.reduce((a, v) => a + (v - mean) ** 2, 0) / scaledVals.length;
                            arr.push(Math.sqrt(variance / scaledVals.length));
                        } else {
                            arr.push(0);
                        }
                    }
                    return arr;
                }
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    arr.push(ovlData.sem[key]['all'][o] || 0);
                }
                return arr;
            };
            const getPerRep = (key) => {
                if (!ovlData.perRep?.[key]?.['all']) return null;
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const repVals = ovlData.perRep[key]['all'][o] || [];
                    // Apply per-replicate RPM scaling for counts
                    if (key === 'counts' && normalizeRPM) {
                        arr.push(repVals.map((v, ri) => v * 1e6 / repLibSizes[ri]));
                    } else {
                        arr.push(repVals);
                    }
                }
                return arr;
            };
            
            const semData = getSEM(panel.data);
            const perRepData = getPerRep(panel.data);
            
            if (panel.type === 'bar') {
                // Draw box-whisker plots instead of bars when we have replicate data
                if (perRepData && perRepData[0]?.length > 1) {
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals || repVals.length === 0) continue;
                        
                        // Sort values for quartile calculation
                        const sorted = [...repVals].filter(v => !isNaN(v)).sort((a, b) => a - b);
                        if (sorted.length === 0) continue;
                        
                        const n = sorted.length;
                        const min = sorted[0];
                        const max = sorted[n - 1];
                        const median = n % 2 === 0 ? (sorted[n/2 - 1] + sorted[n/2]) / 2 : sorted[Math.floor(n/2)];
                        const q1 = sorted[Math.floor(n * 0.25)];
                        const q3 = sorted[Math.floor(n * 0.75)];
                        const mean = repVals.reduce((a, b) => a + b, 0) / n;
                        
                        const x = x0 + (i + 0.5) * barW;
                        const boxW = barW * 0.6;
                        
                        // Convert to Y coordinates
                        const yMin = y0 + plotH - ((min - minV) / (maxV - minV)) * plotH;
                        const yMax = y0 + plotH - ((max - minV) / (maxV - minV)) * plotH;
                        const yMedian = y0 + plotH - ((median - minV) / (maxV - minV)) * plotH;
                        const yQ1 = y0 + plotH - ((q1 - minV) / (maxV - minV)) * plotH;
                        const yQ3 = y0 + plotH - ((q3 - minV) / (maxV - minV)) * plotH;
                        const yMean = y0 + plotH - ((mean - minV) / (maxV - minV)) * plotH;
                        
                        // Draw whiskers (min to Q1, Q3 to max)
                        ctx.strokeStyle = '#4a5568';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        // Lower whisker
                        ctx.moveTo(x, yQ1);
                        ctx.lineTo(x, yMin);
                        ctx.moveTo(x - boxW/4, yMin);
                        ctx.lineTo(x + boxW/4, yMin);
                        // Upper whisker
                        ctx.moveTo(x, yQ3);
                        ctx.lineTo(x, yMax);
                        ctx.moveTo(x - boxW/4, yMax);
                        ctx.lineTo(x + boxW/4, yMax);
                        ctx.stroke();
                        
                        // Draw box (Q1 to Q3)
                        ctx.fillStyle = 'rgba(74, 85, 104, 0.3)';
                        ctx.fillRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        ctx.strokeStyle = '#4a5568';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        
                        // Draw median line
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x - boxW/2, yMedian);
                        ctx.lineTo(x + boxW/2, yMedian);
                        ctx.stroke();
                        
                        // Draw individual points
                        if (showPts) {
                            for (let ri = 0; ri < repVals.length; ri++) {
                                const v = repVals[ri];
                                if (isNaN(v)) continue;
                                const jitter = (Math.random() - 0.5) * boxW * 0.6;
                                const ptX = x + jitter;
                                const ptY = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                                ctx.fillStyle = 'rgba(37, 99, 235, 0.7)';
                                ctx.beginPath();
                                ctx.arc(ptX, ptY, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                } else {
                    // Fallback to simple bars for single replicate
                    ctx.fillStyle = '#4a5568';
                    for (let i = 0; i < data.length; i++) {
                        const v = data[i];
                        if (isNaN(v) || v === 0) continue;
                        const barX = x0 + i * barW + barW * 0.15;
                        const barWidth = barW * 0.7;
                        const barH = ((v - minV) / (maxV - minV)) * plotH;
                        ctx.fillRect(barX, y0 + plotH - barH, barWidth, barH);
                    }
                    
                    // Draw error bars if available
                    if (showErr && semData) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1.5;
                        for (let i = 0; i < data.length; i++) {
                            const v = data[i];
                            const err = semData[i] || 0;
                            if (isNaN(v) || err === 0) continue;
                            const x = x0 + (i + 0.5) * barW;
                            const yTop = y0 + plotH - (((v + err) - minV) / (maxV - minV)) * plotH;
                            const yBot = y0 + plotH - (((v - err) - minV) / (maxV - minV)) * plotH;
                            ctx.beginPath();
                            ctx.moveTo(x, yTop);
                            ctx.lineTo(x, yBot);
                            ctx.moveTo(x - 3, yTop);
                            ctx.lineTo(x + 3, yTop);
                            ctx.moveTo(x - 3, yBot);
                            ctx.lineTo(x + 3, yBot);
                            ctx.stroke();
                        }
                    }
                }
            } else {
                // Line chart - draw error ribbon first
                if (showErr && semData) {
                    ctx.fillStyle = 'rgba(37, 99, 235, 0.15)';
                    ctx.beginPath();
                    let started = false;
                    for (let i = 0; i < data.length; i++) {
                        const v = data[i];
                        const err = semData[i] || 0;
                        if (isNaN(v)) continue;
                        const x = x0 + (i + 0.5) * barW;
                        const yTop = y0 + plotH - (((v + err) - minV) / (maxV - minV)) * plotH;
                        if (!started) { ctx.moveTo(x, yTop); started = true; }
                        else ctx.lineTo(x, yTop);
                    }
                    for (let i = data.length - 1; i >= 0; i--) {
                        const v = data[i];
                        const err = semData[i] || 0;
                        if (isNaN(v)) continue;
                        const x = x0 + (i + 0.5) * barW;
                        const yBot = y0 + plotH - (((v - err) - minV) / (maxV - minV)) * plotH;
                        ctx.lineTo(x, yBot);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw individual replicate points
                if (showPts && perRepData) {
                    const nReps = perRepData[0]?.length || 0;
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals) continue;
                        for (let ri = 0; ri < repVals.length; ri++) {
                            const v = repVals[ri];
                            if (isNaN(v)) continue;
                            const x = x0 + (i + 0.5) * barW;
                            const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                            ctx.fillStyle = 'rgba(37, 99, 235, 0.3)';
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // Main line
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                let started = false;
                for (let i = 0; i < data.length; i++) {
                    const v = data[i];
                    if (isNaN(v)) continue;
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                    if (!started) { ctx.moveTo(x, y); started = true; }
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw mean points
                ctx.fillStyle = '#2563eb';
                for (let i = 0; i < data.length; i++) {
                    const v = data[i];
                    if (isNaN(v)) continue;
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw zero line for z-scores
                if (isZscore) {
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    const zeroY = y0 + plotH - ((0 - minV) / (maxV - minV)) * plotH;
                    ctx.moveTo(x0, zeroY);
                    ctx.lineTo(x0 + plotW, zeroY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Draw vertical zero line if range includes 0 (boundary between overlap and gap)
            if (omin < 0 && omax > 0) {
                const zeroIdx = 0 - omin;
                const x = x0 + (zeroIdx + 0.5) * barW;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(x, y0);
                ctx.lineTo(x, y0 + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Highlight 10nt overlap if in range (ping-pong signature) - only if enabled
            if (show10Line && omin <= 10 && 10 <= omax) {
                const idx = 10 - omin;
                const x = x0 + (idx + 0.5) * barW;
                ctx.strokeStyle = 'rgba(220, 38, 38, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(x, y0);
                ctx.lineTo(x, y0 + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Store info for hover - include panel positions and data with correct padding
        const padForHover = { t: 25, r: 10, b: 35 + yOff, l: 50 + xOff };
        this.plotInfo.ovl = { 
            viewType: '4panel', 
            seg, omin, omax, qmin, qmax,
            panels: panels.map(p => ({
                x: p.x, y: p.y, w: pw, h: ph,
                pad: padForHover,
                title: p.title,
                data: p.data
            })),
            allCounts, allProbs, allCountZ, allProbZ,
            titleOffset, gap, pw, ph
        };
    }
    
    drawOvlHeatmapPanel(ctx, w, h, ovlData, omin, omax, qmin, qmax, font, fontSize, labelSize, dataType, seg) {
        // Get tmin/tmax for title
        const tmin = this.ovlSettings?.tmin || qmin;
        const tmax = this.ovlSettings?.tmax || qmax;
        
        // Get color scheme and custom range from heatmap-specific UI controls
        const colorScheme = document.getElementById('ovl-hm-colors')?.value || 'blue-red';
        const customZmin = document.getElementById('ovl-hm-zmin')?.value;
        const customZmax = document.getElementById('ovl-hm-zmax')?.value;
        
        // Draw title
        ctx.fillStyle = '#000';
        ctx.font = `bold ${fontSize + 1}px ${font}`;
        ctx.textAlign = 'center';
        ctx.fillText(`Overlap Heatmap: ${qmin}-${qmax}nt (+) vs ${tmin}-${tmax}nt (‚àí)`, w / 2, 15);
        
        const titleOffset = 20;
        const pad = { t: titleOffset + 25, r: 55, b: 45, l: 45 }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        
        const numLens = qmax - qmin + 2; // +1 for 'all' column
        const numOvls = omax - omin + 1;
        const cw = pw / numLens, ch = ph / numOvls;
        let data;
        // Support new data type options: pz = probability z-score, cz = count z-score
        if (dataType === 'pz' || dataType === 'z') data = ovlData.probZscores;
        else if (dataType === 'cz') data = ovlData.countZscores;
        else if (dataType === 'p') data = ovlData.probs;
        else data = ovlData.counts;
        
        let minV = Infinity, maxV = -Infinity;
        for (let qlen = qmin; qlen <= qmax; qlen++) {
            for (let ovl = omin; ovl <= omax; ovl++) {
                const v = data[qlen]?.[ovl] || 0;
                if (v !== 0) { minV = Math.min(minV, v); maxV = Math.max(maxV, v); }
            }
        }
        for (let ovl = omin; ovl <= omax; ovl++) {
            const v = data['all']?.[ovl] || 0;
            if (v !== 0) { minV = Math.min(minV, v); maxV = Math.max(maxV, v); }
        }
        if (minV === Infinity) minV = 0;
        if (maxV === -Infinity) maxV = 1;
        
        // Apply custom min/max if set
        if (customZmin !== '' && !isNaN(+customZmin)) minV = +customZmin;
        if (customZmax !== '' && !isNaN(+customZmax)) maxV = +customZmax;
        
        // Color palette functions
        const colorPalettes = {
            'blue-red': (n, isZ) => {
                if (isZ) {
                    // Blue to Pink (via white at 0)
                    if (n < 0) { 
                        // Negative: white to cyan-blue
                        const t = Math.min(-n, 1); 
                        return `rgb(${Math.round(255 * (1 - t))},${Math.round(255 * (1 - t * 0.5))},255)`; 
                    } else { 
                        // Positive: white to pink/magenta
                        const t = Math.min(n, 1); 
                        return `rgb(255,${Math.round(255 * (1 - t * 0.8))},${Math.round(255 * (1 - t * 0.4))})`; 
                    }
                } else {
                    return `rgb(255,${Math.round(255 * (1 - n * 0.8))},${Math.round(255 * (1 - n * 0.4))})`;
                }
            },
            'viridis': (n, isZ) => {
                // Viridis: lowest (#46085B) -> zero (#472F7D) -> mid-positive (#27808E) -> top (#FCE724)
                // n ranges from -1 (lowest) to 1 (highest), with 0 at zero/neutral
                if (isZ) {
                    // For z-scores: map -1 to 1 range
                    if (n <= 0) {
                        // Negative: interpolate from #46085B (n=-1) to #472F7D (n=0)
                        const t = (n + 1); // 0 to 1 as n goes from -1 to 0
                        const r = Math.round(70 + t * (71 - 70));   // 46->47 hex = 70->71
                        const g = Math.round(8 + t * (47 - 8));      // 08->2F hex = 8->47
                        const b = Math.round(91 + t * (125 - 91));   // 5B->7D hex = 91->125
                        return `rgb(${r},${g},${b})`;
                    } else if (n <= 0.5) {
                        // Low positive: interpolate from #472F7D (n=0) to #27808E (n=0.5)
                        const t = n * 2; // 0 to 1 as n goes from 0 to 0.5
                        const r = Math.round(71 + t * (39 - 71));    // 47->27 hex = 71->39
                        const g = Math.round(47 + t * (128 - 47));   // 2F->80 hex = 47->128
                        const b = Math.round(125 + t * (142 - 125)); // 7D->8E hex = 125->142
                        return `rgb(${r},${g},${b})`;
                    } else {
                        // High positive: interpolate from #27808E (n=0.5) to #FCE724 (n=1)
                        const t = (n - 0.5) * 2; // 0 to 1 as n goes from 0.5 to 1
                        const r = Math.round(39 + t * (252 - 39));   // 27->FC hex = 39->252
                        const g = Math.round(128 + t * (231 - 128)); // 80->E7 hex = 128->231
                        const b = Math.round(142 + t * (36 - 142));  // 8E->24 hex = 142->36
                        return `rgb(${r},${g},${b})`;
                    }
                } else {
                    // Non-z-score: map 0 to 1 range (lowest to highest)
                    if (n <= 0.33) {
                        const t = n * 3;
                        const r = Math.round(70 + t * (39 - 70));
                        const g = Math.round(8 + t * (128 - 8));
                        const b = Math.round(91 + t * (142 - 91));
                        return `rgb(${r},${g},${b})`;
                    } else {
                        const t = (n - 0.33) * 1.5;
                        const r = Math.round(39 + t * (252 - 39));
                        const g = Math.round(128 + t * (231 - 128));
                        const b = Math.round(142 + t * (36 - 142));
                        return `rgb(${r},${g},${b})`;
                    }
                }
            },
            'plasma': (n) => {
                const t = Math.max(0, Math.min(1, (n + 1) / 2));
                if (t < 0.33) { const s = t * 3; return `rgb(${Math.round(13 + s * 110)},${Math.round(8 + s * 0)},${Math.round(135 + s * 80)})`; }
                else if (t < 0.66) { const s = (t - 0.33) * 3; return `rgb(${Math.round(123 + s * 117)},${Math.round(8 + s * 65)},${Math.round(215 - s * 130)})`; }
                else { const s = (t - 0.66) * 3; return `rgb(${Math.round(240 + s * 15)},${Math.round(73 + s * 175)},${Math.round(85 - s * 67)})`; }
            },
            'cool-warm': (n, isZ) => {
                if (isZ) {
                    if (n < 0) { const t = Math.min(-n, 1); return `rgb(${Math.round(100 + 155 * (1-t))},${Math.round(149 + 106 * (1-t))},${Math.round(237 + 18 * (1-t))})`; }
                    else { const t = Math.min(n, 1); return `rgb(${Math.round(255)},${Math.round(255 * (1-t))},${Math.round(255 * (1-t))})`; }
                } else {
                    return `rgb(255,${Math.round(255 * (1-n))},${Math.round(255 * (1-n))})`;
                }
            }
        };
        
        const getCol = v => {
            const palette = colorPalettes[colorScheme] || colorPalettes['blue-red'];
            // z-score coloring for both pz (probability) and cz (count) z-scores
            if (dataType === 'pz' || dataType === 'cz' || dataType === 'z') {
                // For z-scores with custom range, map value to -1 to 1 based on actual min/max
                // If minV < 0 and maxV > 0, map proportionally
                // 0 should always map to n=0 (white/neutral)
                let n;
                if (v >= 0) {
                    // Positive values: map 0 to maxV -> 0 to 1
                    n = maxV > 0 ? Math.min(v / maxV, 1) : 0;
                } else {
                    // Negative values: map minV to 0 -> -1 to 0
                    n = minV < 0 ? Math.max(v / Math.abs(minV), -1) : 0;
                }
                return palette(n, true);
            } else {
                const n = maxV > 0 ? Math.min(v / maxV, 1) : 0;
                return palette(n, false);
            }
        };
        
        this.plotInfo.ovlHm = { viewType: 'heatmap', pad, cw, ch, qmin, qmax, omin, omax, numLens, data, dataType, seg };
        
        // Draw heatmap cells for each query length
        for (let li = 0; li < numLens - 1; li++) {
            const qlen = qmin + li;
            for (let oi = 0; oi < numOvls; oi++) {
                const ovl = omin + oi;
                // For positive overlaps, skip if overlap > query length (physically impossible)
                // For negative overlaps (gaps), always show
                if (ovl > 0 && ovl > qlen) continue;
                const v = data[qlen]?.[ovl] || 0;
                ctx.fillStyle = getCol(v);
                ctx.fillRect(pad.l + li * cw + 0.5, pad.t + oi * ch + 0.5, cw - 1, ch - 1);
            }
        }
        for (let oi = 0; oi < numOvls; oi++) {
            const ovl = omin + oi;
            const v = data['all']?.[ovl] || 0;
            ctx.fillStyle = getCol(v);
            ctx.fillRect(pad.l + (numLens - 1) * cw + 0.5, pad.t + oi * ch + 0.5, cw - 1, ch - 1);
        }
        
        // Draw zero line if range includes 0
        if (omin <= 0 && omax >= 0) {
            const zeroOi = 0 - omin;
            const zeroY = pad.t + (zeroOi + 0.5) * ch;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.moveTo(pad.l, zeroY);
            ctx.lineTo(pad.l + pw, zeroY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        ctx.fillStyle = '#000'; ctx.font = `${fontSize}px ${font}`; ctx.textAlign = 'center';
        const hmXtick = +document.getElementById('ovl-hm-xtick')?.value || 1;
        for (let qlen = qmin; qlen <= qmax; qlen += hmXtick) ctx.fillText(qlen.toString(), pad.l + (qlen - qmin + 0.5) * cw, h - pad.b + 12);
        ctx.fillText(`${qmin}-${qmax}`, pad.l + (numLens - 0.5) * cw, h - pad.b + 12);
        ctx.textAlign = 'right';
        for (let ovl = omin; ovl <= omax; ovl += hmXtick) ctx.fillText(ovl.toString(), pad.l - 5, pad.t + (ovl - omin + 0.5) * ch + 3);
        ctx.font = `${labelSize}px ${font}`; ctx.textAlign = 'center';
        ctx.fillText('Query length (nt)', w / 2, h - 5);
        ctx.save(); ctx.translate(12, h / 2); ctx.rotate(-Math.PI / 2); ctx.fillText('Overlap (nt)', 0, 0); ctx.restore();
        
        // Legend
        const lx = w - pad.r + 10, ly = pad.t, lh = ph, lw = 12;
        const grad = ctx.createLinearGradient(0, ly, 0, ly + lh);
        const palette = colorPalettes[colorScheme] || colorPalettes['blue-red'];
        
        // Use the selected color scheme for the legend
        const isZscoreType = dataType === 'pz' || dataType === 'cz' || dataType === 'z';
        if (isZscoreType) {
            // Z-scores: calculate where 0 falls in the gradient
            // Map: top=maxV, bottom=minV
            const range = maxV - minV;
            const zeroPos = range > 0 ? (maxV - 0) / range : 0.5; // Position of 0 from top (0=top, 1=bottom)
            
            grad.addColorStop(0, palette(1, true)); // positive max (top)
            grad.addColorStop(Math.max(0.01, Math.min(0.99, zeroPos)), palette(0, true)); // zero
            grad.addColorStop(1, palette(-1, true)); // negative max (bottom)
        } else {
            // Non-z-scores: gradient from max to min
            grad.addColorStop(0, palette(1, false)); // max (top)
            grad.addColorStop(1, palette(0, false)); // min (bottom)
        }
        
        ctx.fillStyle = grad; ctx.fillRect(lx, ly, lw, lh);
        ctx.strokeStyle = '#ccc'; ctx.strokeRect(lx, ly, lw, lh);
        ctx.fillStyle = '#000'; ctx.font = '8px system-ui'; ctx.textAlign = 'left';
        if (isZscoreType) {
            ctx.fillText(maxV.toFixed(1), lx + lw + 3, ly + 6);
            // Draw 0 marker at its correct position if in range
            if (minV < 0 && maxV > 0) {
                const zeroY = ly + ((maxV - 0) / (maxV - minV)) * lh;
                ctx.fillText('0', lx + lw + 3, zeroY + 3);
            }
            ctx.fillText(minV.toFixed(1), lx + lw + 3, ly + lh - 2);
        }
        else { ctx.fillText(dataType === 'p' ? maxV.toFixed(3) : Math.round(maxV).toString(), lx + lw + 3, ly + 6); ctx.fillText('0', lx + lw + 3, ly + lh - 2); }
    }

    hoverCov(e) {
        if (!this.plotInfo.cov) return;
        const r = e.target.getBoundingClientRect(), x = e.clientX - r.left;
        const { pad, pw, bins, binSz, seg, refLen, fwdM, revM, rangeStart = 0 } = this.plotInfo.cov;
        if (x >= pad.l && x <= pad.l + pw) {
            const bi = Math.floor((x - pad.l) / pw * bins);
            if (bi >= 0 && bi < bins) {
                const pos = rangeStart + Math.floor(bi * binSz) + 1; // 1-based position
                document.getElementById('cov-info').textContent = `${seg}:${pos.toLocaleString()} | + ${fwdM[bi].toFixed(1)} | ‚àí ${revM[bi].toFixed(1)}`;
            }
        }
    }

    hoverLen(e) {
        if (!this.plotInfo.len) return;
        const r = e.target.getBoundingClientRect(), x = e.clientX - r.left, y = e.clientY - r.top;
        const { pad, midY, bw, bars } = this.plotInfo.len;
        for (const b of bars) {
            if (x >= b.x && x <= b.x + bw) {
                const strand = y < midY ? 'Forward' : 'Reverse';
                const total = y < midY ? b.fwdM : b.revM;
                document.getElementById('len-info').textContent = `${b.l}nt ${strand}: ${Math.round(total)} (mean)`;
                return;
            }
        }
    }

    hoverOvl(e) {
        if (!this.plotInfo.ovl) return;
        const { viewType } = this.plotInfo.ovl;
        const r = e.target.getBoundingClientRect(), x = e.clientX - r.left, y = e.clientY - r.top;
        
        if (viewType === '4panel') {
            const { panels, omin, omax, allCounts, allProbs, allCountZ, allProbZ, seg } = this.plotInfo.ovl;
            if (!panels) return;
            
            // Find which panel we're in
            for (const panel of panels) {
                const px = panel.x, py = panel.y, pw = panel.w, ph = panel.h;
                const pad = panel.pad;
                
                if (x >= px && x <= px + pw && y >= py && y <= py + ph) {
                    // We're in this panel - calculate which overlap we're over
                    const plotX = x - px - pad.l;
                    const plotW = pw - pad.l - pad.r;
                    const numBars = omax - omin + 1;
                    const barW = plotW / numBars;
                    const barIdx = Math.floor(plotX / barW);
                    
                    if (barIdx >= 0 && barIdx < numBars) {
                        const ovl = omin + barIdx;
                        
                        // Get the value for this overlap from the appropriate data source
                        let value;
                        if (panel.data === 'counts') value = allCounts[ovl] || 0;
                        else if (panel.data === 'probs') value = allProbs[ovl] || 0;
                        else if (panel.data === 'countZscores') value = allCountZ[ovl] || 0;
                        else value = allProbZ[ovl] || 0;
                        
                        const formattedValue = panel.data.includes('Zscore') ? value.toFixed(2) : 
                                              panel.data === 'probs' ? value.toFixed(4) : 
                                              Math.round(value).toString();
                        
                        document.getElementById('ovl-info').textContent = 
                            `${panel.title} | Overlap: ${ovl}nt | Value: ${formattedValue}`;
                        return;
                    }
                }
            }
            document.getElementById('ovl-info').textContent = 'Hover over a panel for details';
            return;
        }
        
        const { pad, cw, ch, qmin, qmax, omin, omax, numLens, data, dataType, seg } = this.plotInfo.ovl;
        
        if (!pad) return; // Safety check
        
        const li = Math.floor((x - pad.l) / cw), oi = Math.floor((y - pad.t) / ch), ovl = omin + oi;
        if (li >= 0 && li < numLens && oi >= 0 && ovl <= omax) {
            const isAgg = li === numLens - 1;
            const key = isAgg ? 'all' : (qmin + li);
            const v = data[key]?.[ovl] || 0;
            document.getElementById('ovl-info').textContent = `${seg === 'all' ? 'All' : seg} | Query: ${isAgg ? `${qmin}-${qmax}` : key}nt | Overlap: ${ovl}nt | ${v.toFixed(4)}`;
        }
    }

    hoverHist(e, endType) {
        const info = this.plotInfo[`hist${endType}`];
        if (!info) return;
        const r = e.target.getBoundingClientRect(), x = e.clientX - r.left;
        const { pad, bw, gap, bars, meanData, numL, minLen } = info;
        for (const b of bars) {
            if (x >= b.x && x <= b.x + bw) {
                const m = meanData[b.l];
                const total = m.A + m.C + m.G + m.T;
                document.getElementById(`hist${endType}-info`).textContent = 
                    `${b.l}nt: ${Math.round(total)} total | A:${Math.round(m.A)} C:${Math.round(m.C)} G:${Math.round(m.G)} T:${Math.round(m.T)}`;
                return;
            }
        }
    }

    expSVG(canvasId, name) {
        // Generate true vector SVG by re-rendering using SVGBuilder context
        // The key is to call the SAME draw function with SVGBuilder instead of canvas
        const canvas = document.getElementById(canvasId);
        const w = parseInt(canvas.style.width) || canvas.width;
        const h = parseInt(canvas.style.height) || canvas.height;
        
        if (!w || !h) {
            console.error('Canvas has no dimensions:', canvasId);
            alert('Cannot export SVG - canvas has no dimensions');
            return;
        }
        
        // Create SVGBuilder - a Canvas 2D API compatible SVG renderer
        const svg = new SVGBuilder(w, h);
        
        try {
            // Re-render using the SAME drawing logic that's used for canvas
            // SVGBuilder implements the full Canvas 2D API so this works seamlessly
            if (canvasId === 'hist5-canvas') {
                this.drawHistUnified(svg, '5');
            } else if (canvasId === 'hist3-canvas') {
                this.drawHistUnified(svg, '3');
            } else if (canvasId === 'cov-canvas') {
                this.drawCovUnified(svg);
            } else if (canvasId === 'len-canvas') {
                this.drawLenUnified(svg);
            } else if (canvasId === 'bias-canvas') {
                this.drawBiasUnified(svg);
            } else if (canvasId === 'ovl-canvas') {
                this.drawOvlUnified(svg);
            } else if (canvasId === 'ovl-hm-canvas') {
                this.drawOvlHeatmapUnified(svg);
            } else {
                throw new Error('Unknown canvas type: ' + canvasId);
            }
            
            // Finalize any gradient definitions
            if (typeof svg.currentState?.fill === 'object' && svg.currentState.fill?._finalize) {
                svg.currentState.fill._finalize();
            }
            
            const svgString = svg.toSVG();
            this.dl(svgString, `srnamap_${name}.svg`, 'image/svg+xml');
        } catch (err) {
            console.error('SVG export error:', err);
            console.error('Stack trace:', err.stack);
            alert('SVG export failed: ' + err.message + '\n\nPlease report this error. Check browser console (F12) for details.');
        }
    }
    
    // High-quality PNG export at 300 DPI
    expPNG(canvasId, name) {
        const canvas = document.getElementById(canvasId);
        const w = parseInt(canvas.style.width) || canvas.width;
        const h = parseInt(canvas.style.height) || canvas.height;
        
        // Calculate scale for 300 DPI (assuming 96 DPI screen)
        const scale = 4; // 4x scale = ~384 DPI equivalent
        
        const hiRes = document.createElement('canvas');
        hiRes.width = w * scale;
        hiRes.height = h * scale;
        const ctx = hiRes.getContext('2d');
        
        // Set white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, hiRes.width, hiRes.height);
        
        // Scale up and redraw using the same drawing functions
        ctx.scale(scale, scale);
        
        try {
            if (canvasId === 'hist5-canvas') {
                this.drawHistUnified(ctx, '5');
            } else if (canvasId === 'hist3-canvas') {
                this.drawHistUnified(ctx, '3');
            } else if (canvasId === 'cov-canvas') {
                this.drawCovUnified(ctx);
            } else if (canvasId === 'len-canvas') {
                this.drawLenUnified(ctx);
            } else if (canvasId === 'bias-canvas') {
                this.drawBiasUnified(ctx);
            } else if (canvasId === 'ovl-canvas') {
                this.drawOvlUnified(ctx);
            } else if (canvasId === 'ovl-hm-canvas') {
                this.drawOvlHeatmapUnified(ctx);
            } else {
                // Fallback: just scale the existing canvas
                ctx.drawImage(canvas, 0, 0, w, h);
            }
        } catch (err) {
            console.error('High-res redraw failed, using canvas copy:', err);
            ctx.drawImage(canvas, 0, 0, w, h);
        }
        
        // Convert to blob and download
        hiRes.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `srnamap_${name}.png`;
            a.click();
            URL.revokeObjectURL(url);
        }, 'image/png', 1.0);
    }
    
    // ==========================================================================
    // UNIFIED DRAWING FUNCTIONS - Work with both Canvas and SVGBuilder
    // These ensure SVG exports are 100% faithful to canvas rendering
    // ==========================================================================
    
    drawHistUnified(ctx, endType) {
        // Unified histogram drawing that works with both canvas and SVGBuilder
        const w = +document.getElementById(`hist${endType}-w`).value || 420;
        const h = +document.getElementById(`hist${endType}-h`).value || 220;
        const yMaxIn = +document.getElementById(`hist${endType}-ymax`).value || 0;
        const yTickIn = +document.getElementById(`hist${endType}-ytick`)?.value || 0;
        const capW = +document.getElementById(`hist${endType}-cap`).value || 4;
        const showErr = document.getElementById(`hist${endType}-err`).checked && this.M.replicates.length > 1;
        const showPts = document.getElementById(`hist${endType}-pts`)?.checked && this.M.replicates.length > 1;
        const showJitter = document.getElementById(`hist${endType}-jitter`)?.checked || false;
        const ptOpacity = +document.getElementById(`hist${endType}-pt-opacity`)?.value || 0.7;
        const dataType = document.getElementById(`hist${endType}-data`).value || 'counts';
        const colors = getNtColors();
        const errType = document.getElementById('err-type').value;
        const font = getFont();
        const fontSize = +document.getElementById(`hist${endType}-font`).value || 11;
        const xOff = +document.getElementById(`hist${endType}-xoff`)?.value || 0;
        const yOff = +document.getElementById(`hist${endType}-yoff`)?.value || 0;
        const xStart = +document.getElementById(`hist${endType}-xstart`)?.value || 18;
        const xTickInterval = +document.getElementById(`hist${endType}-xtick`)?.value || 2;
        const labelSize = fontSize + 1;
        const pad = { t: 25, r: 20, b: 40 + xOff, l: 55 + yOff }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        if (!this.M.replicates.length) return;
        const { minLen, maxLen } = this.M.settings;
        const numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        // Get per-replicate library sizes for proper CPM normalization
        const libSizes = reps.map(rep => rep.stats.total || 1);
        
        // Collect data - CRITICAL: For CPM, normalize EACH replicate by ITS OWN library size
        const dataByLen = {};
        for (let l = minLen; l <= maxLen; l++) {
            dataByLen[l] = { A: [], C: [], G: [], T: [], total: [] };
            for (let ri = 0; ri < reps.length; ri++) {
                const rep = reps[ri];
                const libLenDistKey = `libLenDist${endType}`;
                const libLenDist = rep[libLenDistKey];
                if (!libLenDist || !libLenDist[l]) {
                    for (const nt of 'ACGT') dataByLen[l][nt].push(0);
                    dataByLen[l].total.push(0);
                    continue;
                }
                const combined = libLenDist[l];
                const total = combined.A + combined.C + combined.G + combined.T;
                
                // Apply per-replicate normalization for CPM
                const repScale = dataType === 'cpm' ? 1e6 / libSizes[ri] : 1;
                for (const nt of 'ACGT') dataByLen[l][nt].push(combined[nt] * repScale);
                dataByLen[l].total.push(total * repScale);
            }
        }
        
        // For percentage, calculate grand total from mean of already-normalized values
        let grandTotal = 0;
        for (let l = minLen; l <= maxLen; l++) grandTotal += this.mean(dataByLen[l].total);
        
        // For percentage mode, apply percentage scaling
        if (dataType === 'pct') {
            const pctScale = 100 / (grandTotal || 1);
            for (let l = minLen; l <= maxLen; l++) {
                for (const nt of 'ACGT') {
                    dataByLen[l][nt] = dataByLen[l][nt].map(v => v * pctScale);
                }
                dataByLen[l].total = dataByLen[l].total.map(v => v * pctScale);
            }
        }
        
        // Calculate means and errors from properly normalized data
        const meanData = {}, errData = {}, rawData = {};
        let maxV = 0;
        for (let l = minLen; l <= maxLen; l++) {
            meanData[l] = {};
            errData[l] = {};
            rawData[l] = {};
            let stackTotal = 0;
            for (const nt of 'ACGT') {
                const vals = dataByLen[l][nt]; // Already normalized per-replicate
                rawData[l][nt] = vals;
                meanData[l][nt] = this.mean(vals);
                stackTotal += meanData[l][nt];
                if (errType === 'sem') errData[l][nt] = this.sem(vals);
                else if (errType === 'ci95') errData[l][nt] = this.sem(vals) * 1.96;
                else errData[l][nt] = this.std(vals);
            }
            // Calculate propagated error for stacked bars
            let totalErr = 0;
            for (const nt of 'ACGT') totalErr += errData[l][nt] ** 2;
            errData[l].total = Math.sqrt(totalErr);
            maxV = Math.max(maxV, stackTotal + (showErr ? errData[l].total : 0));
        }
        
        const maxWithMargin = maxV * 1.20;
        const niceMax = yMaxIn > 0 ? yMaxIn : this.niceNum(maxWithMargin) || 100;
        const yLabel = dataType === 'cpm' ? 'CPM' : dataType === 'pct' ? 'Percentage (%)' : 'Read count';
        
        // Draw axes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad.l, pad.t);
        ctx.lineTo(pad.l, h - pad.b);
        ctx.lineTo(w - pad.r, h - pad.b);
        ctx.stroke();
        
        // Y-axis ticks and labels
        ctx.fillStyle = '#000';
        ctx.font = `${fontSize}px ${font}`;
        ctx.textAlign = 'right';
        
        const yTickCount = 5;
        const yTickStep = yTickIn > 0 ? yTickIn : niceMax / yTickCount;
        for (let v = 0; v <= niceMax; v += yTickStep) {
            const y = h - pad.b - (v / niceMax) * ph;
            ctx.beginPath();
            ctx.moveTo(pad.l - 3, y);
            ctx.lineTo(pad.l, y);
            ctx.stroke();
            ctx.fillText(this.fmtNum(Math.round(v)), pad.l - 5, y + 3);
        }
        
        // Y-axis label
        ctx.save();
        ctx.translate(15, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();
        if (ctx.closeGroups) ctx.closeGroups();
        
        // X-axis ticks and labels
        ctx.textAlign = 'center';
        ctx.font = `${fontSize}px ${font}`;
        
        // Bar width from setting
        const barWidthPct = (+document.getElementById(`hist${endType}-barw`)?.value || 75) / 100;
        const slotW = pw / numL;
        const bw = slotW * barWidthPct;
        const gap = slotW * (1 - barWidthPct) / 2;
        
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen + 0.5) * slotW;
            if ((l - xStart) % xTickInterval === 0 && l >= xStart) {
                ctx.beginPath();
                ctx.moveTo(x, h - pad.b);
                ctx.lineTo(x, h - pad.b + 3);
                ctx.stroke();
                ctx.fillText(l.toString(), x, h - pad.b + 15);
            }
        }
        
        // X-axis label
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText('Read length', w / 2, h - 8);
        
        // Draw stacked bars
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * slotW + gap;
            let y = h - pad.b;
            for (const nt of 'ACGT') {
                const val = meanData[l][nt];
                const barH = (val / niceMax) * ph;
                ctx.fillStyle = colors[nt];
                ctx.fillRect(x, y - barH, bw, barH);
                y -= barH;
            }
        }
        
        // Draw error bars for each nucleotide at its stacked position
        if (showErr) {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            for (let l = minLen; l <= maxLen; l++) {
                const midX = pad.l + (l - minLen) * slotW + gap + bw / 2;
                let cumY = h - pad.b;
                for (const nt of 'ACGT') {
                    const mean = meanData[l][nt];
                    const barH = (mean / niceMax) * ph;
                    cumY -= barH;
                    const err = errData[l][nt];
                    const errH = (err / niceMax) * ph;
                    if (errH > 1 && mean > 0) {
                        // Draw error bar centered on top of this nucleotide's segment
                        const yCenter = cumY;
                        const yTop = yCenter - errH;
                        const yBot = yCenter + errH;
                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(midX, yTop);
                        ctx.lineTo(midX, yBot);
                        ctx.stroke();
                        // Top cap
                        ctx.beginPath();
                        ctx.moveTo(midX - capW, yTop);
                        ctx.lineTo(midX + capW, yTop);
                        ctx.stroke();
                        // Bottom cap
                        ctx.beginPath();
                        ctx.moveTo(midX - capW, yBot);
                        ctx.lineTo(midX + capW, yBot);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Draw individual points if enabled - COLORED by nucleotide with proper stacking
        if (showPts) {
            for (let l = minLen; l <= maxLen; l++) {
                const baseX = pad.l + (l - minLen) * slotW + gap;
                for (let ri = 0; ri < reps.length; ri++) {
                    let cumVal = 0;
                    for (const nt of 'ACGT') {
                        const val = rawData[l][nt][ri] || 0;
                        cumVal += val;
                        if (val <= 0) continue;
                        
                        // Point at cumulative height (top of this nucleotide's contribution)
                        const y = h - pad.b - (cumVal / niceMax) * ph;
                        
                        // Calculate x position with jitter or spread by nucleotide
                        let ptX;
                        if (showJitter) {
                            const jitter = ((ri * 7 + 'ACGT'.indexOf(nt) * 3) % 10) / 10 - 0.5;
                            ptX = baseX + bw / 2 + jitter * bw * 0.6;
                        } else {
                            const ntIdx = 'ACGT'.indexOf(nt);
                            const sectionW = bw / 4;
                            ptX = baseX + ntIdx * sectionW + sectionW * 0.2 + (ri / Math.max(1, reps.length - 1)) * sectionW * 0.6;
                        }
                        
                        // Use nucleotide color with opacity
                        ctx.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                        ctx.beginPath();
                        ctx.arc(ptX, y, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Draw legend
        const showLegend = document.getElementById(`hist${endType}-show-legend`)?.checked;
        if (showLegend) {
            const legendItems = [{label:'A',color:colors.A},{label:'C',color:colors.C},{label:'G',color:colors.G},{label:'T/U',color:colors.T}];
            const legFontSize = +document.getElementById(`hist${endType}-leg-font`)?.value || 12;
            const legPos = document.getElementById(`hist${endType}-leg-pos`)?.value || 'center';
            const legBold = document.getElementById(`hist${endType}-leg-bold`)?.checked;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            ctx.font = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            let totalWidth = legendItems.reduce((acc, item) => acc + boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap, 0) - itemGap;
            let lx = legPos === 'left' ? pad.l : legPos === 'right' ? w - pad.r - totalWidth : (w - totalWidth) / 2;
            const ly = 8;
            for (const item of legendItems) {
                ctx.fillStyle = item.color;
                ctx.fillRect(lx, ly, boxSize, boxSize);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(lx, ly, boxSize, boxSize);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap;
            }
        }
    }
    
    drawCovUnified(ctx) {
        // Unified coverage drawing - replicates exact canvas behavior
        const w = +document.getElementById('cov-w').value || 800;
        const h = +document.getElementById('cov-h').value || 250;
        const seg = document.getElementById('cov-seg').value;
        const dataType = document.getElementById('cov-data').value || 'raw';
        const font = getFont();
        const fontSize = +document.getElementById('cov-font').value || 10;
        const labelSize = fontSize + 1;
        const yMaxFwd = +document.getElementById('cov-ymax-fwd')?.value || 0;
        const yMaxRev = +document.getElementById('cov-ymax-rev')?.value || 0;
        const showZero = document.getElementById('cov-show-zero')?.checked !== false;
        const boldSetting = document.getElementById('cov-bold')?.value || '0';
        const showGrid = document.getElementById('cov-show-grid')?.checked || false;
        const symY = document.getElementById('cov-sym-y')?.checked || false;
        const rangeStart = +document.getElementById('cov-range-start')?.value || 0;
        const rangeEnd = +document.getElementById('cov-range-end')?.value || 0;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        if (!this.M.covFwd[seg]) return;
        
        const refLen = this.M.refs[seg]?.length || 0;
        const actualStart = rangeStart > 0 ? Math.max(0, rangeStart - 1) : 0;
        const actualEnd = rangeEnd > 0 ? Math.min(refLen, rangeEnd) : refLen;
        const viewLen = actualEnd - actualStart;
        
        const pad = { t: 20, r: 30, b: 35, l: 60 };
        const pw = w - pad.l - pad.r;
        const ph = h - pad.t - pad.b;
        const midY = pad.t + ph / 2;
        
        // Get coverage data for visible range
        const bins = Math.min(viewLen, pw);
        const binSz = viewLen / bins;
        const reps = this.M.replicates;
        const nReps = reps.length;
        
        // Calculate per-bin averages
        const fwdM = new Float32Array(bins);
        const revM = new Float32Array(bins);
        
        // Get library sizes for normalization
        const libSizes = reps.map(r => r.stats?.total || 1);
        const avgLibSize = libSizes.reduce((a, b) => a + b, 0) / nReps;
        
        for (let b = 0; b < bins; b++) {
            const start = actualStart + Math.floor(b * binSz);
            const end = actualStart + Math.floor((b + 1) * binSz);
            let fwdSum = 0, revSum = 0;
            
            for (const rep of reps) {
                const repIdx = reps.indexOf(rep);
                const scale = dataType === 'cpm' ? 1e6 / libSizes[repIdx] : dataType === 'rpkm' ? 1e9 / (libSizes[repIdx] * viewLen) : 1;
                let fS = 0, rS = 0;
                for (let i = start; i < end; i++) {
                    fS += (this.M.covFwd[seg][i] || 0);
                    rS += (this.M.covRev[seg][i] || 0);
                }
                const bLen = end - start || 1;
                fwdSum += (fS / bLen) * scale;
                revSum += (rS / bLen) * scale;
            }
            fwdM[b] = fwdSum / nReps;
            revM[b] = revSum / nReps;
        }
        
        // Calculate max for scaling
        let maxFwd = 0, maxRev = 0;
        for (let b = 0; b < bins; b++) {
            maxFwd = Math.max(maxFwd, fwdM[b]);
            maxRev = Math.max(maxRev, revM[b]);
        }
        
        const autoMax = Math.max(maxFwd, maxRev) * 1.1;
        const maxVal = (yMaxFwd > 0 || yMaxRev > 0) ? Math.max(yMaxFwd, yMaxRev) : (symY ? autoMax : Math.max(maxFwd, maxRev) * 1.1);
        const maxFwdVal = symY ? maxVal : (yMaxFwd > 0 ? yMaxFwd : maxFwd * 1.1);
        const maxRevVal = symY ? maxVal : (yMaxRev > 0 ? yMaxRev : maxRev * 1.1);
        
        // Draw grid if enabled
        if (showGrid) {
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            for (let i = 1; i < 5; i++) {
                const y = midY - (i / 5) * (ph / 2);
                ctx.beginPath();
                ctx.moveTo(pad.l, y);
                ctx.lineTo(w - pad.r, y);
                ctx.stroke();
                const y2 = midY + (i / 5) * (ph / 2);
                ctx.beginPath();
                ctx.moveTo(pad.l, y2);
                ctx.lineTo(w - pad.r, y2);
                ctx.stroke();
            }
        }
        
        // Draw zero line
        if (showZero) {
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad.l, midY);
            ctx.lineTo(w - pad.r, midY);
            ctx.stroke();
        }
        
        // Draw coverage
        const fwdColor = document.getElementById('cov-fwd-color')?.value || '#2563eb';
        const revColor = document.getElementById('cov-rev-color')?.value || '#dc2626';
        
        // Forward (above zero line)
        ctx.fillStyle = fwdColor;
        ctx.beginPath();
        ctx.moveTo(pad.l, midY);
        for (let b = 0; b < bins; b++) {
            const x = pad.l + (b / bins) * pw;
            const y = midY - (fwdM[b] / maxFwdVal) * (ph / 2);
            ctx.lineTo(x, Math.max(pad.t, y));
        }
        ctx.lineTo(pad.l + pw, midY);
        ctx.closePath();
        ctx.fill();
        
        // Reverse (below zero line)
        ctx.fillStyle = revColor;
        ctx.beginPath();
        ctx.moveTo(pad.l, midY);
        for (let b = 0; b < bins; b++) {
            const x = pad.l + (b / bins) * pw;
            const y = midY + (revM[b] / maxRevVal) * (ph / 2);
            ctx.lineTo(x, Math.min(h - pad.b, y));
        }
        ctx.lineTo(pad.l + pw, midY);
        ctx.closePath();
        ctx.fill();
        
        // Draw axes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad.l, pad.t);
        ctx.lineTo(pad.l, h - pad.b);
        ctx.lineTo(w - pad.r, h - pad.b);
        ctx.stroke();
        
        // Y-axis labels
        ctx.fillStyle = '#000';
        ctx.font = `${fontSize}px ${font}`;
        ctx.textAlign = 'right';
        
        // Forward max
        ctx.fillText(this.fmtNum(Math.round(maxFwdVal)), pad.l - 5, pad.t + 5);
        // Reverse max (negative)
        ctx.fillText('-' + this.fmtNum(Math.round(maxRevVal)), pad.l - 5, h - pad.b - 5);
        // Zero
        ctx.fillText('0', pad.l - 5, midY + 3);
        
        // Y-axis label
        ctx.save();
        ctx.translate(12, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.font = `${labelSize}px ${font}`;
        const yLabel = dataType === 'cpm' ? 'Coverage (CPM)' : dataType === 'rpkm' ? 'Coverage (RPKM)' : 'Coverage (reads)';
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();
        if (ctx.closeGroups) ctx.closeGroups();
        
        // X-axis labels - default to 500nt intervals for larger references
        ctx.textAlign = 'center';
        ctx.font = `${fontSize}px ${font}`;
        
        let xTicks = [];
        let effectiveXTickInterval = viewLen > 2000 ? 500 : (viewLen > 500 ? 200 : 0);
        
        if (effectiveXTickInterval > 0) {
            let firstTick = Math.ceil(actualStart / effectiveXTickInterval) * effectiveXTickInterval;
            if (firstTick < actualStart) firstTick += effectiveXTickInterval;
            for (let tick = firstTick; tick <= actualEnd; tick += effectiveXTickInterval) {
                xTicks.push(tick);
            }
        } else {
            // Auto ticks for small references
            const numTicks = 6;
            for (let i = 0; i <= numTicks; i++) {
                xTicks.push(actualStart + Math.floor(i * viewLen / numTicks));
            }
        }
        
        ctx.strokeStyle = '#000';
        for (const tick of xTicks) {
            const x = pad.l + ((tick - actualStart) / viewLen) * pw;
            if (x >= pad.l && x <= pad.l + pw) {
                ctx.beginPath();
                ctx.moveTo(x, h - pad.b);
                ctx.lineTo(x, h - pad.b + 3);
                ctx.stroke();
                ctx.fillText(this.fmtNum(tick), x, h - pad.b + 15);
            }
        }
        
        // X-axis label
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText(`Position (${seg})`, w / 2, h - 5);
        
        // Title
        ctx.font = `bold ${labelSize}px ${font}`;
        ctx.fillText(`${seg} Coverage`, w / 2, 12);
    }
    
    drawLenUnified(ctx) {
        // Unified length distribution drawing
        const w = +document.getElementById('len-w').value || 700;
        const h = +document.getElementById('len-h').value || 400;
        const seg = document.getElementById('len-seg').value;
        const font = getFont();
        const fontSize = +document.getElementById('len-font').value || 10;
        const labelSize = fontSize + 1;
        const yMaxFwd = +document.getElementById('len-ymax-fwd')?.value || 0;
        const yMaxRev = +document.getElementById('len-ymax-rev')?.value || 0;
        const dataType = document.getElementById('len-data').value || 'counts';
        const end3Type = document.getElementById('len-3-type')?.value || '5prime';
        const showErr = document.getElementById('len-err')?.checked;
        const showPts = document.getElementById('len-pts')?.checked;
        const colors = getNtColors();
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        if (!this.M.replicates.length) return;
        const { minLen, maxLen } = this.M.settings;
        const numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        const pad = { t: 30, r: 20, b: 45, l: 55 };
        const pw = w - pad.l - pad.r;
        const ph = h - pad.t - pad.b;
        const midY = pad.t + ph / 2;
        
        // Bar width from setting
        const barWidthPct = (+document.getElementById('len-barw')?.value || 75) / 100;
        const slotW = pw / numL;
        const bw = slotW * barWidthPct;
        const gap = slotW * (1 - barWidthPct) / 2;
        
        // Collect data
        let libSize = 0;
        for (const rep of reps) libSize += rep.stats.total;
        const avgLibSize = libSize / reps.length;
        
        const dataByLen = { fwd: {}, rev: {} };
        for (let l = minLen; l <= maxLen; l++) {
            for (const strand of ['fwd', 'rev']) {
                dataByLen[strand][l] = { A: [], C: [], G: [], T: [], total: [] };
                for (const rep of reps) {
                    const lenDist = rep.lenDist5;
                    if (!lenDist || !lenDist[strand]) {
                        for (const nt of 'ACGT') dataByLen[strand][l][nt].push(0);
                        dataByLen[strand][l].total.push(0);
                        continue;
                    }
                    const d = lenDist[strand][l] || { A: 0, C: 0, G: 0, T: 0 };
                    const total = d.A + d.C + d.G + d.T;
                    for (const nt of 'ACGT') dataByLen[strand][l][nt].push(d[nt]);
                    dataByLen[strand][l].total.push(total);
                }
            }
        }
        
        // Calculate max
        let maxV = 0;
        for (let l = minLen; l <= maxLen; l++) {
            for (const strand of ['fwd', 'rev']) {
                const total = this.mean(dataByLen[strand][l].total);
                maxV = Math.max(maxV, total);
            }
        }
        const niceMax = (yMaxFwd > 0 || yMaxRev > 0) ? Math.max(yMaxFwd, yMaxRev) : this.niceNum(maxV * 1.15) || 100;
        
        // Draw zero line
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad.l, midY);
        ctx.lineTo(w - pad.r, midY);
        ctx.stroke();
        
        // Draw stacked bars
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * slotW + gap;
            
            // Forward (above)
            let y = midY;
            for (const nt of 'ACGT') {
                const val = this.mean(dataByLen.fwd[l][nt]);
                const barH = (val / niceMax) * (ph / 2);
                ctx.fillStyle = colors[nt];
                ctx.fillRect(x, y - barH, bw, barH);
                y -= barH;
            }
            
            // Reverse (below)
            y = midY;
            for (const nt of 'ACGT') {
                const val = this.mean(dataByLen.rev[l][nt]);
                const barH = (val / niceMax) * (ph / 2);
                ctx.fillStyle = colors[nt];
                ctx.fillRect(x, y, bw, barH);
                y += barH;
            }
        }
        
        // Draw axes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad.l, pad.t);
        ctx.lineTo(pad.l, h - pad.b);
        ctx.lineTo(w - pad.r, h - pad.b);
        ctx.stroke();
        
        // Y-axis labels with magnitude formatting
        ctx.fillStyle = '#000';
        ctx.font = `${fontSize}px ${font}`;
        ctx.textAlign = 'right';
        const mag = this.getAxisMagnitude(niceMax);
        const yLabelText = mag.divisor > 1 ? `Read count${mag.suffix}` : 'Read count';
        ctx.fillText(this.fmtNum(Math.round(niceMax / mag.divisor)), pad.l - 5, pad.t + 5);
        ctx.fillText('-' + this.fmtNum(Math.round(niceMax / mag.divisor)), pad.l - 5, h - pad.b - 5);
        ctx.fillText('0', pad.l - 5, midY + 3);
        
        // Y-axis label
        ctx.save();
        ctx.translate(12, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText(yLabelText, 0, 0);
        ctx.restore();
        if (ctx.closeGroups) ctx.closeGroups();
        
        // X-axis labels - use xtick setting
        const xTickInterval = +document.getElementById('len-xtick')?.value || 1;
        ctx.textAlign = 'center';
        ctx.font = `${fontSize}px ${font}`;
        for (let l = minLen; l <= maxLen; l += xTickInterval) {
            const x = pad.l + (l - minLen + 0.5) * slotW;
            ctx.fillText(l.toString(), x, h - pad.b + 15);
        }
        
        // Labels
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText('Read length (nt)', w / 2, h - 5);
    }
    
    drawBiasUnified(ctx) {
        // Unified nucleotide bias drawing
        const w = +document.getElementById('bias-w').value || 700;
        const h = +document.getElementById('bias-h').value || 180;
        const seg = document.getElementById('bias-seg').value;
        const endType = document.getElementById('bias-end').value || '5';
        const strand = document.getElementById('bias-strand').value || 'both';
        const lenMin = +document.getElementById('bias-len-min').value || 18;
        const lenMax = +document.getElementById('bias-len-max').value || 30;
        const displayType = document.getElementById('bias-type').value || 'prop';
        const maxBits = +document.getElementById('bias-maxbits').value || 2;
        const font = getFont();
        const fontSize = +document.getElementById('bias-font').value || 11;
        const labelSize = fontSize + 1;
        const colors = getNtColors();
        const showErr = document.getElementById('bias-err')?.checked;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        if (!this.M.replicates.length) return;
        
        const pad = { t: 25, r: 20, b: 40, l: 50 };
        const pw = w - pad.l - pad.r;
        const ph = h - pad.t - pad.b;
        const maxPos = 20;
        const bw = pw / maxPos;
        const reps = this.M.replicates;
        
        // Aggregate data
        const posData = [];
        for (let p = 0; p < maxPos; p++) {
            const ntCounts = { A: 0, C: 0, G: 0, T: 0 };
            for (const rep of reps) {
                const bias = seg === 'all' ? rep.bias : rep.biasBySeg?.[seg];
                if (!bias) continue;
                
                const strandKeys = strand === 'both' ? ['fwd', 'rev'] : [strand];
                for (const s of strandKeys) {
                    const key = s + endType;
                    const d = bias[key]?.[p];
                    if (d) {
                        for (const nt of 'ACGT') ntCounts[nt] += d[nt] || 0;
                    }
                }
            }
            const total = ntCounts.A + ntCounts.C + ntCounts.G + ntCounts.T;
            posData.push({ counts: ntCounts, total });
        }
        
        // Draw based on display type
        if (displayType === 'prop') {
            // Proportion stacked bars
            for (let p = 0; p < maxPos; p++) {
                const x = pad.l + p * bw;
                let y = h - pad.b;
                const total = posData[p].total || 1;
                
                for (const nt of 'ACGT') {
                    const prop = posData[p].counts[nt] / total;
                    const barH = prop * ph;
                    ctx.fillStyle = colors[nt];
                    ctx.fillRect(x + 1, y - barH, bw - 2, barH);
                    y -= barH;
                }
            }
            
            // Y-axis for proportion
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad.l, pad.t);
            ctx.lineTo(pad.l, h - pad.b);
            ctx.lineTo(w - pad.r, h - pad.b);
            ctx.stroke();
            
            ctx.fillStyle = '#000';
            ctx.font = `${fontSize}px ${font}`;
            ctx.textAlign = 'right';
            ctx.fillText('1.0', pad.l - 5, pad.t + 5);
            ctx.fillText('0.5', pad.l - 5, pad.t + ph / 2 + 3);
            ctx.fillText('0', pad.l - 5, h - pad.b);
        } else {
            // Bits (sequence logo)
            for (let p = 0; p < maxPos; p++) {
                const x = pad.l + p * bw;
                const total = posData[p].total || 1;
                
                // Calculate information content
                let entropy = 0;
                const probs = {};
                for (const nt of 'ACGT') {
                    const prob = posData[p].counts[nt] / total;
                    probs[nt] = prob;
                    if (prob > 0) entropy -= prob * Math.log2(prob);
                }
                const ic = 2 - entropy; // Information content in bits
                
                // Sort nucleotides by frequency
                const sorted = 'ACGT'.split('').sort((a, b) => probs[a] - probs[b]);
                
                // Draw letters
                let y = h - pad.b;
                for (const nt of sorted) {
                    const height = (probs[nt] * ic / maxBits) * ph;
                    if (height > 0.5) {
                        ctx.fillStyle = colors[nt];
                        ctx.font = `bold ${Math.max(8, height)}px ${font}`;
                        ctx.textAlign = 'center';
                        ctx.fillText(nt, x + bw / 2, y);
                        y -= height;
                    }
                }
            }
            
            // Y-axis for bits
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad.l, pad.t);
            ctx.lineTo(pad.l, h - pad.b);
            ctx.lineTo(w - pad.r, h - pad.b);
            ctx.stroke();
            
            ctx.fillStyle = '#000';
            ctx.font = `${fontSize}px ${font}`;
            ctx.textAlign = 'right';
            ctx.fillText(maxBits.toString(), pad.l - 5, pad.t + 5);
            ctx.fillText('0', pad.l - 5, h - pad.b);
        }
        
        // X-axis labels
        ctx.textAlign = 'center';
        ctx.font = `${fontSize}px ${font}`;
        ctx.fillStyle = '#000';
        const xTick = +document.getElementById('bias-xtick')?.value || 1;
        for (let p = 0; p < maxPos; p += xTick) {
            const x = pad.l + (p + 0.5) * bw;
            ctx.fillText((p + 1).toString(), x, h - pad.b + 15);
        }
        
        // Axis labels
        ctx.font = `${labelSize}px ${font}`;
        ctx.fillText(`Position from ${endType}' end`, w / 2, h - 5);
        
        ctx.save();
        ctx.translate(12, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText(displayType === 'prop' ? 'Proportion' : 'Bits', 0, 0);
        ctx.restore();
        if (ctx.closeGroups) ctx.closeGroups();
        
        // Draw legend inside canvas if enabled
        const showLegend = document.getElementById('bias-show-legend')?.checked;
        if (showLegend) {
            const legendItems = [
                { label: 'A', color: colors.A },
                { label: 'C', color: colors.C },
                { label: 'G', color: colors.G },
                { label: 'T/U', color: colors.T }
            ];
            const legFontSize = +document.getElementById('bias-leg-font')?.value || 12;
            const legPos = document.getElementById('bias-leg-pos')?.value || 'center';
            const legBold = document.getElementById('bias-leg-bold')?.checked;
            const legXoff = +document.getElementById('bias-leg-xoff')?.value || 15;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            const legendFont = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            ctx.font = legendFont;
            
            // Calculate total legend width
            let totalWidth = 0;
            for (const item of legendItems) {
                totalWidth += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
            totalWidth -= itemGap;
            
            // Position based on setting
            let lx;
            if (legPos === 'left') {
                lx = pad.l + legXoff;
            } else if (legPos === 'right') {
                lx = w - pad.r - totalWidth - legXoff;
            } else { // center
                lx = (w - totalWidth) / 2;
            }
            const legYoff = +document.getElementById('bias-leg-yoff')?.value || 0;
            const ly = 2 + legYoff;
            
            for (const item of legendItems) {
                ctx.fillStyle = item.color;
                ctx.fillRect(lx, ly, boxSize, boxSize);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(lx, ly, boxSize, boxSize);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, lx + boxSize + 5, ly + boxSize * 0.75 + legFontSize * 0.1);
                lx += boxSize + 5 + ctx.measureText(item.label).width + itemGap;
            }
        }
    }
    
    drawOvlUnified(ctx) {
        // Unified overlap 4-panel drawing - exact replica of canvas version
        const seg = document.getElementById('ovl-seg').value;
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        const w = +document.getElementById('ovl-w').value || 800;
        const h = +document.getElementById('ovl-h').value || 500;
        const font = getFont();
        const fontSize = +document.getElementById('ovl-font').value || 10;
        const labelSize = fontSize + 1;
        const titleSize = +document.getElementById('ovl-title-size')?.value || 11;
        const titleBold = document.getElementById('ovl-title-bold')?.checked !== false;
        const showBorder = document.getElementById('ovl-show-border')?.checked || false;
        const show10Line = document.getElementById('ovl-show-10line')?.checked || false;
        const showSubtitles = document.getElementById('ovl-show-subtitles')?.checked !== false;
        const xOff = +document.getElementById('ovl-xoff')?.value || 0;
        const yOff = +document.getElementById('ovl-yoff')?.value || 0;
        const panelW = +document.getElementById('ovl-panel-w')?.value || 0;
        const panelH = +document.getElementById('ovl-panel-h')?.value || 0;
        const normalizeRPM = document.getElementById('ovl-normalize-rpm')?.checked || false;
        const showErr = document.getElementById('ovl-err')?.checked && ovlData.sem;
        const showPts = document.getElementById('ovl-pts')?.checked && ovlData.perRep;
        
        const qmin = this.ovlSettings?.qmin || 18;
        const qmax = this.ovlSettings?.qmax || 30;
        const tmin = this.ovlSettings?.tmin || 18;
        const tmax = this.ovlSettings?.tmax || 30;
        const omin = this.ovlSettings?.omin || -10;
        const omax = this.ovlSettings?.omax || 30;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        // Draw main title
        ctx.fillStyle = '#000';
        ctx.font = `${titleBold ? 'bold ' : ''}${titleSize + 2}px ${font}`;
        ctx.textAlign = 'center';
        ctx.fillText(`Overlap Signatures of ${qmin}-${qmax} against ${tmin}-${tmax}nt small RNAs`, w / 2, 15);
        
        // Panel layout
        const titleOffset = 25;
        const gap = 15;
        const pw = panelW > 0 ? panelW : (w - gap * 3) / 2;
        const ph = panelH > 0 ? panelH : (h - titleOffset - gap * 3) / 2;
        
        const allCounts = ovlData.counts?.['all'] || {};
        const allProbs = ovlData.probs?.['all'] || {};
        const allCountZ = ovlData.countZscores?.['all'] || {};
        const allProbZ = ovlData.probZscores?.['all'] || {};
        
        const repLibSizes = this.M.replicates.map(rep => rep.stats?.total || 1);
        
        // Get Y-max settings
        const yMaxCounts = +document.getElementById('ovl-ymax-counts')?.value || 0;
        const yMaxProbs = +document.getElementById('ovl-ymax-probs')?.value || 0;
        const yMaxZ = +document.getElementById('ovl-ymax-z')?.value || 0;
        
        const panels = [
            { x: gap, y: titleOffset + gap, title: 'Number of pairs', dataKey: 'counts', type: 'bar' },
            { x: gap * 2 + pw, y: titleOffset + gap, title: 'Number of pairs z-scores', dataKey: 'countZscores', type: 'line' },
            { x: gap, y: titleOffset + gap * 2 + ph, title: 'Overlap probabilities', dataKey: 'probs', type: 'bar' },
            { x: gap * 2 + pw, y: titleOffset + gap * 2 + ph, title: 'Overlap probability z-scores', dataKey: 'probZscores', type: 'line' }
        ];
        
        // Get data for a panel - with RPM normalization support
        const getData = (key) => {
            if (key === 'counts' && normalizeRPM) {
                // For counts with RPM: scale each replicate by its library size, then average
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                    if (perRepVals.length > 0) {
                        // Scale each replicate's count by 1e6 / that replicate's library size
                        const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                        arr.push(scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length);
                    } else {
                        arr.push(allCounts[o] || 0);
                    }
                }
                return arr;
            }
            const obj = key === 'counts' ? allCounts : 
                       key === 'probs' ? allProbs :
                       key === 'countZscores' ? allCountZ : allProbZ;
            const arr = [];
            for (let o = omin; o <= omax; o++) arr.push(obj[o] || 0);
            return arr;
        };
        
        const getSEM = (key) => {
            if (!ovlData.sem?.[key]?.['all']) return null;
            const arr = [];
            for (let o = omin; o <= omax; o++) arr.push(ovlData.sem[key]['all'][o] || 0);
            return arr;
        };
        
        const getPerRep = (key) => {
            if (!ovlData.perRep?.[key]?.['all']) return null;
            const arr = [];
            for (let o = omin; o <= omax; o++) arr.push(ovlData.perRep[key]['all'][o] || []);
            return arr;
        };
        
        for (const panel of panels) {
            const data = getData(panel.dataKey);
            const semData = getSEM(panel.dataKey);
            const perRepData = getPerRep(panel.dataKey);
            
            const isZscore = panel.dataKey.includes('Zscore');
            const pad = { t: 25, r: 10, b: 35 + yOff, l: 50 + xOff };
            const plotW = pw - pad.l - pad.r;
            const plotH = ph - pad.t - pad.b;
            const x0 = panel.x + pad.l;
            const y0 = panel.y + pad.t;
            
            // Calculate Y range
            let minV, maxV;
            if (isZscore) {
                if (yMaxZ > 0) {
                    maxV = yMaxZ; minV = -yMaxZ;
                } else {
                    let absMax = 1;
                    for (const v of data) absMax = Math.max(absMax, Math.abs(v));
                    maxV = Math.ceil(absMax * 1.2);
                    minV = -maxV;
                }
            } else if (panel.dataKey === 'counts') {
                minV = 0;
                maxV = yMaxCounts > 0 ? yMaxCounts : Math.max(...data) * 1.15;
            } else {
                minV = 0;
                maxV = yMaxProbs > 0 ? yMaxProbs : Math.max(...data) * 1.15;
            }
            if (maxV === minV) maxV = minV + 1;
            
            // Draw panel background
            ctx.fillStyle = '#fff';
            ctx.fillRect(panel.x, panel.y, pw, ph);
            if (showBorder) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(panel.x, panel.y, pw, ph);
            }
            
            // Draw subtitle
            if (showSubtitles) {
                ctx.fillStyle = '#000';
                ctx.font = `${titleBold ? 'bold ' : ''}${titleSize}px ${font}`;
                ctx.textAlign = 'center';
                ctx.fillText(panel.title, panel.x + pw / 2, panel.y + 15);
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x0, y0 + plotH);
            ctx.lineTo(x0 + plotW, y0 + plotH);
            ctx.stroke();
            
            // Y-axis ticks
            ctx.fillStyle = '#000';
            ctx.font = `${fontSize}px ${font}`;
            ctx.textAlign = 'right';
            const numBars = omax - omin + 1;
            const barW = plotW / numBars;
            
            const yTickCount = isZscore ? 5 : 4;
            for (let i = 0; i <= yTickCount; i++) {
                const v = minV + (i / yTickCount) * (maxV - minV);
                const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                ctx.beginPath();
                ctx.moveTo(x0 - 3, y);
                ctx.lineTo(x0, y);
                ctx.stroke();
                const label = isZscore ? v.toFixed(1) : 
                             panel.dataKey === 'probs' ? v.toFixed(2) : this.fmtNum(Math.round(v));
                ctx.fillText(label, x0 - 5, y + 3);
            }
            
            // X-axis ticks
            ctx.textAlign = 'center';
            for (let i = 0; i < numBars; i += 2) {
                const ovl = omin + i;
                const x = x0 + (i + 0.5) * barW;
                ctx.fillText(ovl.toString(), x, y0 + plotH + 12);
            }
            
            // Axis labels
            ctx.font = `${fontSize}px ${font}`;
            ctx.fillText('overlap (nt)', panel.x + pw / 2, panel.y + ph - 5);
            
            ctx.save();
            ctx.translate(panel.x + 10, panel.y + ph / 2);
            ctx.rotate(-Math.PI / 2);
            let yLabel;
            if (panel.dataKey === 'counts') {
                yLabel = normalizeRPM ? 'RPM' : 'Numbers of pairs';
            } else if (panel.dataKey === 'probs') {
                yLabel = 'Probability [%]';
            } else {
                yLabel = 'z-score';
            }
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
            if (ctx.closeGroups) ctx.closeGroups();
            
            // Draw data
            if (panel.type === 'bar') {
                // Draw boxplots for bar panels
                if (perRepData && perRepData[0]?.length > 1) {
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals || repVals.length === 0) continue;
                        
                        const sorted = [...repVals].filter(v => !isNaN(v)).sort((a, b) => a - b);
                        if (sorted.length === 0) continue;
                        
                        const n = sorted.length;
                        const min = sorted[0];
                        const max = sorted[n - 1];
                        const median = n % 2 === 0 ? (sorted[n/2 - 1] + sorted[n/2]) / 2 : sorted[Math.floor(n/2)];
                        const q1 = sorted[Math.floor(n * 0.25)];
                        const q3 = sorted[Math.floor(n * 0.75)];
                        
                        const x = x0 + (i + 0.5) * barW;
                        const boxW = barW * 0.6;
                        
                        const yMin = y0 + plotH - ((min - minV) / (maxV - minV)) * plotH;
                        const yMax = y0 + plotH - ((max - minV) / (maxV - minV)) * plotH;
                        const yMedian = y0 + plotH - ((median - minV) / (maxV - minV)) * plotH;
                        const yQ1 = y0 + plotH - ((q1 - minV) / (maxV - minV)) * plotH;
                        const yQ3 = y0 + plotH - ((q3 - minV) / (maxV - minV)) * plotH;
                        
                        // Whiskers
                        ctx.strokeStyle = '#4a5568';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, yQ1); ctx.lineTo(x, yMin);
                        ctx.moveTo(x - boxW/4, yMin); ctx.lineTo(x + boxW/4, yMin);
                        ctx.moveTo(x, yQ3); ctx.lineTo(x, yMax);
                        ctx.moveTo(x - boxW/4, yMax); ctx.lineTo(x + boxW/4, yMax);
                        ctx.stroke();
                        
                        // Box
                        ctx.fillStyle = 'rgba(74, 85, 104, 0.3)';
                        ctx.fillRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        ctx.strokeRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        
                        // Median
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x - boxW/2, yMedian);
                        ctx.lineTo(x + boxW/2, yMedian);
                        ctx.stroke();
                        
                        // Points
                        if (showPts) {
                            for (const v of repVals) {
                                if (isNaN(v)) continue;
                                const jitter = (Math.random() - 0.5) * boxW * 0.6;
                                const ptY = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                                ctx.fillStyle = 'rgba(37, 99, 235, 0.7)';
                                ctx.beginPath();
                                ctx.arc(x + jitter, ptY, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                } else {
                    // Simple bars
                    ctx.fillStyle = '#4a5568';
                    for (let i = 0; i < data.length; i++) {
                        const v = data[i];
                        if (isNaN(v) || v === 0) continue;
                        const barX = x0 + i * barW + barW * 0.15;
                        const barH = ((v - minV) / (maxV - minV)) * plotH;
                        ctx.fillRect(barX, y0 + plotH - barH, barW * 0.7, barH);
                    }
                }
            } else {
                // Line chart
                // Error ribbon
                if (showErr && semData) {
                    ctx.fillStyle = 'rgba(37, 99, 235, 0.15)';
                    ctx.beginPath();
                    let started = false;
                    for (let i = 0; i < data.length; i++) {
                        const v = data[i];
                        const err = semData[i] || 0;
                        const x = x0 + (i + 0.5) * barW;
                        const yTop = y0 + plotH - (((v + err) - minV) / (maxV - minV)) * plotH;
                        if (!started) { ctx.moveTo(x, yTop); started = true; }
                        else ctx.lineTo(x, yTop);
                    }
                    for (let i = data.length - 1; i >= 0; i--) {
                        const v = data[i];
                        const err = semData[i] || 0;
                        const x = x0 + (i + 0.5) * barW;
                        const yBot = y0 + plotH - (((v - err) - minV) / (maxV - minV)) * plotH;
                        ctx.lineTo(x, yBot);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Individual points
                if (showPts && perRepData) {
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals) continue;
                        for (const v of repVals) {
                            if (isNaN(v)) continue;
                            const x = x0 + (i + 0.5) * barW;
                            const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                            ctx.fillStyle = 'rgba(37, 99, 235, 0.3)';
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // Main line
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                let started = false;
                for (let i = 0; i < data.length; i++) {
                    const v = data[i];
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                    if (!started) { ctx.moveTo(x, y); started = true; }
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Mean points
                ctx.fillStyle = '#2563eb';
                for (let i = 0; i < data.length; i++) {
                    const v = data[i];
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Zero line for z-scores
                if (isZscore) {
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    const zeroY = y0 + plotH - ((0 - minV) / (maxV - minV)) * plotH;
                    ctx.moveTo(x0, zeroY);
                    ctx.lineTo(x0 + plotW, zeroY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Vertical zero line
            if (omin < 0 && omax > 0) {
                const zeroIdx = 0 - omin;
                const x = x0 + (zeroIdx + 0.5) * barW;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(x, y0);
                ctx.lineTo(x, y0 + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 10nt line
            if (show10Line && omin <= 10 && omax >= 10) {
                const idx10 = 10 - omin;
                const x = x0 + (idx10 + 0.5) * barW;
                ctx.strokeStyle = 'rgba(220, 38, 38, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(x, y0);
                ctx.lineTo(x, y0 + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }
    
    drawOvlHeatmapUnified(ctx) {
        // Call the EXACT same drawing function used by canvas
        const w = +document.getElementById('ovl-hm-w')?.value || 700;
        const h = +document.getElementById('ovl-hm-h')?.value || 350;
        const seg = document.getElementById('ovl-hm-seg')?.value || document.getElementById('ovl-seg')?.value || 'all';
        const dataType = document.getElementById('ovl-hm-data')?.value || 'z';
        const font = getFont();
        const fontSize = +document.getElementById('ovl-hm-font')?.value || 14;
        const labelSize = fontSize + 1;
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        const qmin = +document.getElementById('ovl-hm-qmin')?.value || this.ovlSettings?.qmin || 18;
        const qmax = +document.getElementById('ovl-hm-qmax')?.value || this.ovlSettings?.qmax || 30;
        const omin = +document.getElementById('ovl-hm-omin')?.value || this.ovlSettings?.omin || -10;
        const omax = +document.getElementById('ovl-hm-omax')?.value || this.ovlSettings?.omax || 30;
        
        // Call the same drawing function
        this.drawOvlHeatmapPanel(ctx, w, h, ovlData, omin, omax, qmin, qmax, font, fontSize, labelSize, dataType, seg);
    }
    
    // SVG rendering functions for each plot type
    drawHistSVG(svg, endType) {
        const w = +document.getElementById(`hist${endType}-w`).value || 420;
        const h = +document.getElementById(`hist${endType}-h`).value || 220;
        const yMaxIn = +document.getElementById(`hist${endType}-ymax`).value || 0;
        const yTickIn = +document.getElementById(`hist${endType}-ytick`)?.value || 0;
        const capW = +document.getElementById(`hist${endType}-cap`).value || 4;
        const showErr = document.getElementById(`hist${endType}-err`).checked && this.M.replicates.length > 1;
        const showPts = document.getElementById(`hist${endType}-pts`)?.checked && this.M.replicates.length > 1;
        const showJitter = document.getElementById(`hist${endType}-jitter`)?.checked;
        const ptOpacity = +document.getElementById(`hist${endType}-pt-opacity`)?.value || 0.7;
        const dataType = document.getElementById(`hist${endType}-data`).value || 'counts';
        const colors = getNtColors();
        const errType = document.getElementById('err-type').value;
        const font = getFont();
        const fontSize = +document.getElementById(`hist${endType}-font`).value || 10;
        const xOff = +document.getElementById(`hist${endType}-xoff`)?.value || 0;
        const yOff = +document.getElementById(`hist${endType}-yoff`)?.value || 0;
        const labelSize = fontSize + 1;
        const pad = { t: 25, r: 20, b: 40 + xOff, l: 55 + yOff }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        
        if (!this.M.replicates.length) return;
        const { minLen, maxLen } = this.M.settings;
        const numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        let librarySize = 0;
        for (const rep of reps) librarySize += rep.stats.total;
        const avgLibSize = librarySize / reps.length;
        
        const dataByLen = {};
        for (let l = minLen; l <= maxLen; l++) {
            dataByLen[l] = { A: [], C: [], G: [], T: [], total: [] };
            for (const rep of reps) {
                const lenDistKey = `lenDist${endType}`;
                const lenDist = rep[lenDistKey];
                if (!lenDist || !lenDist.fwd || !lenDist.rev) {
                    for (const nt of 'ACGT') dataByLen[l][nt].push(0);
                    dataByLen[l].total.push(0);
                    continue;
                }
                const fwd = lenDist.fwd[l] || { A: 0, C: 0, G: 0, T: 0 };
                const rev = lenDist.rev[l] || { A: 0, C: 0, G: 0, T: 0 };
                const combined = { A: fwd.A + rev.A, C: fwd.C + rev.C, G: fwd.G + rev.G, T: fwd.T + rev.T };
                const total = combined.A + combined.C + combined.G + combined.T;
                for (const nt of 'ACGT') dataByLen[l][nt].push(combined[nt]);
                dataByLen[l].total.push(total);
            }
        }
        
        let grandTotal = 0;
        for (let l = minLen; l <= maxLen; l++) grandTotal += this.mean(dataByLen[l].total);
        const scale = dataType === 'cpm' ? 1e6 / avgLibSize : dataType === 'pct' ? 100 / (grandTotal || 1) : 1;
        
        const meanData = {}, errData = {}, totalErrData = {};
        let maxV = 0;
        for (let l = minLen; l <= maxLen; l++) {
            meanData[l] = {};
            errData[l] = {};
            let stackTotal = 0;
            for (const nt of 'ACGT') {
                const vals = dataByLen[l][nt].map(v => v * scale);
                meanData[l][nt] = this.mean(vals);
                stackTotal += meanData[l][nt];
                if (errType === 'sem') errData[l][nt] = this.sem(vals);
                else if (errType === 'ci95') errData[l][nt] = this.sem(vals) * 1.96;
                else errData[l][nt] = this.std(vals);
            }
            // Calculate error for the TOTAL stack (sum of all nucleotides)
            const totalVals = dataByLen[l].total.map(v => v * scale);
            if (errType === 'sem') totalErrData[l] = this.sem(totalVals);
            else if (errType === 'ci95') totalErrData[l] = this.sem(totalVals) * 1.96;
            else totalErrData[l] = this.std(totalVals);
            
            const topErr = showErr ? totalErrData[l] : 0;
            maxV = Math.max(maxV, stackTotal + topErr);
        }
        
        const maxWithMargin = maxV * 1.15;
        const niceMax = yMaxIn > 0 ? yMaxIn : this.niceNum(maxWithMargin) || 100;
        const yLabel = dataType === 'cpm' ? 'CPM' : dataType === 'pct' ? 'Percentage (%)' : 'Read count';
        
        // Draw axes
        svg.strokeStyle = '#000';
        svg.lineWidth = 1;
        svg.beginPath();
        svg.moveTo(pad.l, pad.t);
        svg.lineTo(pad.l, h - pad.b);
        svg.lineTo(w - pad.r, h - pad.b);
        svg.stroke();
        
        // Y-axis labels and ticks - use custom interval if specified
        svg.fillStyle = '#000';
        svg.font = `${fontSize}px ${font}`;
        svg.textAlign = 'right';
        let yTicks;
        if (yTickIn > 0) {
            yTicks = [];
            for (let v = 0; v <= niceMax; v += yTickIn) yTicks.push(v);
            if (yTicks[yTicks.length - 1] < niceMax) yTicks.push(niceMax);
        } else {
            yTicks = this.niceTicks(0, niceMax, 4);
        }
        for (const t of yTicks) {
            const y = h - pad.b - (t / niceMax) * ph;
            svg.beginPath();
            svg.moveTo(pad.l - 4, y);
            svg.lineTo(pad.l, y);
            svg.stroke();
            let tickLabel = dataType === 'pct' ? t.toFixed(1) : this.fmtNum(t);
            svg.fillText(tickLabel, pad.l - 6, y + 3);
            if (t > 0) {
                svg.strokeStyle = '#eee';
                svg.beginPath();
                svg.moveTo(pad.l, y);
                svg.lineTo(w - pad.r, y);
                svg.stroke();
                svg.strokeStyle = '#000';
            }
        }
        
        // X-axis labels with custom start and interval
        svg.textAlign = 'center';
        const xStart = +document.getElementById(`hist${endType}-xstart`)?.value || minLen;
        const xTickInt = +document.getElementById(`hist${endType}-xtick`)?.value || 2;
        const firstTick = Math.max(minLen, xStart);
        for (let l = firstTick; l <= maxLen; l += xTickInt) {
            const x = pad.l + (l - minLen + 0.5) * (pw / numL);
            svg.beginPath();
            svg.moveTo(x, h - pad.b);
            svg.lineTo(x, h - pad.b + 4);
            svg.stroke();
            svg.fillText(l.toString(), x, h - pad.b + 15);
        }
        svg.font = `${labelSize}px ${font}`;
        svg.fillText('Read length', w / 2, h - 5);
        
        // Y-axis label
        svg.save();
        svg.translate(12, h / 2);
        svg.rotate(-Math.PI / 2);
        svg.fillText(yLabel, 0, 0);
        svg.restore();
        svg.closeGroups();
        
        // Draw bars
        const bw = (pw / numL) * 0.75, gap = (pw / numL) * 0.125;
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * (pw / numL) + gap;
            let y = h - pad.b;
            for (const nt of 'ACGT') {
                const mean = meanData[l][nt];
                const barH = (mean / niceMax) * ph;
                if (barH > 0.5) {
                    svg.fillStyle = colors[nt];
                    svg.fillRect(x, y - barH, bw, barH);
                    y -= barH;
                }
            }
            
            // Error bar at top (uses total stack error)
            if (showErr && reps.length > 1) {
                const err = totalErrData[l];
                const errH = (err / niceMax) * ph;
                if (errH > 1) {
                    const midX = x + bw / 2;
                    svg.strokeStyle = '#000';
                    svg.lineWidth = 1;
                    svg.beginPath();
                    svg.moveTo(midX, y);
                    svg.lineTo(midX, y - errH);
                    svg.stroke();
                    svg.beginPath();
                    svg.moveTo(midX - capW, y - errH);
                    svg.lineTo(midX + capW, y - errH);
                    svg.stroke();
                }
            }
            
            // Individual replicate points
            if (showPts && reps.length > 1) {
                const numReps = reps.length;
                for (let ri = 0; ri < numReps; ri++) {
                    let cumHeight = 0;
                    for (const nt of 'ACGT') {
                        const val = dataByLen[l][nt][ri] * scale;
                        cumHeight += val;
                        const ptY = h - pad.b - (cumHeight / niceMax) * ph;
                        if (val <= 0) continue;
                        
                        const ntIdx = 'ACGT'.indexOf(nt);
                        let ptX;
                        if (showJitter) {
                            const jitterOffset = ((ri * 7 + ntIdx * 3) % 10) / 10 - 0.5;
                            ptX = x + bw / 2 + jitterOffset * bw * 0.6;
                        } else {
                            const sectionW = bw / 4;
                            const sectionStart = x + ntIdx * sectionW;
                            ptX = sectionStart + sectionW * 0.2 + (ri / Math.max(1, numReps - 1)) * sectionW * 0.6;
                        }
                        
                        // Fill the circle
                        svg.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                        svg.beginPath();
                        svg.arc(ptX, ptY, 2.5, 0, Math.PI * 2);
                        svg.fill();
                        // Stroke the circle (need new path)
                        svg.strokeStyle = '#000';
                        svg.lineWidth = 0.5;
                        svg.beginPath();
                        svg.arc(ptX, ptY, 2.5, 0, Math.PI * 2);
                        svg.stroke();
                    }
                }
            }
        }
        
        // Legend
        const showLegend = document.getElementById(`hist${endType}-show-legend`)?.checked;
        if (showLegend) {
            const legendItems = [
                { label: 'A', color: colors.A },
                { label: 'C', color: colors.C },
                { label: 'G', color: colors.G },
                { label: 'T/U', color: colors.T }
            ];
            const legFontSize = +document.getElementById(`hist${endType}-leg-font`)?.value || 12;
            const legPos = document.getElementById(`hist${endType}-leg-pos`)?.value || 'center';
            const legBold = document.getElementById(`hist${endType}-leg-bold`)?.checked;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            
            svg.font = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            let totalWidth = 0;
            for (const item of legendItems) {
                totalWidth += boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap;
            }
            totalWidth -= itemGap;
            
            let lx;
            if (legPos === 'left') lx = pad.l + 10;
            else if (legPos === 'right') lx = w - pad.r - totalWidth - 10;
            else lx = (w - totalWidth) / 2;
            const ly = 6;
            
            for (const item of legendItems) {
                svg.fillStyle = item.color;
                svg.fillRect(lx, ly, boxSize, boxSize);
                svg.strokeStyle = 'rgba(0,0,0,0.3)';
                svg.lineWidth = 0.5;
                svg.strokeRect(lx, ly, boxSize, boxSize);
                svg.fillStyle = '#333';
                svg.textAlign = 'left';
                svg.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap;
            }
        }
    }
    
    drawCovSVG(svg) {
        // Re-render coverage plot as SVG using same logic as drawCov
        const plotInfo = this.plotInfo.cov;
        if (!plotInfo) return;
        
        const w = +document.getElementById('cov-w').value || 900;
        const h = +document.getElementById('cov-h').value || 240;
        const seg = document.getElementById('cov-seg').value;
        const showErr = document.getElementById('cov-err').checked && this.M.replicates.length > 1;
        const errOp = +document.getElementById('err-opacity').value || 0.25;
        const lw = +document.getElementById('cov-lw').value || 1.5;
        const fwdCol = document.getElementById('cov-fwd-col').value || '#0066cc';
        const revCol = document.getElementById('cov-rev-col').value || '#cc3300';
        const font = getFont();
        const fontSize = +document.getElementById('cov-font').value || 10;
        const xBold = document.getElementById('cov-xbold')?.checked || false;
        const yBold = document.getElementById('cov-ybold')?.checked || false;
        const labelSize = fontSize + 1;
        
        const { pad, pw, ph, midY, bins, fwdM, revM, fwdE, revE, niceMaxFwd, niceMaxRev, rangeStart = 0, rangeEnd, fullRefLen, refLen } = plotInfo;
        const isZoomed = rangeStart > 0 || rangeEnd < fullRefLen;
        const dataType = document.getElementById('cov-data').value || 'counts';
        const covType = document.getElementById('cov-type').value || 'full';
        const yLabel = dataType === 'cpm' ? 'CPM' : (covType === '5end' ? "5‚Ä≤ end depth" : covType === '3end' ? "3‚Ä≤ end depth" : 'Read depth');
        
        // Axes
        svg.strokeStyle = '#ddd';
        svg.lineWidth = 1;
        svg.beginPath();
        svg.moveTo(pad.l, pad.t);
        svg.lineTo(pad.l, h - pad.b);
        svg.lineTo(w - pad.r, h - pad.b);
        svg.stroke();
        
        // Center line
        svg.strokeStyle = '#ccc';
        svg.beginPath();
        svg.moveTo(pad.l, midY);
        svg.lineTo(w - pad.r, midY);
        svg.stroke();
        
        // Y-axis ticks
        svg.fillStyle = '#000';
        svg.font = `${yBold ? 'bold ' : ''}${fontSize}px ${font}`;
        svg.textAlign = 'right';
        const yTickInterval = +document.getElementById('cov-ytick')?.value || 0;
        let yTicksFwd, yTicksRev;
        if (yTickInterval > 0) {
            // Custom Y-tick interval
            yTicksFwd = [];
            yTicksRev = [];
            for (let v = 0; v <= niceMaxFwd; v += yTickInterval) yTicksFwd.push(v);
            for (let v = 0; v <= niceMaxRev; v += yTickInterval) yTicksRev.push(v);
        } else {
            // Auto ticks
            yTicksFwd = this.niceTicks(0, niceMaxFwd, 3);
            yTicksRev = this.niceTicks(0, niceMaxRev, 3);
        }
        for (const tick of yTicksFwd) {
            const yUp = midY - (tick / niceMaxFwd) * (ph / 2);
            svg.fillText(this.fmtNum(tick), pad.l - 5, yUp + 3);
        }
        for (const tick of yTicksRev) {
            if (tick > 0) {
                const yDn = midY + (tick / niceMaxRev) * (ph / 2);
                svg.fillText(this.fmtNum(tick), pad.l - 5, yDn + 3);
            }
        }
        
        // X-axis ticks
        svg.textAlign = 'center';
        svg.font = `${xBold ? 'bold ' : ''}${fontSize}px ${font}`;
        const xTicks = this.niceTicks(rangeStart, rangeStart + refLen, 6);
        for (const tick of xTicks) {
            const xPos = pad.l + ((tick - rangeStart) / refLen) * pw;
            if (xPos >= pad.l && xPos <= pad.l + pw) {
                svg.beginPath();
                svg.moveTo(xPos, midY);
                svg.lineTo(xPos, midY + 4);
                svg.stroke();
                svg.fillText(this.fmtNum(tick), xPos, h - pad.b + 15);
            }
        }
        svg.font = `${xBold ? 'bold ' : ''}${labelSize}px ${font}`;
        svg.fillText(isZoomed ? `Position (nt) [${rangeStart+1}-${rangeEnd}]` : 'Position (nt)', w / 2, h - pad.b + 30);
        
        // Y-axis label
        svg.save();
        svg.translate(12, h / 2);
        svg.rotate(-Math.PI / 2);
        svg.font = `${yBold ? 'bold ' : ''}${labelSize}px ${font}`;
        svg.fillText(yLabel, 0, 0);
        svg.restore();
        svg.closeGroups();
        
        // Helper functions
        const toYFwd = v => { const r = Math.max(0, Math.min(niceMaxFwd, v)); return midY - (r / niceMaxFwd) * (ph / 2); };
        const toYRev = v => { const r = Math.max(0, Math.min(niceMaxRev, v)); return midY + (r / niceMaxRev) * (ph / 2); };
        
        // Error ribbons (if applicable)
        if (showErr && fwdE && revE) {
            // Forward error ribbon
            svg.fillStyle = this.hexRgba(fwdCol, errOp);
            svg.beginPath();
            svg.moveTo(pad.l, toYFwd(fwdM[0] + fwdE[0]));
            for (let i = 1; i < bins; i++) svg.lineTo(pad.l + (i / bins) * pw, toYFwd(fwdM[i] + fwdE[i]));
            for (let i = bins - 1; i >= 0; i--) svg.lineTo(pad.l + (i / bins) * pw, toYFwd(Math.max(0, fwdM[i] - fwdE[i])));
            svg.closePath();
            svg.fill();
            
            // Reverse error ribbon
            svg.fillStyle = this.hexRgba(revCol, errOp);
            svg.beginPath();
            svg.moveTo(pad.l, toYRev(revM[0] + revE[0]));
            for (let i = 1; i < bins; i++) svg.lineTo(pad.l + (i / bins) * pw, toYRev(revM[i] + revE[i]));
            for (let i = bins - 1; i >= 0; i--) svg.lineTo(pad.l + (i / bins) * pw, toYRev(Math.max(0, revM[i] - revE[i])));
            svg.closePath();
            svg.fill();
        }
        
        // Forward line
        svg.strokeStyle = fwdCol;
        svg.lineWidth = lw;
        svg.beginPath();
        svg.moveTo(pad.l, toYFwd(fwdM[0]));
        for (let i = 1; i < bins; i++) svg.lineTo(pad.l + (i / bins) * pw, toYFwd(fwdM[i]));
        svg.stroke();
        
        // Reverse line
        svg.strokeStyle = revCol;
        svg.beginPath();
        svg.moveTo(pad.l, toYRev(revM[0]));
        for (let i = 1; i < bins; i++) svg.lineTo(pad.l + (i / bins) * pw, toYRev(revM[i]));
        svg.stroke();
    }
    
    drawLenSVG(svg) {
        // Full vector SVG export for length distribution
        if (!this.M.replicates.length) return;
        
        const w = +document.getElementById('len-w').value || 700;
        const h = +document.getElementById('len-h').value || 320;
        const yMaxFwdIn = +document.getElementById('len-ymax-fwd')?.value || 0;
        const yMaxRevIn = +document.getElementById('len-ymax-rev')?.value || 0;
        const showErr = document.getElementById('len-err').checked && this.M.replicates.length > 1;
        const showPts = document.getElementById('len-pts').checked && this.M.replicates.length > 1;
        const showJitter = document.getElementById('len-jitter')?.checked || false;
        const ptOpacity = +document.getElementById('len-pt-opacity')?.value || 0.7;
        const selectedSeg = document.getElementById('len-seg')?.value || 'all';
        const topEnd = document.getElementById('len-top-end').value;
        const botEnd = document.getElementById('len-bot-end').value;
        const dataType = document.getElementById('len-data').value || 'counts';
        const xTick = +document.getElementById('len-xtick').value || 1;
        const errType = document.getElementById('err-type').value;
        const xOff = +document.getElementById('len-xoff')?.value || 0;
        const yOff = +document.getElementById('len-yoff')?.value || 0;
        const colors = getNtColors();
        const font = getFont();
        const fontSize = +document.getElementById('len-font').value || 10;
        const labelSize = fontSize + 1;
        const pad = { t: 25, r: 20, b: 40 + xOff, l: 55 + yOff };
        const pw = w - pad.l - pad.r, ph = h - pad.t - pad.b, midY = pad.t + ph / 2;
        
        const { minLen, maxLen } = this.M.settings;
        const numL = maxLen - minLen + 1;
        const reps = this.M.replicates;
        
        // Collect data per length per nucleotide per strand
        const dataByLen = { fwd5: {}, rev5: {}, fwd3: {}, rev3: {} };
        for (let l = minLen; l <= maxLen; l++) {
            dataByLen.fwd5[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.rev5[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.fwd3[l] = { A: [], C: [], G: [], T: [], total: [] };
            dataByLen.rev3[l] = { A: [], C: [], G: [], T: [], total: [] };
            
            for (const rep of reps) {
                let fwd5, rev5, fwd3, rev3;
                if (selectedSeg === 'all') {
                    fwd5 = rep.lenDist5?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev5 = rep.lenDist5?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    fwd3 = rep.lenDist3?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev3 = rep.lenDist3?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                } else {
                    const segData = rep.lenDistBySeg?.[selectedSeg];
                    fwd5 = segData?.len5?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev5 = segData?.len5?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    fwd3 = segData?.len3?.fwd?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                    rev3 = segData?.len3?.rev?.[l] || { A: 0, C: 0, G: 0, T: 0 };
                }
                
                for (const nt of 'ACGT') {
                    dataByLen.fwd5[l][nt].push(fwd5[nt] || 0);
                    dataByLen.rev5[l][nt].push(rev5[nt] || 0);
                    dataByLen.fwd3[l][nt].push(fwd3[nt] || 0);
                    dataByLen.rev3[l][nt].push(rev3[nt] || 0);
                }
                dataByLen.fwd5[l].total.push((fwd5.A||0) + (fwd5.C||0) + (fwd5.G||0) + (fwd5.T||0));
                dataByLen.rev5[l].total.push((rev5.A||0) + (rev5.C||0) + (rev5.G||0) + (rev5.T||0));
                dataByLen.fwd3[l].total.push((fwd3.A||0) + (fwd3.C||0) + (fwd3.G||0) + (fwd3.T||0));
                dataByLen.rev3[l].total.push((rev3.A||0) + (rev3.C||0) + (rev3.G||0) + (rev3.T||0));
            }
        }
        
        const fwdKey = topEnd === '5' ? 'fwd5' : 'fwd3';
        const revKey = botEnd === '5' ? 'rev5' : 'rev3';
        const fwdData = dataByLen[fwdKey];
        const revData = dataByLen[revKey];
        
        let librarySize = 0, grandTotal = 0;
        for (const rep of reps) librarySize += rep.stats.total;
        const avgLibSize = librarySize / reps.length || 1;
        for (let l = minLen; l <= maxLen; l++) {
            grandTotal += this.mean(fwdData[l].total) + this.mean(revData[l].total);
        }
        const scale = dataType === 'cpm' ? 1e6 / avgLibSize : dataType === 'pct' ? 100 / (grandTotal || 1) : 1;
        
        // Calculate means and errors
        const fMean = {}, rMean = {}, fErr = {}, rErr = {};
        let maxFwd = 0, maxRev = 0;
        for (let l = minLen; l <= maxLen; l++) {
            fMean[l] = { A: 0, C: 0, G: 0, T: 0, total: 0 };
            rMean[l] = { A: 0, C: 0, G: 0, T: 0, total: 0 };
            for (const nt of 'ACGT') {
                fMean[l][nt] = this.mean(fwdData[l][nt]) * scale;
                rMean[l][nt] = this.mean(revData[l][nt]) * scale;
            }
            fMean[l].total = this.mean(fwdData[l].total) * scale;
            rMean[l].total = this.mean(revData[l].total) * scale;
            const fTotVals = fwdData[l].total.map(v => v * scale);
            const rTotVals = revData[l].total.map(v => v * scale);
            if (errType === 'sem') { fErr[l] = this.sem(fTotVals); rErr[l] = this.sem(rTotVals); }
            else if (errType === 'ci95') { fErr[l] = this.sem(fTotVals) * 1.96; rErr[l] = this.sem(rTotVals) * 1.96; }
            else { fErr[l] = this.std(fTotVals); rErr[l] = this.std(rTotVals); }
            maxFwd = Math.max(maxFwd, fMean[l].total + (showErr ? fErr[l] : 0));
            maxRev = Math.max(maxRev, rMean[l].total + (showErr ? rErr[l] : 0));
        }
        
        const niceMaxFwd = yMaxFwdIn > 0 ? yMaxFwdIn : this.niceNum(maxFwd * 1.1) || 100;
        const niceMaxRev = yMaxRevIn > 0 ? yMaxRevIn : this.niceNum(maxRev * 1.1) || 100;
        
        // Draw axes
        svg.strokeStyle = '#ddd';
        svg.lineWidth = 1;
        svg.beginPath();
        svg.moveTo(pad.l, pad.t);
        svg.lineTo(pad.l, h - pad.b);
        svg.lineTo(w - pad.r, h - pad.b);
        svg.stroke();
        
        // Center line
        svg.strokeStyle = '#ccc';
        svg.beginPath();
        svg.moveTo(pad.l, midY);
        svg.lineTo(w - pad.r, midY);
        svg.stroke();
        
        // Y-axis ticks and labels
        svg.fillStyle = '#000';
        svg.font = `${fontSize}px ${font}`;
        svg.textAlign = 'right';
        const yTicksFwd = this.niceTicks(0, niceMaxFwd, 4);
        const yTicksRev = this.niceTicks(0, niceMaxRev, 4);
        for (const t of yTicksFwd) {
            const y = midY - (t / niceMaxFwd) * (ph / 2);
            svg.beginPath(); svg.moveTo(pad.l - 3, y); svg.lineTo(pad.l, y); svg.stroke();
            svg.fillText(this.fmtNum(t), pad.l - 5, y + 3);
        }
        for (const t of yTicksRev) {
            if (t > 0) {
                const y = midY + (t / niceMaxRev) * (ph / 2);
                svg.beginPath(); svg.moveTo(pad.l - 3, y); svg.lineTo(pad.l, y); svg.stroke();
                svg.fillText(this.fmtNum(t), pad.l - 5, y + 3);
            }
        }
        
        // X-axis labels
        svg.textAlign = 'center';
        for (let l = minLen; l <= maxLen; l += xTick) {
            const x = pad.l + (l - minLen + 0.5) * (pw / numL);
            svg.beginPath(); svg.moveTo(x, midY - 3); svg.lineTo(x, midY + 3); svg.stroke();
            svg.fillText(l.toString(), x, h - pad.b + 15);
        }
        svg.font = `${labelSize}px ${font}`;
        svg.fillText('Read length (nt)', w / 2, h - 5);
        
        // Y-axis label
        svg.save();
        svg.translate(12, h / 2);
        svg.rotate(-Math.PI / 2);
        const yLabel = dataType === 'cpm' ? 'CPM' : dataType === 'pct' ? 'Percentage (%)' : 'Read count';
        svg.fillText(yLabel, 0, 0);
        svg.restore();
        svg.closeGroups();
        
        // Draw bars
        const bw = (pw / numL) * 0.8, gap = (pw / numL) * 0.1;
        for (let l = minLen; l <= maxLen; l++) {
            const x = pad.l + (l - minLen) * (pw / numL) + gap;
            
            // Forward (top) - stack from midY upward
            let yFwd = midY;
            for (const nt of 'ACGT') {
                const val = fMean[l][nt];
                const barH = (val / niceMaxFwd) * (ph / 2);
                if (barH > 0.5) {
                    svg.fillStyle = colors[nt];
                    svg.fillRect(x, yFwd - barH, bw, barH);
                    yFwd -= barH;
                }
            }
            
            // Forward error bar
            if (showErr && reps.length > 1 && fErr[l] > 0) {
                const errH = (fErr[l] / niceMaxFwd) * (ph / 2);
                const midX = x + bw / 2;
                svg.strokeStyle = '#000';
                svg.lineWidth = 1;
                svg.beginPath();
                svg.moveTo(midX, yFwd);
                svg.lineTo(midX, yFwd - errH);
                svg.stroke();
                svg.beginPath();
                svg.moveTo(midX - 3, yFwd - errH);
                svg.lineTo(midX + 3, yFwd - errH);
                svg.stroke();
            }
            
            // Reverse (bottom) - stack from midY downward
            let yRev = midY;
            for (const nt of 'ACGT') {
                const val = rMean[l][nt];
                const barH = (val / niceMaxRev) * (ph / 2);
                if (barH > 0.5) {
                    svg.fillStyle = colors[nt];
                    svg.fillRect(x, yRev, bw, barH);
                    yRev += barH;
                }
            }
            
            // Reverse error bar
            if (showErr && reps.length > 1 && rErr[l] > 0) {
                const errH = (rErr[l] / niceMaxRev) * (ph / 2);
                const midX = x + bw / 2;
                svg.strokeStyle = '#000';
                svg.lineWidth = 1;
                svg.beginPath();
                svg.moveTo(midX, yRev);
                svg.lineTo(midX, yRev + errH);
                svg.stroke();
                svg.beginPath();
                svg.moveTo(midX - 3, yRev + errH);
                svg.lineTo(midX + 3, yRev + errH);
                svg.stroke();
            }
            
            // Individual replicate points
            if (showPts && reps.length > 1) {
                for (let ri = 0; ri < reps.length; ri++) {
                    // Forward points
                    let cumFwd = 0;
                    for (const nt of 'ACGT') {
                        const val = fwdData[l][nt][ri] * scale;
                        cumFwd += val;
                        if (val > 0) {
                            const ptY = midY - (cumFwd / niceMaxFwd) * (ph / 2);
                            const ntIdx = 'ACGT'.indexOf(nt);
                            let ptX = showJitter ? 
                                x + bw/2 + (((ri*7 + ntIdx*3) % 10) / 10 - 0.5) * bw * 0.6 :
                                x + (ntIdx + 0.5) * (bw / 4);
                            svg.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                            svg.beginPath();
                            svg.arc(ptX, ptY, 2, 0, Math.PI * 2);
                            svg.fill();
                            // Add black stroke
                            svg.strokeStyle = '#000';
                            svg.lineWidth = 0.5;
                            svg.beginPath();
                            svg.arc(ptX, ptY, 2, 0, Math.PI * 2);
                            svg.stroke();
                        }
                    }
                    // Reverse points
                    let cumRev = 0;
                    for (const nt of 'ACGT') {
                        const val = revData[l][nt][ri] * scale;
                        cumRev += val;
                        if (val > 0) {
                            const ptY = midY + (cumRev / niceMaxRev) * (ph / 2);
                            const ntIdx = 'ACGT'.indexOf(nt);
                            let ptX = showJitter ? 
                                x + bw/2 + (((ri*7 + ntIdx*3) % 10) / 10 - 0.5) * bw * 0.6 :
                                x + (ntIdx + 0.5) * (bw / 4);
                            svg.fillStyle = this.hexRgba(colors[nt], ptOpacity);
                            svg.beginPath();
                            svg.arc(ptX, ptY, 2, 0, Math.PI * 2);
                            svg.fill();
                            // Add black stroke
                            svg.strokeStyle = '#000';
                            svg.lineWidth = 0.5;
                            svg.beginPath();
                            svg.arc(ptX, ptY, 2, 0, Math.PI * 2);
                            svg.stroke();
                        }
                    }
                }
            }
        }
        
        // Legend
        const showLegend = document.getElementById('len-show-legend')?.checked;
        if (showLegend) {
            const legendItems = [{label:'A',color:colors.A},{label:'C',color:colors.C},{label:'G',color:colors.G},{label:'T/U',color:colors.T}];
            const legFontSize = +document.getElementById('len-leg-font')?.value || 12;
            const legPos = document.getElementById('len-leg-pos')?.value || 'center';
            const legBold = document.getElementById('len-leg-bold')?.checked;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            svg.font = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            let totalWidth = legendItems.reduce((acc, item) => acc + boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap, 0) - itemGap;
            let lx = legPos === 'left' ? pad.l + 10 : legPos === 'right' ? w - pad.r - totalWidth - 10 : (w - totalWidth) / 2;
            const ly = 6;
            for (const item of legendItems) {
                svg.fillStyle = item.color;
                svg.fillRect(lx, ly, boxSize, boxSize);
                svg.strokeStyle = 'rgba(0,0,0,0.3)';
                svg.lineWidth = 0.5;
                svg.strokeRect(lx, ly, boxSize, boxSize);
                svg.fillStyle = '#333';
                svg.textAlign = 'left';
                svg.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap;
            }
        }
    }
    
    drawBiasSVG(svg) {
        // Full vector SVG export for nucleotide bias
        if (!this.M.replicates.length) return;
        
        const w = +document.getElementById('bias-w').value || 700;
        const h = +document.getElementById('bias-h').value || 180;
        const endType = document.getElementById('bias-end').value;
        const strandType = document.getElementById('bias-strand').value;
        const displayType = document.getElementById('bias-type').value;
        const maxBits = +document.getElementById('bias-maxbits').value || 2;
        const xTick = +document.getElementById('bias-xtick').value || 2;
        const selectedSeg = document.getElementById('bias-seg')?.value || 'all';
        const showErr = document.getElementById('bias-err')?.checked && this.M.replicates.length > 1;
        const biasLenMin = +document.getElementById('bias-len-min')?.value || 18;
        const biasLenMax = +document.getElementById('bias-len-max')?.value || 30;
        const colors = getNtColors();
        const font = getFont();
        const fontSize = +document.getElementById('bias-font').value || 10;
        const labelSize = fontSize + 1;
        const errType = document.getElementById('err-type').value;
        const pad = { t: 15, r: 15, b: 35, l: 50 }, pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        
        const numPos = 20;
        const reps = this.M.replicates;
        const { minLen, maxLen } = this.M.settings;
        const filterActive = biasLenMin !== minLen || biasLenMax !== maxLen;
        
        // Collect per-replicate data for each position (simplified - use pre-calculated if no filter)
        const dataByPos = [];
        for (let i = 0; i < numPos; i++) {
            const posData = { perRep: [], combined: { A: 0, C: 0, G: 0, T: 0 } };
            for (const rep of reps) {
                const c = { A: 0, C: 0, G: 0, T: 0 };
                if (strandType === 'both' || strandType === 'fwd') {
                    const d = selectedSeg === 'all' ? 
                        rep.bias?.['fwd' + endType]?.[i] : 
                        rep.biasBySeg?.[selectedSeg]?.['fwd' + endType]?.[i];
                    if (d) for (const nt of 'ACGT') c[nt] += d[nt] || 0;
                }
                if (strandType === 'both' || strandType === 'rev') {
                    const d = selectedSeg === 'all' ? 
                        rep.bias?.['rev' + endType]?.[i] : 
                        rep.biasBySeg?.[selectedSeg]?.['rev' + endType]?.[i];
                    if (d) for (const nt of 'ACGT') c[nt] += d[nt] || 0;
                }
                posData.perRep.push(c);
                for (const nt of 'ACGT') posData.combined[nt] += c[nt];
            }
            dataByPos.push(posData);
        }
        
        // Calculate frequencies/bits
        const meanFreqs = [], errFreqs = [];
        for (let i = 0; i < numPos; i++) {
            const posFreqs = { A: [], C: [], G: [], T: [] };
            for (const repData of dataByPos[i].perRep) {
                const total = repData.A + repData.C + repData.G + repData.T;
                for (const nt of 'ACGT') {
                    posFreqs[nt].push(total > 0 ? repData[nt] / total : 0.25);
                }
            }
            const mf = {}, ef = {};
            for (const nt of 'ACGT') {
                mf[nt] = this.mean(posFreqs[nt]);
                if (errType === 'sem') ef[nt] = this.sem(posFreqs[nt]);
                else if (errType === 'ci95') ef[nt] = this.sem(posFreqs[nt]) * 1.96;
                else ef[nt] = this.std(posFreqs[nt]);
            }
            meanFreqs.push(mf);
            errFreqs.push(ef);
        }
        
        // Draw axes
        svg.strokeStyle = '#000';
        svg.lineWidth = 1;
        svg.beginPath();
        svg.moveTo(pad.l, pad.t);
        svg.lineTo(pad.l, h - pad.b);
        svg.lineTo(w - pad.r, h - pad.b);
        svg.stroke();
        
        const bw = pw / numPos;
        const yMax = displayType === 'bits' ? maxBits : 1;
        const yLabel = displayType === 'bits' ? 'Bits' : 'Frequency';
        
        // Y-axis ticks
        svg.fillStyle = '#000';
        svg.font = `${fontSize}px ${font}`;
        svg.textAlign = 'right';
        const yTicks = displayType === 'bits' ? [0, 0.5, 1, 1.5, 2].filter(t => t <= maxBits) : [0, 0.25, 0.5, 0.75, 1];
        for (const t of yTicks) {
            const y = h - pad.b - (t / yMax) * ph;
            svg.beginPath(); svg.moveTo(pad.l - 3, y); svg.lineTo(pad.l, y); svg.stroke();
            svg.fillText(t.toFixed(displayType === 'bits' ? 1 : 2), pad.l - 5, y + 3);
            if (t > 0) {
                svg.strokeStyle = '#eee';
                svg.beginPath(); svg.moveTo(pad.l, y); svg.lineTo(w - pad.r, y); svg.stroke();
                svg.strokeStyle = '#000';
            }
        }
        
        // X-axis labels
        svg.textAlign = 'center';
        for (let i = 0; i < numPos; i += xTick) {
            const x = pad.l + (i + 0.5) * bw;
            svg.beginPath(); svg.moveTo(x, h - pad.b); svg.lineTo(x, h - pad.b + 4); svg.stroke();
            svg.fillText((i + 1).toString(), x, h - pad.b + 15);
        }
        svg.font = `${labelSize}px ${font}`;
        svg.fillText(`Position from ${endType}‚Ä≤ end`, w / 2, h - 5);
        
        // Y-axis label
        svg.save();
        svg.translate(12, h / 2);
        svg.rotate(-Math.PI / 2);
        svg.fillText(yLabel, 0, 0);
        svg.restore();
        svg.closeGroups();
        
        // Draw stacked bars or lines based on display type
        if (displayType === 'prop') {
            // Proportion mode: stacked bars
            for (let i = 0; i < numPos; i++) {
                const x = pad.l + i * bw + bw * 0.1;
                const barW = bw * 0.8;
                let y = h - pad.b;
                
                for (const nt of 'ACGT') {
                    const val = meanFreqs[i][nt];
                    const barH = (val / yMax) * ph;
                    if (barH > 0.5) {
                        svg.fillStyle = colors[nt];
                        svg.fillRect(x, y - barH, barW, barH);
                        y -= barH;
                    }
                }
                
                // Error bar at top of stacked bar (if enabled)
                // Sum all frequencies = 1.0, so we need to calculate error on the total stack
                // For proportions, error represents uncertainty in the frequency estimates
                if (showErr && reps.length > 1) {
                    // Calculate total error as sqrt of sum of squared errors (propagated)
                    let totalErr = 0;
                    for (const nt of 'ACGT') {
                        totalErr += (errFreqs[i][nt] || 0) ** 2;
                    }
                    totalErr = Math.sqrt(totalErr);
                    const errH = (totalErr / yMax) * ph;
                    if (errH > 1) {
                        const midX = x + barW / 2;
                        svg.strokeStyle = '#000';
                        svg.lineWidth = 1;
                        svg.beginPath();
                        svg.moveTo(midX, y);
                        svg.lineTo(midX, y - errH);
                        svg.stroke();
                        svg.beginPath();
                        svg.moveTo(midX - 3, y - errH);
                        svg.lineTo(midX + 3, y - errH);
                        svg.stroke();
                    }
                }
            }
        } else if (displayType === 'bits') {
            // Bits (logo) mode: stacked scaled letters
            const colW = pw / numPos;
            
            for (let i = 0; i < numPos; i++) {
                const freqs = meanFreqs[i];
                const c = dataByPos[i].combined;
                const total = c.A + c.C + c.G + c.T;
                if (total === 0) continue;
                
                // Calculate information content
                let entropy = 0;
                for (const nt of 'ACGT') {
                    const f = freqs[nt];
                    if (f > 0) entropy -= f * Math.log2(f);
                }
                const info = Math.max(0, 2 - entropy);
                
                // Sort nucleotides by frequency (smallest first for stacking)
                const sorted = 'ACGT'.split('').sort((a, b) => freqs[a] - freqs[b]);
                let y = h - pad.b;
                
                for (const nt of sorted) {
                    const letterH = (freqs[nt] * info / maxBits) * ph;
                    if (letterH < 3) continue;
                    
                    // Draw letter using SVG text with scaling
                    const letterX = pad.l + i * colW + colW / 2;
                    const letterY = y - letterH / 2;
                    
                    // Calculate scale factors for the letter
                    const scaleX = colW * 0.7 / 20;
                    const scaleY = letterH / 20;
                    
                    svg.fillStyle = colors[nt];
                    svg.font = `bold 20px Arial`;
                    svg.textAlign = 'center';
                    
                    // Use transform to scale the letter - must close groups after
                    svg.save();
                    svg.translate(letterX, letterY);
                    svg.scale(scaleX, scaleY);
                    svg.fillText(nt, 0, 0);
                    svg.closeGroups(); // Close transform groups before next letter
                    svg.restore();
                    
                    y -= letterH;
                }
            }
            
            // Draw error bars for bits mode if enabled
            if (showErr && reps.length > 1) {
                for (let i = 0; i < numPos; i++) {
                    // Calculate per-replicate info content
                    const repInfos = dataByPos[i].perRep.map(rep => {
                        const t = rep.A + rep.C + rep.G + rep.T;
                        if (t === 0) return 0;
                        let e = 0;
                        for (const nt of 'ACGT') {
                            const f = rep[nt] / t;
                            if (f > 0) e -= f * Math.log2(f);
                        }
                        return Math.max(0, 2 - e);
                    });
                    
                    const meanInfo = this.mean(repInfos);
                    let errInfo;
                    if (errType === 'sem') errInfo = this.sem(repInfos);
                    else if (errType === 'ci95') errInfo = this.sem(repInfos) * 1.96;
                    else errInfo = this.std(repInfos);
                    
                    if (errInfo > 0.01) {
                        const x = pad.l + (i + 0.5) * bw;
                        const yMean = h - pad.b - (meanInfo / maxBits) * ph;
                        const errH = (errInfo / maxBits) * ph;
                        
                        svg.strokeStyle = '#000';
                        svg.lineWidth = 1;
                        svg.beginPath();
                        svg.moveTo(x, yMean);
                        svg.lineTo(x, yMean - errH);
                        svg.stroke();
                        svg.beginPath();
                        svg.moveTo(x - 2, yMean - errH);
                        svg.lineTo(x + 2, yMean - errH);
                        svg.stroke();
                    }
                }
            }
        } else if (displayType === 'line') {
            // Line chart for each nucleotide
            for (const nt of 'ACGT') {
                svg.strokeStyle = colors[nt];
                svg.lineWidth = 1.5;
                svg.beginPath();
                for (let i = 0; i < numPos; i++) {
                    const x = pad.l + (i + 0.5) * bw;
                    const y = h - pad.b - (meanFreqs[i][nt] / yMax) * ph;
                    if (i === 0) svg.moveTo(x, y);
                    else svg.lineTo(x, y);
                }
                svg.stroke();
                
                // Error ribbons if enabled
                if (showErr && reps.length > 1) {
                    svg.fillStyle = this.hexRgba(colors[nt], 0.2);
                    svg.beginPath();
                    for (let i = 0; i < numPos; i++) {
                        const x = pad.l + (i + 0.5) * bw;
                        const y = h - pad.b - ((meanFreqs[i][nt] + errFreqs[i][nt]) / yMax) * ph;
                        if (i === 0) svg.moveTo(x, y);
                        else svg.lineTo(x, y);
                    }
                    for (let i = numPos - 1; i >= 0; i--) {
                        const x = pad.l + (i + 0.5) * bw;
                        const y = h - pad.b - ((meanFreqs[i][nt] - errFreqs[i][nt]) / yMax) * ph;
                        svg.lineTo(x, y);
                    }
                    svg.closePath();
                    svg.fill();
                }
            }
        }
        
        // Legend
        const showLegend = document.getElementById('bias-show-legend')?.checked;
        if (showLegend) {
            const legendItems = [{label:'A',color:colors.A},{label:'C',color:colors.C},{label:'G',color:colors.G},{label:'T/U',color:colors.T}];
            const legFontSize = +document.getElementById('bias-leg-font')?.value || 12;
            const legPos = document.getElementById('bias-leg-pos')?.value || 'center';
            const legBold = document.getElementById('bias-leg-bold')?.checked;
            const legXoff = +document.getElementById('bias-leg-xoff')?.value || 15;
            const legYoff = +document.getElementById('bias-leg-yoff')?.value || 0;
            const boxSize = Math.max(10, legFontSize);
            const itemGap = 12;
            svg.font = `${legBold ? 'bold ' : ''}${legFontSize}px ${font}`;
            let totalWidth = legendItems.reduce((acc, item) => acc + boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap, 0) - itemGap;
            let lx = legPos === 'left' ? pad.l + legXoff : legPos === 'right' ? w - pad.r - totalWidth - legXoff : (w - totalWidth) / 2;
            const ly = -15 + legYoff; // Move legend up by default, with offset control
            for (const item of legendItems) {
                svg.fillStyle = item.color;
                svg.fillRect(lx, ly, boxSize, boxSize);
                svg.strokeStyle = 'rgba(0,0,0,0.3)';
                svg.lineWidth = 0.5;
                svg.strokeRect(lx, ly, boxSize, boxSize);
                svg.fillStyle = '#333';
                svg.textAlign = 'left';
                svg.fillText(item.label, lx + boxSize + 5, ly + boxSize - 2);
                lx += boxSize + 5 + legFontSize * item.label.length * 0.6 + itemGap;
            }
        }
    }
    
    drawOvlSVG(svg) {
        // Full vector SVG export for overlap 4-panel
        const seg = document.getElementById('ovl-seg').value;
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        const w = +document.getElementById('ovl-w').value || 800;
        const h = +document.getElementById('ovl-h').value || 500;
        const font = getFont();
        const fontSize = +document.getElementById('ovl-font').value || 14;
        const titleSize = +document.getElementById('ovl-title-size')?.value || 14;
        const titleBold = document.getElementById('ovl-title-bold')?.checked;
        const showSubtitles = document.getElementById('ovl-show-subtitles')?.checked;
        const xOff = +document.getElementById('ovl-xoff')?.value || 0;
        const yOff = +document.getElementById('ovl-yoff')?.value || 0;
        const showBorder = document.getElementById('ovl-show-border')?.checked;
        const show10line = document.getElementById('ovl-show-10line')?.checked;
        const normalizeRPM = document.getElementById('ovl-normalize-rpm')?.checked || false;
        
        const qmin = this.ovlSettings?.qmin || 18;
        const qmax = this.ovlSettings?.qmax || 30;
        const tmin = this.ovlSettings?.tmin || 18;
        const tmax = this.ovlSettings?.tmax || 30;
        const omin = this.ovlSettings?.omin || -10;
        const omax = this.ovlSettings?.omax || 30;
        
        const allCounts = ovlData.counts?.['all'] || {};
        const allProbs = ovlData.probs?.['all'] || {};
        const allCountZ = ovlData.countZscores?.['all'] || {};
        const allProbZ = ovlData.probZscores?.['all'] || {};
        
        const repLibSizes = this.M.replicates.map(rep => rep.stats?.total || 1);
        
        // Get data with optional RPM normalization
        const getData = (key) => {
            if (key === 'counts' && normalizeRPM) {
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                    if (perRepVals.length > 0) {
                        const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                        arr.push(scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length);
                    } else {
                        arr.push(allCounts[o] || 0);
                    }
                }
                return arr;
            }
            const obj = key === 'counts' ? allCounts : key === 'probs' ? allProbs : key === 'countZscores' ? allCountZ : allProbZ;
            const arr = [];
            for (let o = omin; o <= omax; o++) arr.push(obj[o] || 0);
            return arr;
        };
        
        const getSEM = (key) => {
            if (!ovlData.sem?.[key]?.['all']) return null;
            if (key === 'counts' && normalizeRPM) {
                const arr = [];
                for (let o = omin; o <= omax; o++) {
                    const perRepVals = ovlData.perRep?.counts?.['all']?.[o] || [];
                    if (perRepVals.length > 1) {
                        const scaledVals = perRepVals.map((v, ri) => v * 1e6 / repLibSizes[ri]);
                        const mean = scaledVals.reduce((a, b) => a + b, 0) / scaledVals.length;
                        const variance = scaledVals.reduce((a, v) => a + (v - mean) ** 2, 0) / scaledVals.length;
                        arr.push(Math.sqrt(variance / scaledVals.length));
                    } else arr.push(0);
                }
                return arr;
            }
            const arr = [];
            for (let o = omin; o <= omax; o++) arr.push(ovlData.sem[key]['all'][o] || 0);
            return arr;
        };
        
        const getPerRep = (key) => {
            if (!ovlData.perRep?.[key]?.['all']) return null;
            const arr = [];
            for (let o = omin; o <= omax; o++) {
                const repVals = ovlData.perRep[key]['all'][o] || [];
                // Apply per-replicate RPM scaling for counts
                if (key === 'counts' && normalizeRPM) {
                    arr.push(repVals.map((v, ri) => v * 1e6 / repLibSizes[ri]));
                } else {
                    arr.push(repVals);
                }
            }
            return arr;
        };
        
        // Title
        svg.fillStyle = '#000';
        svg.font = `${titleBold ? 'bold ' : ''}${titleSize}px ${font}`;
        svg.textAlign = 'center';
        svg.fillText(`Overlap Signatures of ${qmin}-${qmax} against ${tmin}-${tmax}nt small RNAs`, w / 2, 15);
        
        // Panel layout
        const margin = 20;
        const titleH = 25;
        const pw = (w - margin * 3) / 2;
        const ph = (h - titleH - margin * 3) / 2;
        
        const panels = [
            { x: margin, y: titleH + margin, data: 'counts', type: 'box', title: 'Number of pairs' },
            { x: margin * 2 + pw, y: titleH + margin, data: 'countZscores', type: 'line', title: 'Number of pairs z-scores' },
            { x: margin, y: titleH + margin * 2 + ph, data: 'probs', type: 'box', title: 'Overlap probabilities' },
            { x: margin * 2 + pw, y: titleH + margin * 2 + ph, data: 'probZscores', type: 'line', title: 'Overlap probability z-scores' }
        ];
        
        const yMaxCounts = +document.getElementById('ovl-ymax-counts')?.value || 0;
        const yMaxProbs = +document.getElementById('ovl-ymax-probs')?.value || 0;
        const yMaxZ = +document.getElementById('ovl-ymax-z')?.value || 0;
        const showErr = document.getElementById('ovl-err')?.checked;
        const showPts = document.getElementById('ovl-pts')?.checked;
        
        for (const panel of panels) {
            const data = getData(panel.data);
            const semData = getSEM(panel.data);
            const perRepData = getPerRep(panel.data);
            const pad = { t: 25, r: 10, b: 35 + yOff, l: 50 + xOff };
            const plotW = pw - pad.l - pad.r;
            const plotH = ph - pad.t - pad.b;
            const x0 = panel.x + pad.l;
            const y0 = panel.y + pad.t;
            
            const isZscore = panel.data.includes('Zscore');
            let minV, maxV;
            
            if (isZscore) {
                if (yMaxZ > 0) { maxV = yMaxZ; minV = -yMaxZ; }
                else {
                    let absMax = 1;
                    for (let i = 0; i < data.length; i++) {
                        const err = semData ? (semData[i] || 0) : 0;
                        absMax = Math.max(absMax, Math.abs(data[i]) + err);
                    }
                    maxV = Math.ceil(absMax * 1.2);
                    minV = -maxV;
                }
            } else if (panel.data === 'counts') {
                minV = 0;
                let mx = 0;
                for (let i = 0; i < data.length; i++) mx = Math.max(mx, data[i] + (semData?.[i] || 0));
                maxV = yMaxCounts > 0 ? yMaxCounts : this.niceNum(mx * 1.15) || 100;
            } else {
                minV = 0;
                let mx = 0;
                for (let i = 0; i < data.length; i++) mx = Math.max(mx, data[i] + (semData?.[i] || 0));
                maxV = yMaxProbs > 0 ? yMaxProbs : (mx <= 0.1 ? 0.1 : mx <= 0.5 ? 0.5 : mx <= 1 ? 1 : Math.ceil(mx));
            }
            
            // Panel background
            svg.fillStyle = '#fff';
            svg.fillRect(panel.x, panel.y, pw, ph);
            if (showBorder) {
                svg.strokeStyle = '#ddd';
                svg.lineWidth = 1;
                svg.strokeRect(panel.x, panel.y, pw, ph);
            }
            
            // Panel title
            if (showSubtitles) {
                svg.fillStyle = '#000';
                svg.font = `bold ${fontSize - 1}px ${font}`;
                svg.textAlign = 'center';
                svg.fillText(panel.title, panel.x + pw / 2, panel.y + 12);
            }
            
            // Axes
            svg.strokeStyle = '#ddd';
            svg.lineWidth = 1;
            svg.beginPath();
            svg.moveTo(x0, y0);
            svg.lineTo(x0, y0 + plotH);
            svg.lineTo(x0 + plotW, y0 + plotH);
            svg.stroke();
            
            // Zero line for z-scores
            if (isZscore) {
                svg.strokeStyle = '#000';
                svg.setLineDash([3, 3]);
                const zeroY = y0 + plotH - ((0 - minV) / (maxV - minV)) * plotH;
                svg.beginPath();
                svg.moveTo(x0, zeroY);
                svg.lineTo(x0 + plotW, zeroY);
                svg.stroke();
                svg.setLineDash([]);
            }
            
            // 10nt vertical line
            if (show10line && 10 >= omin && 10 <= omax) {
                const idx10 = 10 - omin;
                const x10 = x0 + (idx10 + 0.5) * (plotW / data.length);
                svg.strokeStyle = 'rgba(255,0,0,0.3)';
                svg.setLineDash([5, 5]);
                svg.beginPath();
                svg.moveTo(x10, y0);
                svg.lineTo(x10, y0 + plotH);
                svg.stroke();
                svg.setLineDash([]);
            }
            
            // Y-axis ticks
            svg.fillStyle = '#000';
            svg.font = `${fontSize - 1}px ${font}`;
            svg.textAlign = 'right';
            const numYTicks = isZscore ? 5 : 4;
            for (let i = 0; i <= numYTicks; i++) {
                const v = minV + (maxV - minV) * (i / numYTicks);
                const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                let label = isZscore ? v.toFixed(1) : panel.data === 'probs' ? v.toFixed(2) : this.fmtNum(v);
                svg.fillText(label, x0 - 5, y + 3);
            }
            
            // X-axis labels
            svg.textAlign = 'center';
            const numBars = omax - omin + 1;
            const barW = plotW / numBars;
            for (let i = 0; i < numBars; i += 2) {
                const ovl = omin + i;
                const x = x0 + (i + 0.5) * barW;
                svg.fillText(ovl.toString(), x, y0 + plotH + 12);
            }
            
            svg.font = `${fontSize}px ${font}`;
            svg.fillText('overlap (nt)', panel.x + pw / 2, panel.y + ph - 5);
            
            // Y-axis label
            svg.save();
            svg.translate(panel.x + 10, panel.y + ph / 2);
            svg.rotate(-Math.PI / 2);
            const yLabel = panel.data === 'counts' ? (normalizeRPM ? 'Pairs per million' : 'Numbers of pairs') :
                          panel.data === 'probs' ? 'Probability [%]' : 'z-score';
            svg.fillText(yLabel, 0, 0);
            svg.restore();
            svg.closeGroups();
            
            // Draw data
            if (panel.type === 'box') {
                // Draw box-whisker plots when we have replicate data, otherwise bars
                if (perRepData && perRepData[0]?.length > 1) {
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals || repVals.length === 0) continue;
                        
                        // Sort values for quartile calculation
                        const sorted = [...repVals].filter(v => !isNaN(v)).sort((a, b) => a - b);
                        if (sorted.length === 0) continue;
                        
                        const n = sorted.length;
                        const min = sorted[0];
                        const max = sorted[n - 1];
                        const median = n % 2 === 0 ? (sorted[Math.floor(n/2) - 1] + sorted[Math.floor(n/2)]) / 2 : sorted[Math.floor(n/2)];
                        const q1 = sorted[Math.floor(n * 0.25)];
                        const q3 = sorted[Math.floor(n * 0.75)];
                        
                        const x = x0 + (i + 0.5) * barW;
                        const boxW = barW * 0.6;
                        
                        // Convert to Y coordinates
                        const yMin = y0 + plotH - ((min - minV) / (maxV - minV)) * plotH;
                        const yMax = y0 + plotH - ((max - minV) / (maxV - minV)) * plotH;
                        const yMedian = y0 + plotH - ((median - minV) / (maxV - minV)) * plotH;
                        const yQ1 = y0 + plotH - ((q1 - minV) / (maxV - minV)) * plotH;
                        const yQ3 = y0 + plotH - ((q3 - minV) / (maxV - minV)) * plotH;
                        
                        // Draw whiskers (min to Q1, Q3 to max)
                        svg.strokeStyle = '#4a5568';
                        svg.lineWidth = 1;
                        // Lower whisker
                        svg.beginPath();
                        svg.moveTo(x, yQ1);
                        svg.lineTo(x, yMin);
                        svg.stroke();
                        svg.beginPath();
                        svg.moveTo(x - boxW/4, yMin);
                        svg.lineTo(x + boxW/4, yMin);
                        svg.stroke();
                        // Upper whisker
                        svg.beginPath();
                        svg.moveTo(x, yQ3);
                        svg.lineTo(x, yMax);
                        svg.stroke();
                        svg.beginPath();
                        svg.moveTo(x - boxW/4, yMax);
                        svg.lineTo(x + boxW/4, yMax);
                        svg.stroke();
                        
                        // Draw box (Q1 to Q3)
                        svg.fillStyle = 'rgba(74, 85, 104, 0.3)';
                        svg.fillRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        svg.strokeStyle = '#4a5568';
                        svg.lineWidth = 1;
                        svg.strokeRect(x - boxW/2, yQ3, boxW, yQ1 - yQ3);
                        
                        // Draw median line
                        svg.strokeStyle = '#000';
                        svg.lineWidth = 2;
                        svg.beginPath();
                        svg.moveTo(x - boxW/2, yMedian);
                        svg.lineTo(x + boxW/2, yMedian);
                        svg.stroke();
                        
                        // Draw individual points if enabled
                        if (showPts) {
                            for (let ri = 0; ri < repVals.length; ri++) {
                                const v = repVals[ri];
                                if (isNaN(v)) continue;
                                const jitter = ((ri % 5) / 5 - 0.4) * boxW * 0.6;
                                const ptX = x + jitter;
                                const ptY = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                                svg.fillStyle = 'rgba(37, 99, 235, 0.7)';
                                svg.beginPath();
                                svg.arc(ptX, ptY, 3, 0, Math.PI * 2);
                                svg.fill();
                                // Add black stroke to points
                                svg.strokeStyle = '#000';
                                svg.lineWidth = 0.5;
                                svg.beginPath();
                                svg.arc(ptX, ptY, 3, 0, Math.PI * 2);
                                svg.stroke();
                            }
                        }
                    }
                } else {
                    // Fallback to simple bars for single replicate
                    for (let i = 0; i < data.length; i++) {
                        const val = data[i];
                        if (isNaN(val) || val === 0) continue;
                        const x = x0 + i * barW + barW * 0.15;
                        const bw = barW * 0.7;
                        const barH = ((val - minV) / (maxV - minV)) * plotH;
                        const y = y0 + plotH - barH;
                        svg.fillStyle = 'rgba(74, 85, 104, 0.6)';
                        svg.fillRect(x, y, bw, barH);
                        svg.strokeStyle = 'rgba(74, 85, 104, 0.8)';
                        svg.lineWidth = 0.5;
                        svg.strokeRect(x, y, bw, barH);
                        
                        // Error bar
                        if (showErr && semData && semData[i] > 0) {
                            const errH = (semData[i] / (maxV - minV)) * plotH;
                            const midX = x + bw / 2;
                            svg.strokeStyle = '#000';
                            svg.lineWidth = 1;
                            svg.beginPath();
                            svg.moveTo(midX, y);
                            svg.lineTo(midX, y - errH);
                            svg.stroke();
                            svg.beginPath();
                            svg.moveTo(midX - 3, y - errH);
                            svg.lineTo(midX + 3, y - errH);
                            svg.stroke();
                        }
                    }
                }
            } else {
                // Line chart
                
                // Error ribbon
                if (showErr && semData) {
                    svg.fillStyle = 'rgba(49, 130, 206, 0.15)';
                    svg.beginPath();
                    for (let i = 0; i < data.length; i++) {
                        const x = x0 + (i + 0.5) * barW;
                        const y = y0 + plotH - ((data[i] + (semData[i] || 0) - minV) / (maxV - minV)) * plotH;
                        if (i === 0) svg.moveTo(x, y);
                        else svg.lineTo(x, y);
                    }
                    for (let i = data.length - 1; i >= 0; i--) {
                        const x = x0 + (i + 0.5) * barW;
                        const y = y0 + plotH - ((data[i] - (semData[i] || 0) - minV) / (maxV - minV)) * plotH;
                        svg.lineTo(x, y);
                    }
                    svg.closePath();
                    svg.fill();
                }
                
                // Draw individual replicate points if enabled
                if (showPts && perRepData) {
                    for (let i = 0; i < data.length; i++) {
                        const repVals = perRepData[i];
                        if (!repVals) continue;
                        for (let ri = 0; ri < repVals.length; ri++) {
                            const v = repVals[ri];
                            if (isNaN(v)) continue;
                            const x = x0 + (i + 0.5) * barW;
                            const y = y0 + plotH - ((v - minV) / (maxV - minV)) * plotH;
                            svg.fillStyle = 'rgba(37, 99, 235, 0.3)';
                            svg.beginPath();
                            svg.arc(x, y, 2, 0, Math.PI * 2);
                            svg.fill();
                        }
                    }
                }
                
                // Main line
                svg.strokeStyle = '#3182ce';
                svg.lineWidth = 2;
                svg.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((data[i] - minV) / (maxV - minV)) * plotH;
                    if (i === 0) svg.moveTo(x, y);
                    else svg.lineTo(x, y);
                }
                svg.stroke();
                
                // Points with black stroke (mean points)
                for (let i = 0; i < data.length; i++) {
                    const x = x0 + (i + 0.5) * barW;
                    const y = y0 + plotH - ((data[i] - minV) / (maxV - minV)) * plotH;
                    svg.fillStyle = '#3182ce';
                    svg.beginPath();
                    svg.arc(x, y, 3, 0, Math.PI * 2);
                    svg.fill();
                    svg.strokeStyle = '#000';
                    svg.lineWidth = 0.5;
                    svg.beginPath();
                    svg.arc(x, y, 3, 0, Math.PI * 2);
                    svg.stroke();
                }
            }
        }
    }
    
    drawOvlHeatmapSVG(svg) {
        // Full vector SVG export for overlap heatmap
        const seg = document.getElementById('ovl-hm-seg')?.value || document.getElementById('ovl-seg')?.value || 'all';
        const ovlData = this.ovlData[seg];
        if (!ovlData) return;
        
        const w = +document.getElementById('ovl-hm-w')?.value || 700;
        const h = +document.getElementById('ovl-hm-h')?.value || 350;
        const font = getFont();
        const fontSize = +document.getElementById('ovl-hm-font')?.value || 14;
        const labelSize = fontSize + 1;
        const dataType = document.getElementById('ovl-hm-data')?.value || 'z';
        const colorScheme = document.getElementById('ovl-hm-colors')?.value || 'blue-red';
        const customZmin = document.getElementById('ovl-hm-zmin')?.value;
        const customZmax = document.getElementById('ovl-hm-zmax')?.value;
        
        const qmin = +document.getElementById('ovl-hm-qmin')?.value || this.ovlSettings?.qmin || 18;
        const qmax = +document.getElementById('ovl-hm-qmax')?.value || this.ovlSettings?.qmax || 30;
        const omin = +document.getElementById('ovl-hm-omin')?.value || this.ovlSettings?.omin || -10;
        const omax = +document.getElementById('ovl-hm-omax')?.value || this.ovlSettings?.omax || 30;
        const tmin = this.ovlSettings?.tmin || qmin;
        const tmax = this.ovlSettings?.tmax || qmax;
        
        let data;
        // Support new data type options: pz = probability z-score, cz = count z-score
        if (dataType === 'pz' || dataType === 'z') data = ovlData.probZscores;
        else if (dataType === 'cz') data = ovlData.countZscores;
        else if (dataType === 'p') data = ovlData.probs;
        else data = ovlData.counts;
        
        // Calculate min/max
        let minV = Infinity, maxV = -Infinity;
        for (let qlen = qmin; qlen <= qmax; qlen++) {
            for (let ovl = omin; ovl <= omax; ovl++) {
                const v = data[qlen]?.[ovl] || 0;
                if (v !== 0) { minV = Math.min(minV, v); maxV = Math.max(maxV, v); }
            }
        }
        for (let ovl = omin; ovl <= omax; ovl++) {
            const v = data['all']?.[ovl] || 0;
            if (v !== 0) { minV = Math.min(minV, v); maxV = Math.max(maxV, v); }
        }
        if (minV === Infinity) minV = 0;
        if (maxV === -Infinity) maxV = 1;
        if (customZmin !== '' && !isNaN(+customZmin)) minV = +customZmin;
        if (customZmax !== '' && !isNaN(+customZmax)) maxV = +customZmax;
        
        // Color function
        const getCol = v => {
            // z-score coloring for both pz (probability) and cz (count) z-scores
            if (dataType === 'pz' || dataType === 'cz' || dataType === 'z') {
                let n;
                if (v >= 0) n = maxV > 0 ? Math.min(v / maxV, 1) : 0;
                else n = minV < 0 ? Math.max(v / Math.abs(minV), -1) : 0;
                
                if (colorScheme === 'blue-red') {
                    // Blue to Pink (via white at 0)
                    if (n < 0) { 
                        // Negative: white to cyan-blue
                        const t = Math.min(-n, 1); 
                        return `rgb(${Math.round(255*(1-t))},${Math.round(255*(1-t*0.5))},255)`; 
                    } else { 
                        // Positive: white to pink/magenta
                        const t = Math.min(n, 1); 
                        return `rgb(255,${Math.round(255*(1-t*0.8))},${Math.round(255*(1-t*0.4))})`; 
                    }
                } else if (colorScheme === 'cool-warm') {
                    if (n < 0) { const t = Math.min(-n, 1); return `rgb(${Math.round(100+155*(1-t))},${Math.round(149+106*(1-t))},${Math.round(237+18*(1-t))})`; }
                    else { const t = Math.min(n, 1); return `rgb(255,${Math.round(255*(1-t))},${Math.round(255*(1-t))})`; }
                } else if (colorScheme === 'viridis') {
                    // Viridis: lowest (#46085B) -> zero (#472F7D) -> mid-positive (#27808E) -> top (#FCE724)
                    if (n <= 0) {
                        const t = (n + 1);
                        return `rgb(${Math.round(70 + t * 1)},${Math.round(8 + t * 39)},${Math.round(91 + t * 34)})`;
                    } else if (n <= 0.5) {
                        const t = n * 2;
                        return `rgb(${Math.round(71 + t * (39 - 71))},${Math.round(47 + t * (128 - 47))},${Math.round(125 + t * (142 - 125))})`;
                    } else {
                        const t = (n - 0.5) * 2;
                        return `rgb(${Math.round(39 + t * (252 - 39))},${Math.round(128 + t * (231 - 128))},${Math.round(142 + t * (36 - 142))})`;
                    }
                } else { // plasma
                    const t = Math.max(0, Math.min(1, (n + 1) / 2));
                    if (t < 0.33) return `rgb(${Math.round(13+t*3*110)},${Math.round(8)},${Math.round(135+t*3*80)})`;
                    else if (t < 0.66) return `rgb(${Math.round(123+(t-0.33)*3*117)},${Math.round(8+(t-0.33)*3*65)},${Math.round(215-(t-0.33)*3*130)})`;
                    else return `rgb(${Math.round(240+(t-0.66)*3*15)},${Math.round(73+(t-0.66)*3*175)},${Math.round(85-(t-0.66)*3*67)})`;
                }
            } else {
                const n = maxV > 0 ? Math.min(v / maxV, 1) : 0;
                return `rgb(255,${Math.round(255*(1-n*0.8))},${Math.round(255*(1-n*0.4))})`;
            }
        };
        
        // Title
        svg.fillStyle = '#000';
        svg.font = `bold ${fontSize + 1}px ${font}`;
        svg.textAlign = 'center';
        svg.fillText(`Overlap Heatmap: ${qmin}-${qmax}nt (+) vs ${tmin}-${tmax}nt (‚àí)`, w / 2, 15);
        
        const titleOffset = 20;
        const pad = { t: titleOffset + 25, r: 55, b: 45, l: 45 };
        const pw = w - pad.l - pad.r, ph = h - pad.t - pad.b;
        
        const numLens = qmax - qmin + 2; // +1 for 'all' column
        const numOvls = omax - omin + 1;
        const cw = pw / numLens, ch = ph / numOvls;
        
        // Draw heatmap cells
        for (let li = 0; li < numLens - 1; li++) {
            const qlen = qmin + li;
            for (let oi = 0; oi < numOvls; oi++) {
                const ovl = omin + oi;
                if (ovl > 0 && ovl > qlen) continue;
                const v = data[qlen]?.[ovl] || 0;
                svg.fillStyle = getCol(v);
                svg.fillRect(pad.l + li * cw, pad.t + oi * ch, cw - 0.5, ch - 0.5);
            }
        }
        
        // 'all' column
        for (let oi = 0; oi < numOvls; oi++) {
            const ovl = omin + oi;
            const v = data['all']?.[ovl] || 0;
            svg.fillStyle = getCol(v);
            svg.fillRect(pad.l + (numLens - 1) * cw, pad.t + oi * ch, cw - 0.5, ch - 0.5);
        }
        
        // Separator line before 'all' column
        svg.strokeStyle = '#000';
        svg.lineWidth = 1;
        svg.beginPath();
        svg.moveTo(pad.l + (numLens - 1) * cw, pad.t);
        svg.lineTo(pad.l + (numLens - 1) * cw, pad.t + ph);
        svg.stroke();
        
        // Zero line
        if (omin < 0 && omax > 0) {
            const zeroOi = -omin;
            const zeroY = pad.t + zeroOi * ch;
            svg.strokeStyle = '#888';
            svg.setLineDash([3, 3]);
            svg.beginPath();
            svg.moveTo(pad.l, zeroY);
            svg.lineTo(pad.l + pw, zeroY);
            svg.stroke();
            svg.setLineDash([]);
        }
        
        // Axis labels
        svg.fillStyle = '#000';
        svg.font = `${fontSize - 1}px ${font}`;
        svg.textAlign = 'center';
        for (let li = 0; li < numLens - 1; li += 2) {
            const qlen = qmin + li;
            svg.fillText(qlen.toString(), pad.l + (li + 0.5) * cw, h - pad.b + 12);
        }
        svg.fillText(`${qmin}-${qmax}`, pad.l + (numLens - 0.5) * cw, h - pad.b + 12);
        
        svg.textAlign = 'right';
        for (let ovl = omin; ovl <= omax; ovl += 2) {
            svg.fillText(ovl.toString(), pad.l - 5, pad.t + (ovl - omin + 0.5) * ch + 3);
        }
        
        svg.font = `${labelSize}px ${font}`;
        svg.textAlign = 'center';
        svg.fillText('Query length (nt)', w / 2, h - 5);
        svg.save();
        svg.translate(12, h / 2);
        svg.rotate(-Math.PI / 2);
        svg.fillText('Overlap (nt)', 0, 0);
        svg.restore();
        svg.closeGroups();
        
        // Legend
        const lx = w - pad.r + 10, ly = pad.t, lh = ph, lw = 12;
        // Draw legend gradient as individual rectangles
        const numSteps = 50;
        for (let i = 0; i < numSteps; i++) {
            const t = i / numSteps;
            const v = maxV - t * (maxV - minV);
            svg.fillStyle = getCol(v);
            svg.fillRect(lx, ly + t * lh, lw, lh / numSteps + 1);
        }
        svg.strokeStyle = '#ccc';
        svg.lineWidth = 1;
        svg.strokeRect(lx, ly, lw, lh);
        
        // Legend labels
        svg.fillStyle = '#000';
        svg.font = '8px system-ui';
        svg.textAlign = 'left';
        svg.fillText(maxV.toFixed(1), lx + lw + 3, ly + 6);
        if (dataType === 'z' && minV < 0 && maxV > 0) {
            const zeroY = ly + ((maxV - 0) / (maxV - minV)) * lh;
            svg.fillText('0', lx + lw + 3, zeroY + 3);
        }
        svg.fillText(minV.toFixed(1), lx + lw + 3, ly + lh - 2);
    }
    
    canvasToSVGFallback(svg, canvasId) {
        // For complex plots, embed high-res PNG in SVG
        const canvas = document.getElementById(canvasId);
        const w = parseInt(canvas.style.width);
        const h = parseInt(canvas.style.height);
        const scale = 3;
        const hiRes = document.createElement('canvas');
        hiRes.width = w * scale;
        hiRes.height = h * scale;
        const ctx = hiRes.getContext('2d');
        ctx.scale(scale, scale);
        ctx.drawImage(canvas, 0, 0, w, h);
        const url = hiRes.toDataURL('image/png', 1.0);
        // Add as embedded image with proper attributes
        svg.elements.push(`<image href="${url}" width="${w}" height="${h}" image-rendering="optimizeQuality"/>`);
    }
    
    // Export as high-resolution PNG
    expPNG(canvasId, name) {
        const canvas = document.getElementById(canvasId);
        // Canvas is already at devicePixelRatio scale, which is typically 2x on modern displays
        // For 300dpi export, we may want to scale further
        // Current canvas size gives ~192dpi at 2x DPR on 96dpi screen
        // To get 300dpi, we'd need ~3.125x scale
        
        // Create a high-res version by redrawing at higher scale
        const scale = 3; // This gives ~288dpi on most screens, close to 300
        const w = parseInt(canvas.style.width);
        const h = parseInt(canvas.style.height);
        
        // Create a temporary high-res canvas
        const hiRes = document.createElement('canvas');
        hiRes.width = w * scale;
        hiRes.height = h * scale;
        const ctx = hiRes.getContext('2d');
        
        // Draw the original canvas scaled up
        ctx.scale(scale, scale);
        ctx.drawImage(canvas, 0, 0, w, h);
        
        const url = hiRes.toDataURL('image/png', 1.0);
        const a = document.createElement('a');
        a.href = url;
        a.download = `srnamap_${name}_300dpi.png`;
        a.click();
    }
    
    // Export as PDF (creates a proper vector PDF)
    expPDF(canvasId, name) {
        const canvas = document.getElementById(canvasId);
        const w = parseInt(canvas.style.width);
        const h = parseInt(canvas.style.height);
        
        // Create a high-resolution render for PDF embedding
        const scale = 4; // Higher scale for better PDF quality
        const hiRes = document.createElement('canvas');
        hiRes.width = w * scale;
        hiRes.height = h * scale;
        const ctx = hiRes.getContext('2d');
        ctx.scale(scale, scale);
        ctx.drawImage(canvas, 0, 0, w, h);
        
        // PDF page size in points (1 point = 1/72 inch)
        // Use actual pixel dimensions scaled appropriately
        const aspectRatio = w / h;
        let pdfW, pdfH;
        if (aspectRatio > 1) {
            pdfW = Math.min(842, w * 1.2); // A4 landscape max width
            pdfH = pdfW / aspectRatio;
        } else {
            pdfH = Math.min(842, h * 1.2);
            pdfW = pdfH * aspectRatio;
        }
        
        // Convert to JPEG with high quality for smaller file size
        const jpegCanvas = document.createElement('canvas');
        jpegCanvas.width = w * scale;
        jpegCanvas.height = h * scale;
        const jpegCtx = jpegCanvas.getContext('2d');
        jpegCtx.fillStyle = '#ffffff';
        jpegCtx.fillRect(0, 0, jpegCanvas.width, jpegCanvas.height);
        jpegCtx.drawImage(hiRes, 0, 0);
        const jpegData = jpegCanvas.toDataURL('image/jpeg', 0.95);
        const jpegBase64 = jpegData.split(',')[1];
        const jpegBytes = atob(jpegBase64);
        const jpegLen = jpegBytes.length;
        
        // Build PDF with proper structure
        const contentStream = `q ${pdfW.toFixed(2)} 0 0 ${pdfH.toFixed(2)} 0 0 cm /Img Do Q`;
        
        // Calculate object offsets for xref table
        let offset = 0;
        const offsets = [];
        
        // PDF header
        let pdfStr = '%PDF-1.4\n%\xFF\xFF\xFF\xFF\n';
        offset = pdfStr.length;
        
        // Object 1: Catalog
        offsets[1] = offset;
        const obj1 = '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n';
        pdfStr += obj1;
        offset += obj1.length;
        
        // Object 2: Pages
        offsets[2] = offset;
        const obj2 = '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n';
        pdfStr += obj2;
        offset += obj2.length;
        
        // Object 3: Page
        offsets[3] = offset;
        const obj3 = `3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${pdfW.toFixed(2)} ${pdfH.toFixed(2)}] /Contents 4 0 R /Resources << /XObject << /Img 5 0 R >> >> >>\nendobj\n`;
        pdfStr += obj3;
        offset += obj3.length;
        
        // Object 4: Content stream
        offsets[4] = offset;
        const obj4 = `4 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream\nendobj\n`;
        pdfStr += obj4;
        offset += obj4.length;
        
        // Object 5: Image XObject (header only, binary data follows)
        offsets[5] = offset;
        const imageHeader = `5 0 obj\n<< /Type /XObject /Subtype /Image /Width ${w * scale} /Height ${h * scale} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegLen} >>\nstream\n`;
        
        // Build binary PDF
        const headerPart = new TextEncoder().encode(pdfStr + imageHeader);
        const jpegPart = new Uint8Array(jpegLen);
        for (let i = 0; i < jpegLen; i++) {
            jpegPart[i] = jpegBytes.charCodeAt(i);
        }
        const streamEnd = new TextEncoder().encode('\nendstream\nendobj\n');
        
        // Calculate xref offset
        const xrefStart = headerPart.length + jpegPart.length + streamEnd.length;
        
        // Build xref table
        let xref = `xref\n0 6\n`;
        xref += '0000000000 65535 f \n';
        xref += String(offsets[1]).padStart(10, '0') + ' 00000 n \n';
        xref += String(offsets[2]).padStart(10, '0') + ' 00000 n \n';
        xref += String(offsets[3]).padStart(10, '0') + ' 00000 n \n';
        xref += String(offsets[4]).padStart(10, '0') + ' 00000 n \n';
        xref += String(pdfStr.length).padStart(10, '0') + ' 00000 n \n';
        
        const trailer = `trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`;
        const xrefPart = new TextEncoder().encode(xref + trailer);
        
        // Combine all parts
        const totalLen = headerPart.length + jpegPart.length + streamEnd.length + xrefPart.length;
        const pdfArray = new Uint8Array(totalLen);
        let pos = 0;
        pdfArray.set(headerPart, pos); pos += headerPart.length;
        pdfArray.set(jpegPart, pos); pos += jpegPart.length;
        pdfArray.set(streamEnd, pos); pos += streamEnd.length;
        pdfArray.set(xrefPart, pos);
        
        // Download
        const blob = new Blob([pdfArray], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `srnamap_${name}.pdf`;
        a.click();
        URL.revokeObjectURL(url);
    }

    expCovTSV() {
        const seg = document.getElementById('cov-seg').value;
        if (!seg || !this.M.refs[seg]) return;
        
        const reps = this.M.replicates;
        const len = this.M.refs[seg].length;
        
        // Calculate library sizes for CPM (per replicate)
        const libSizes = reps.map(r => Math.max(r.stats?.total || 1, 1));
        
        // Build comprehensive header with all data types for each replicate
        let tsv = 'segment\tposition\tsequence';
        for (let ri = 0; ri < reps.length; ri++) {
            const rn = reps[ri].name?.replace(/\.(fastq|fq|fasta|fa)(\.gz)?$/i, '') || `Rep${ri + 1}`;
            // Full coverage counts
            tsv += `\t${rn}_fwd_counts\t${rn}_rev_counts`;
            // 5' end coverage counts
            tsv += `\t${rn}_fwd_5end\t${rn}_rev_5end`;
            // 3' end coverage counts  
            tsv += `\t${rn}_fwd_3end\t${rn}_rev_3end`;
            // Full coverage CPM
            tsv += `\t${rn}_fwd_cpm\t${rn}_rev_cpm`;
            // 5' end CPM
            tsv += `\t${rn}_fwd_5end_cpm\t${rn}_rev_5end_cpm`;
            // 3' end CPM
            tsv += `\t${rn}_fwd_3end_cpm\t${rn}_rev_3end_cpm`;
        }
        // Total columns (sum across all replicates)
        tsv += '\ttotal_fwd_counts\ttotal_rev_counts\ttotal_fwd_5end\ttotal_rev_5end\ttotal_fwd_3end\ttotal_rev_3end';
        // Mean columns
        tsv += '\tmean_fwd_counts\tmean_rev_counts\tmean_fwd_5end\tmean_rev_5end\tmean_fwd_3end\tmean_rev_3end';
        tsv += '\tmean_fwd_cpm\tmean_rev_cpm\tmean_fwd_5end_cpm\tmean_rev_5end_cpm\tmean_fwd_3end_cpm\tmean_rev_3end_cpm';
        tsv += '\ttotal_counts\ttotal_cpm\n';
        
        const seq = this.M.refs[seg];
        
        // Check if we have per-replicate data or need to use cumulative
        const hasPerRepData = reps.some(rep => rep.covFwd && rep.covFwd[seg]);
        
        // Export every position (including zeros)
        for (let i = 0; i < len; i++) {
            tsv += `${seg}\t${i + 1}\t${seq[i]}`;
            
            let sumFwdC = 0, sumRevC = 0, sumFwd5 = 0, sumRev5 = 0, sumFwd3 = 0, sumRev3 = 0;
            let sumFwdCPM = 0, sumRevCPM = 0, sumFwd5CPM = 0, sumRev5CPM = 0, sumFwd3CPM = 0, sumRev3CPM = 0;
            
            for (let ri = 0; ri < reps.length; ri++) {
                const rep = reps[ri];
                const libSize = libSizes[ri];
                const cpmScale = 1e6 / libSize;
                
                // Get coverage values - use per-replicate if available, otherwise fall back to cumulative
                let fwdC, revC, fwd5, rev5, fwd3, rev3;
                
                if (hasPerRepData && rep.covFwd?.[seg]) {
                    // Use per-replicate data
                    fwdC = rep.covFwd[seg][i] || 0;
                    revC = rep.covRev?.[seg]?.[i] || 0;
                    fwd5 = rep.cov5Fwd?.[seg]?.[i] || 0;
                    rev5 = rep.cov5Rev?.[seg]?.[i] || 0;
                    fwd3 = rep.cov3Fwd?.[seg]?.[i] || 0;
                    rev3 = rep.cov3Rev?.[seg]?.[i] || 0;
                } else {
                    // Fall back to cumulative arrays (single replicate or no per-rep data)
                    // For single replicate, this is the same data
                    // For multiple replicates without per-rep tracking, divide by replicate count
                    const divisor = hasPerRepData ? 1 : reps.length;
                    fwdC = Math.round((this.M.covFwd?.[seg]?.[i] || 0) / divisor);
                    revC = Math.round((this.M.covRev?.[seg]?.[i] || 0) / divisor);
                    fwd5 = Math.round((this.M.cov5Fwd?.[seg]?.[i] || 0) / divisor);
                    rev5 = Math.round((this.M.cov5Rev?.[seg]?.[i] || 0) / divisor);
                    fwd3 = Math.round((this.M.cov3Fwd?.[seg]?.[i] || 0) / divisor);
                    rev3 = Math.round((this.M.cov3Rev?.[seg]?.[i] || 0) / divisor);
                }
                
                // CPM values
                const fwdCPM = fwdC * cpmScale;
                const revCPM = revC * cpmScale;
                const fwd5CPM = fwd5 * cpmScale;
                const rev5CPM = rev5 * cpmScale;
                const fwd3CPM = fwd3 * cpmScale;
                const rev3CPM = rev3 * cpmScale;
                
                // Write all values for this replicate
                tsv += `\t${fwdC}\t${revC}`;
                tsv += `\t${fwd5}\t${rev5}`;
                tsv += `\t${fwd3}\t${rev3}`;
                tsv += `\t${fwdCPM.toFixed(2)}\t${revCPM.toFixed(2)}`;
                tsv += `\t${fwd5CPM.toFixed(2)}\t${rev5CPM.toFixed(2)}`;
                tsv += `\t${fwd3CPM.toFixed(2)}\t${rev3CPM.toFixed(2)}`;
                
                // Accumulate for totals and means
                sumFwdC += fwdC; sumRevC += revC;
                sumFwd5 += fwd5; sumRev5 += rev5;
                sumFwd3 += fwd3; sumRev3 += rev3;
                sumFwdCPM += fwdCPM; sumRevCPM += revCPM;
                sumFwd5CPM += fwd5CPM; sumRev5CPM += rev5CPM;
                sumFwd3CPM += fwd3CPM; sumRev3CPM += rev3CPM;
            }
            
            // Write totals (sum across replicates)
            tsv += `\t${sumFwdC}\t${sumRevC}`;
            tsv += `\t${sumFwd5}\t${sumRev5}`;
            tsv += `\t${sumFwd3}\t${sumRev3}`;
            
            // Calculate and write means
            const n = reps.length || 1;
            const meanFwdC = sumFwdC / n;
            const meanRevC = sumRevC / n;
            const meanFwd5 = sumFwd5 / n;
            const meanRev5 = sumRev5 / n;
            const meanFwd3 = sumFwd3 / n;
            const meanRev3 = sumRev3 / n;
            const meanFwdCPM = sumFwdCPM / n;
            const meanRevCPM = sumRevCPM / n;
            const meanFwd5CPM = sumFwd5CPM / n;
            const meanRev5CPM = sumRev5CPM / n;
            const meanFwd3CPM = sumFwd3CPM / n;
            const meanRev3CPM = sumRev3CPM / n;
            
            tsv += `\t${meanFwdC.toFixed(1)}\t${meanRevC.toFixed(1)}`;
            tsv += `\t${meanFwd5.toFixed(1)}\t${meanRev5.toFixed(1)}`;
            tsv += `\t${meanFwd3.toFixed(1)}\t${meanRev3.toFixed(1)}`;
            tsv += `\t${meanFwdCPM.toFixed(2)}\t${meanRevCPM.toFixed(2)}`;
            tsv += `\t${meanFwd5CPM.toFixed(2)}\t${meanRev5CPM.toFixed(2)}`;
            tsv += `\t${meanFwd3CPM.toFixed(2)}\t${meanRev3CPM.toFixed(2)}`;
            tsv += `\t${(meanFwdC + meanRevC).toFixed(1)}\t${(meanFwdCPM + meanRevCPM).toFixed(2)}\n`;
        }
        
        this.dl(tsv, `srnamap_coverage_${seg}.tsv`, 'text/tsv');
    }

    expHistTSV(endType) {
        const { minLen, maxLen } = this.M.settings;
        let tsv = `replicate\tlength\tend\tA\tC\tG\tT\ttotal\n`;
        for (let ri = 0; ri < this.M.replicates.length; ri++) {
            const rep = this.M.replicates[ri];
            for (let l = minLen; l <= maxLen; l++) {
                const fwd = rep[`lenDist${endType}`].fwd[l] || { A: 0, C: 0, G: 0, T: 0 };
                const rev = rep[`lenDist${endType}`].rev[l] || { A: 0, C: 0, G: 0, T: 0 };
                const combined = { A: fwd.A + rev.A, C: fwd.C + rev.C, G: fwd.G + rev.G, T: fwd.T + rev.T };
                const total = combined.A + combined.C + combined.G + combined.T;
                tsv += `${ri + 1}\t${l}\t${endType}'\t${combined.A}\t${combined.C}\t${combined.G}\t${combined.T}\t${total}\n`;
            }
        }
        this.dl(tsv, `srnamap_hist${endType}.tsv`, 'text/tsv');
    }

    expLenTSV() {
        const { minLen, maxLen } = this.M.settings;
        let tsv = 'replicate\tlength\tstrand\tend\tA\tC\tG\tT\ttotal\n';
        for (let ri = 0; ri < this.M.replicates.length; ri++) {
            const rep = this.M.replicates[ri];
            for (let l = minLen; l <= maxLen; l++) {
                for (const strand of ['fwd', 'rev']) {
                    for (const end of ['5', '3']) {
                        const d = rep[`lenDist${end}`][strand][l] || { A: 0, C: 0, G: 0, T: 0 };
                        tsv += `${ri + 1}\t${l}\t${strand}\t${end}'\t${d.A}\t${d.C}\t${d.G}\t${d.T}\t${d.A + d.C + d.G + d.T}\n`;
                    }
                }
            }
        }
        this.dl(tsv, 'srnamap_length.tsv', 'text/tsv');
    }

    expOvlTSV() {
        const seg = document.getElementById('ovl-seg').value;
        const ovlData = this.ovlData[seg];
        const perRepData = this.ovlDataPerRep?.[seg];
        if (!ovlData) return;
        const { omin, omax, qmin, qmax, tmin, tmax } = this.ovlSettings || this.M.settings;
        
        // Build header with per-replicate columns
        const nReps = this.M.replicates.length;
        const repNames = this.M.replicates.map((r, i) => r.name || `Library_${i + 1}`);
        
        let header = 'segment\tlength\toverlap\tcount_mean\tcount_sem\tprobability_mean\tprob_sem\tcount_zscore_mean\tprob_zscore_mean';
        for (let i = 0; i < nReps; i++) {
            header += `\t${repNames[i]}_count\t${repNames[i]}_prob\t${repNames[i]}_count_z\t${repNames[i]}_prob_z`;
        }
        header += '\n';
        
        let tsv = header;
        
        for (const key of Object.keys(ovlData.counts)) {
            for (let ovl = omin; ovl <= omax; ovl++) {
                const c = ovlData.counts[key]?.[ovl] || 0;
                const p = ovlData.probs[key]?.[ovl] || 0;
                const cz = ovlData.countZscores?.[key]?.[ovl] || 0;
                const pz = ovlData.probZscores?.[key]?.[ovl] || 0;
                const cSem = ovlData.sem?.counts?.[key]?.[ovl] || 0;
                const pSem = ovlData.sem?.probs?.[key]?.[ovl] || 0;
                
                let row = `${seg}\t${key}\t${ovl}\t${c}\t${cSem}\t${p}\t${pSem}\t${cz}\t${pz}`;
                
                // Add per-replicate values
                for (let i = 0; i < nReps; i++) {
                    if (perRepData && perRepData[i]) {
                        const repC = perRepData[i]?.counts?.[key]?.[ovl] || 0;
                        const repP = perRepData[i]?.probs?.[key]?.[ovl] || 0;
                        const repCz = perRepData[i]?.countZscores?.[key]?.[ovl] || 0;
                        const repPz = perRepData[i]?.probZscores?.[key]?.[ovl] || 0;
                        row += `\t${repC}\t${repP}\t${repCz}\t${repPz}`;
                    } else if (ovlData.perRep?.counts?.[key]?.[ovl]) {
                        // Fall back to per-rep data stored in averaged ovlData
                        const repVals = ovlData.perRep;
                        const repC = repVals.counts?.[key]?.[ovl]?.[i] || 0;
                        const repP = repVals.probs?.[key]?.[ovl]?.[i] || 0;
                        const repCz = repVals.countZscores?.[key]?.[ovl]?.[i] || 0;
                        const repPz = repVals.probZscores?.[key]?.[ovl]?.[i] || 0;
                        row += `\t${repC}\t${repP}\t${repCz}\t${repPz}`;
                    } else {
                        row += `\t${c}\t${p}\t${cz}\t${pz}`; // Single replicate - use same values
                    }
                }
                tsv += row + '\n';
            }
        }
        this.dl(tsv, `srnamap_overlap_${seg}.tsv`, 'text/tsv');
    }

    expStats() {
        document.getElementById('prog-status').textContent = 'Preparing full export...';
        document.getElementById('progress').classList.add('show');
        document.getElementById('prog-bar').style.width = '10%';
        
        // Build comprehensive export with all data needed for full restoration
        const exportData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            
            // Reference sequences
            refs: this.M.refs,
            refOrder: this.M.refOrder,
            
            // Global settings
            settings: this.M.settings,
            
            // Global stats
            stats: this.M.stats,
            
            // Global coverage arrays (convert Uint32Array to regular arrays for JSON)
            covFwd: {},
            covRev: {},
            cov5Fwd: {},
            cov5Rev: {},
            
            // Replicates with all their data
            replicates: [],
            
            // Overlap data
            overlap: this.ovlData,
            ovlSettings: this.ovlSettings,
            ovlDataPerRep: this.ovlDataPerRep
        };
        
        document.getElementById('prog-bar').style.width = '20%';
        
        // Convert global coverage arrays
        for (const seg of this.M.refOrder) {
            if (this.M.covFwd[seg]) exportData.covFwd[seg] = Array.from(this.M.covFwd[seg]);
            if (this.M.covRev[seg]) exportData.covRev[seg] = Array.from(this.M.covRev[seg]);
            if (this.M.cov5Fwd[seg]) exportData.cov5Fwd[seg] = Array.from(this.M.cov5Fwd[seg]);
            if (this.M.cov5Rev[seg]) exportData.cov5Rev[seg] = Array.from(this.M.cov5Rev[seg]);
        }
        
        document.getElementById('prog-bar').style.width = '40%';
        
        // Export each replicate's data
        for (const rep of this.M.replicates) {
            const repExport = {
                name: rep.name,
                stats: rep.stats,
                
                // Coverage per segment
                covFwd: {},
                covRev: {},
                cov5Fwd: {},
                cov5Rev: {},
                
                // Length distributions
                lenDist5: rep.lenDist5 || null,
                lenDist3: rep.lenDist3 || null,
                lenDistBySeg: rep.lenDistBySeg || null,
                
                // Nucleotide bias
                bias: rep.bias || null,
                biasBySeg: rep.biasBySeg || null,
                
                // Mapped reads (for recalculation if needed)
                mappedReads: rep.mappedReads || {}
            };
            
            // Convert coverage Uint32Arrays to regular arrays
            for (const seg of this.M.refOrder) {
                if (rep.covFwd?.[seg]) repExport.covFwd[seg] = Array.from(rep.covFwd[seg]);
                if (rep.covRev?.[seg]) repExport.covRev[seg] = Array.from(rep.covRev[seg]);
                if (rep.cov5Fwd?.[seg]) repExport.cov5Fwd[seg] = Array.from(rep.cov5Fwd[seg]);
                if (rep.cov5Rev?.[seg]) repExport.cov5Rev[seg] = Array.from(rep.cov5Rev[seg]);
            }
            
            exportData.replicates.push(repExport);
        }
        
        document.getElementById('prog-bar').style.width = '70%';
        document.getElementById('prog-status').textContent = 'Generating JSON...';
        
        // Generate JSON string
        const jsonStr = JSON.stringify(exportData);
        
        document.getElementById('prog-bar').style.width = '90%';
        document.getElementById('prog-status').textContent = 'Downloading...';
        
        // Download
        this.dl(jsonStr, 'srnamap_full.json', 'application/json');
        
        document.getElementById('prog-bar').style.width = '100%';
        document.getElementById('prog-status').textContent = 'Export complete';
        document.getElementById('prog-stats').textContent = `Exported ${(jsonStr.length / 1024 / 1024).toFixed(2)} MB`;
    }
    
    exportStandaloneHTML() {
        const filename = (document.getElementById('export-filename').value || 'srnamap_report').replace(/[^a-zA-Z0-9_-]/g, '_');
        
        // Helper to convert canvas to SVG-like representation
        const canvasToSVG = (canvas) => {
            if (!canvas || canvas.width === 0) return null;
            const w = parseInt(canvas.style.width) || canvas.width;
            const h = parseInt(canvas.style.height) || canvas.height;
            // Get high-quality PNG with proper scaling
            const dataUrl = canvas.toDataURL('image/png', 1.0);
            return { dataUrl, w, h };
        };
        
        // Collect all figures for each segment
        const figures = {};
        
        // Get histogram SVGs (these are global, not per-segment)
        figures.hist5 = this.generateSVGFromCanvas('hist5-canvas');
        figures.hist3 = this.generateSVGFromCanvas('hist3-canvas');
        
        // Store current segment selections
        const origCovSeg = document.getElementById('cov-seg').value;
        const origLenSeg = document.getElementById('len-seg').value;
        const origBiasSeg = document.getElementById('bias-seg').value;
        const origOvlSeg = document.getElementById('ovl-seg').value;
        
        // Generate coverage, length dist, bias, and overlap for each segment
        figures.coverage = {};
        figures.length = {};
        figures.bias = {};
        figures.overlap = {};
        
        for (const seg of this.M.refOrder) {
            // Coverage per segment
            document.getElementById('cov-seg').value = seg;
            this.drawCov();
            figures.coverage[seg] = this.generateSVGFromCanvas('cov-canvas');
            
            // Overlap per segment
            document.getElementById('ovl-seg').value = seg;
            this.drawOvl();
            figures.overlap[seg] = this.generateSVGFromCanvas('ovl-canvas');
        }
        
        // Length distribution - do "all" and per-segment
        document.getElementById('len-seg').value = 'all';
        this.drawLen();
        figures.length['all'] = this.generateSVGFromCanvas('len-canvas');
        
        // Bias - do "all" and per-segment
        document.getElementById('bias-seg').value = 'all';
        this.drawBias();
        figures.bias['all'] = this.generateSVGFromCanvas('bias-canvas');
        
        for (const seg of this.M.refOrder) {
            document.getElementById('len-seg').value = seg;
            this.drawLen();
            figures.length[seg] = this.generateSVGFromCanvas('len-canvas');
            
            document.getElementById('bias-seg').value = seg;
            this.drawBias();
            figures.bias[seg] = this.generateSVGFromCanvas('bias-canvas');
        }
        
        // Restore original selections
        document.getElementById('cov-seg').value = origCovSeg;
        document.getElementById('len-seg').value = origLenSeg;
        document.getElementById('bias-seg').value = origBiasSeg;
        document.getElementById('ovl-seg').value = origOvlSeg;
        this.drawCov(); this.drawLen(); this.drawBias(); this.drawOvl();
        
        // Collect metadata
        const refName = document.getElementById('ref-info').textContent || 'Not specified';
        const stats = this.M.stats;
        const settings = this.M.settings;
        const segments = this.M.refOrder;
        const timestamp = new Date().toLocaleString();
        const biasEnd = document.getElementById('bias-end').value;
        const biasStrand = document.getElementById('bias-strand').value;
        
        // Build per-replicate table HTML
        let repTableHTML = '<table><thead><tr><th>File</th><th>Total Reads</th><th>Mapped</th><th>%</th>';
        for (const seg of segments) {
            const shortName = seg.length > 20 ? seg.slice(0, 17) + '...' : seg;
            repTableHTML += `<th title="${this.escapeHtml(seg)}">${this.escapeHtml(shortName)}</th>`;
        }
        repTableHTML += '</tr></thead><tbody>';
        
        for (let ri = 0; ri < this.M.replicates.length; ri++) {
            const rep = this.M.replicates[ri];
            const fileName = this.files[ri]?.name || `Rep ${ri + 1}`;
            const pct = rep.stats.total > 0 ? (rep.stats.mapped / rep.stats.total * 100).toFixed(1) : '0.0';
            const rowClass = rep.stats.mapped === 0 ? ' class="no-mapped"' : '';
            
            repTableHTML += `<tr${rowClass}>`;
            repTableHTML += `<td title="${this.escapeHtml(fileName)}">${this.escapeHtml(fileName.length > 30 ? fileName.slice(0, 27) + '...' : fileName)}</td>`;
            repTableHTML += `<td>${rep.stats.total.toLocaleString()}</td>`;
            repTableHTML += `<td><strong>${rep.stats.mapped.toLocaleString()}</strong></td>`;
            repTableHTML += `<td>${pct}%</td>`;
            
            for (const seg of segments) {
                const segMapped = rep.mappedReads[seg]?.length || 0;
                repTableHTML += `<td${segMapped === 0 ? ' class="zero"' : ''}>${segMapped.toLocaleString()}</td>`;
            }
            repTableHTML += '</tr>';
        }
        
        // Totals row
        repTableHTML += '<tr class="total"><td>TOTAL</td>';
        repTableHTML += `<td>${stats.total.toLocaleString()}</td>`;
        repTableHTML += `<td><strong>${stats.mapped.toLocaleString()}</strong></td>`;
        repTableHTML += `<td>${stats.total > 0 ? (stats.mapped / stats.total * 100).toFixed(1) : '0.0'}%</td>`;
        for (const seg of segments) {
            let segTotal = 0;
            for (const rep of this.M.replicates) segTotal += rep.mappedReads[seg]?.length || 0;
            repTableHTML += `<td>${segTotal.toLocaleString()}</td>`;
        }
        repTableHTML += '</tr></tbody></table>';
        
        // Build segment figures HTML
        let segmentFiguresHTML = '';
        for (const seg of segments) {
            const segLen = this.M.refs[seg]?.length || 0;
            segmentFiguresHTML += `
            <div class="segment-section">
                <h3 class="segment-header" onclick="toggleSegment(this)">${this.escapeHtml(seg)} <span class="seg-len">(${segLen.toLocaleString()} bp)</span> <span class="toggle-icon">‚ñº</span></h3>
                <div class="segment-content">
                    <div class="figure">
                        <h4>Coverage Profile</h4>
                        <div class="fig-container" onclick="expandFig(this)">
                            ${figures.coverage[seg] || '<p class="no-data">No data</p>'}
                        </div>
                        <p class="caption">Read coverage. Sense (+) above axis, antisense (‚àí) below.</p>
                    </div>
                    <div class="grid-2">
                        <div class="figure">
                            <h4>Length Distribution</h4>
                            <div class="fig-container" onclick="expandFig(this)">
                                ${figures.length[seg] || '<p class="no-data">No data</p>'}
                            </div>
                        </div>
                        <div class="figure">
                            <h4>Nucleotide Bias (${biasEnd}‚Ä≤, ${biasStrand})</h4>
                            <div class="fig-container" onclick="expandFig(this)">
                                ${figures.bias[seg] || '<p class="no-data">No data</p>'}
                            </div>
                        </div>
                    </div>
                    <div class="figure">
                        <h4>Overlap Signature Heatmap</h4>
                        <div class="fig-container" onclick="expandFig(this)">
                            ${figures.overlap[seg] || '<p class="no-data">No data</p>'}
                        </div>
                        <p class="caption">5‚Ä≤-to-5‚Ä≤ overlap distances. A 10nt peak indicates ping-pong amplification.</p>
                    </div>
                </div>
            </div>`;
        }
        
        // Build standalone HTML
        const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sRNAMap Report - ${this.escapeHtml(filename)}</title>
    <style>
        :root { --bg: #fff; --bg2: #f8f9fa; --bg3: #f0f2f4; --text: #1a1a2e; --text2: #3a4a5e; --muted: #5a6a7a; --accent: #0055bb; --border: #d0d8e0; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); font-size: 14px; line-height: 1.6; }
        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        header { margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 2px solid var(--accent); }
        h1 { font-size: 1.75rem; color: var(--accent); margin-bottom: 0.5rem; }
        h1 span { font-weight: normal; }
        h2 { font-size: 1.1rem; color: var(--text2); margin: 2rem 0 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
        h3 { font-size: 1rem; color: var(--text); margin-bottom: 0.75rem; }
        h4 { font-size: 0.85rem; color: var(--text2); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.03em; }
        .meta { background: var(--bg2); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem; margin-bottom: 1.5rem; }
        .meta-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem; }
        .meta-row { display: flex; }
        .meta-label { font-weight: 600; color: var(--text2); min-width: 130px; flex-shrink: 0; }
        .meta-value { color: var(--text); word-break: break-word; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .stat { background: var(--bg2); border: 1px solid var(--border); border-radius: 6px; padding: 0.75rem; text-align: center; }
        .stat-label { font-size: 0.65rem; text-transform: uppercase; color: var(--muted); letter-spacing: 0.03em; }
        .stat-value { font-size: 1.2rem; font-weight: 700; color: var(--accent); }
        
        /* Tables */
        .table-wrapper { overflow-x: auto; margin-bottom: 1.5rem; }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        th, td { padding: 8px 10px; border: 1px solid var(--border); text-align: right; }
        th { background: var(--bg3); font-weight: 600; color: var(--text2); text-align: right; }
        th:first-child, td:first-child { text-align: left; }
        tr.no-mapped { background: rgba(255,0,0,0.08); }
        tr.total { background: var(--bg3); font-weight: 600; }
        td.zero { color: var(--muted); }
        
        /* Figures */
        .figure { margin-bottom: 1.5rem; }
        .fig-container { cursor: pointer; border: 1px solid var(--border); border-radius: 4px; padding: 0.5rem; background: #fff; transition: box-shadow 0.2s; }
        .fig-container:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .fig-container svg { max-width: 100%; height: auto; display: block; }
        .caption { font-size: 0.8rem; color: var(--muted); margin-top: 0.5rem; font-style: italic; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .no-data { color: var(--muted); font-style: italic; padding: 2rem; text-align: center; }
        
        /* Segment sections */
        .segment-section { margin-bottom: 1rem; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .segment-header { background: var(--bg2); padding: 0.75rem 1rem; cursor: pointer; display: flex; align-items: center; justify-content: space-between; margin: 0; }
        .segment-header:hover { background: var(--bg3); }
        .seg-len { font-weight: normal; color: var(--muted); font-size: 0.85rem; margin-left: 0.5rem; }
        .toggle-icon { font-size: 0.8rem; color: var(--muted); transition: transform 0.2s; }
        .segment-header.collapsed .toggle-icon { transform: rotate(-90deg); }
        .segment-content { padding: 1rem; display: block; }
        .segment-content.hidden { display: none; }
        
        /* Modal for expanded figures */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; justify-content: center; align-items: center; }
        .modal.show { display: flex; }
        .modal-content { max-width: 95vw; max-height: 95vh; background: #fff; padding: 1rem; border-radius: 8px; overflow: auto; }
        .modal-content svg { max-width: 100%; height: auto; }
        .modal-close { position: fixed; top: 1rem; right: 1rem; background: #fff; border: none; font-size: 1.5rem; cursor: pointer; width: 40px; height: 40px; border-radius: 50%; }
        
        footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border); font-size: 0.75rem; color: var(--muted); text-align: center; }
        @media print { 
            .container { max-width: 100%; padding: 1rem; } 
            .segment-content { display: block !important; }
            .modal { display: none !important; }
        }
        @media (max-width: 768px) { .grid-2 { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>sRNA<span>Map</span> Analysis Report</h1>
        <p style="color:var(--muted);">Generated: ${timestamp}</p>
    </header>
    
    <section class="meta">
        <h3>Analysis Parameters</h3>
        <div class="meta-grid">
            <div class="meta-row"><span class="meta-label">Reference:</span><span class="meta-value">${this.escapeHtml(refName)}</span></div>
            <div class="meta-row"><span class="meta-label">Segments:</span><span class="meta-value">${segments.length}</span></div>
            <div class="meta-row"><span class="meta-label">Read length:</span><span class="meta-value">${settings.minLen}‚Äì${settings.maxLen} nt</span></div>
            <div class="meta-row"><span class="meta-label">k-mer size:</span><span class="meta-value">${settings.kmer}</span></div>
            <div class="meta-row"><span class="meta-label">Max mismatches:</span><span class="meta-value">${settings.maxMismatch}</span></div>
            <div class="meta-row"><span class="meta-label">Replicates:</span><span class="meta-value">${this.M.replicates.length}</span></div>
        </div>
    </section>
    
    <section class="stats">
        <div class="stat"><div class="stat-label">Total Reads</div><div class="stat-value">${stats.total.toLocaleString()}</div></div>
        <div class="stat"><div class="stat-label">Mapped</div><div class="stat-value">${stats.mapped.toLocaleString()}</div></div>
        <div class="stat"><div class="stat-label">Mapped %</div><div class="stat-value">${stats.total > 0 ? (stats.mapped / stats.total * 100).toFixed(1) : 0}%</div></div>
        <div class="stat"><div class="stat-label">Multi-mapped</div><div class="stat-value">${stats.multiMapped.toLocaleString()}</div></div>
    </section>
    
    <h2>Per-Replicate Mapping Summary</h2>
    <div class="table-wrapper">
        ${repTableHTML}
    </div>
    
    <h2>Global Read Length Distributions</h2>
    <p style="color:var(--muted);margin-bottom:1rem;font-size:0.85rem;">Click any figure to expand. These histograms show combined data across all segments.</p>
    <div class="grid-2">
        <div class="figure">
            <h4>5‚Ä≤ Bias Length Histogram</h4>
            <div class="fig-container" onclick="expandFig(this)">
                ${figures.hist5 || '<p class="no-data">No data</p>'}
            </div>
            <p class="caption">Read counts by length, colored by 5‚Ä≤ terminal nucleotide (A/C/G/U).</p>
        </div>
        <div class="figure">
            <h4>3‚Ä≤ Bias Length Histogram</h4>
            <div class="fig-container" onclick="expandFig(this)">
                ${figures.hist3 || '<p class="no-data">No data</p>'}
            </div>
            <p class="caption">Read counts by length, colored by 3‚Ä≤ terminal nucleotide.</p>
        </div>
    </div>
    
    <h2>Combined Analysis (All Segments)</h2>
    <div class="grid-2">
        <div class="figure">
            <h4>Length Distribution by Strand</h4>
            <div class="fig-container" onclick="expandFig(this)">
                ${figures.length['all'] || '<p class="no-data">No data</p>'}
            </div>
            <p class="caption">Forward reads (top) and reverse reads (bottom).</p>
        </div>
        <div class="figure">
            <h4>Nucleotide Bias (${biasEnd}‚Ä≤ end, ${biasStrand})</h4>
            <div class="fig-container" onclick="expandFig(this)">
                ${figures.bias['all'] || '<p class="no-data">No data</p>'}
            </div>
            <p class="caption">Positional nucleotide composition from ${biasEnd}‚Ä≤ end.</p>
        </div>
    </div>
    
    <h2>Per-Segment Analysis</h2>
    <p style="color:var(--muted);margin-bottom:1rem;font-size:0.85rem;">Click segment headers to expand/collapse. Each segment shows coverage, length distribution, nucleotide bias, and overlap signature.</p>
    ${segmentFiguresHTML}
    
    <footer>
        <p>Generated by sRNAMap v0.2.8 ‚Äî Rhys H Parry (r.parry@uq.edu.au)</p>
        <p>School of Chemistry and Molecular Biosciences, The University of Queensland</p>
    </footer>
</div>

<!-- Modal for expanded figures -->
<div class="modal" id="figModal" onclick="closeModal()">
    <button class="modal-close" onclick="closeModal()">&times;</button>
    <div class="modal-content" onclick="event.stopPropagation()"></div>
</div>

<` + `script>
function toggleSegment(header) {
    header.classList.toggle('collapsed');
    const content = header.nextElementSibling;
    content.classList.toggle('hidden');
}

function expandFig(container) {
    const modal = document.getElementById('figModal');
    const content = modal.querySelector('.modal-content');
    content.innerHTML = container.innerHTML;
    modal.classList.add('show');
}

function closeModal() {
    document.getElementById('figModal').classList.remove('show');
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeModal();
});

// Collapse all segments by default except first
document.querySelectorAll('.segment-header').forEach((h, i) => {
    if (i > 0) {
        h.classList.add('collapsed');
        h.nextElementSibling.classList.add('hidden');
    }
});
</` + `script>
</body>
</html>`;
        
        this.dl(html, filename + '.html', 'text/html');
    }
    
    generateSVGFromCanvas(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas || canvas.width === 0) return null;
        
        const w = parseInt(canvas.style.width) || canvas.width;
        const h = parseInt(canvas.style.height) || canvas.height;
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        // Create SVG wrapper with embedded high-res image
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" width="${w}" height="${h}">
            <image href="${dataUrl}" width="${w}" height="${h}" />
        </svg>`;
    }
    
    escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str || '';
        return div.innerHTML;
    }

    dl(content, filename, mime) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([content], { type: mime }));
        a.download = filename; a.click(); URL.revokeObjectURL(a.href);
    }

    resetAll() {
        this.M.stop = true; this.M.running = false; this.M.refs = {}; this.M.refOrder = [];
        this.files = []; this.ovlData = {}; this.ovlSettings = {}; this.aggData = null; this.plotInfo = {};
        document.getElementById('ref-info').classList.remove('show');
        document.getElementById('ref-text').value = '';
        document.getElementById('reads-info').classList.remove('show');
        document.getElementById('progress').classList.remove('show');
        document.getElementById('results').classList.remove('show');
        document.getElementById('run-btn').disabled = true;
        document.getElementById('rep-info').textContent = '';
        document.getElementById('cov-seg').innerHTML = '';
        document.getElementById('len-seg').innerHTML = '';
        document.getElementById('bias-seg').innerHTML = '';
        document.getElementById('ovl-seg').innerHTML = '';
        ['hist5-canvas', 'hist3-canvas', 'cov-canvas', 'len-canvas', 'bias-canvas', 'ovl-canvas'].forEach(id => {
            const c = document.getElementById(id), ctx = c.getContext('2d');
            ctx.clearRect(0, 0, c.width, c.height);
        });
    }
}

document.addEventListener('DOMContentLoaded', () => { 
    // Prevent browser from opening files dropped outside drop zones
    ['dragenter', 'dragover', 'drop'].forEach(evt => {
        document.body.addEventListener(evt, e => {
            if (!e.target.closest('.drop')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'none';
            }
        });
    });
    window.srnamap = new UI(); 
});
</script>
</body>
</html>
